'use strict';

var require$$1 = require('util');
var require$$0$1 = require('stream');
var require$$1$1 = require('path');
var require$$3 = require('http');
var require$$4 = require('https');
var require$$0$2 = require('url');
var require$$6 = require('fs');
var require$$4$1 = require('assert');
var require$$1$2 = require('tty');
var require$$0$3 = require('os');
var require$$7 = require('zlib');
var require$$9 = require('events');
var require$$0$4 = require('crypto');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
var require$$6__default = /*#__PURE__*/_interopDefaultLegacy(require$$6);
var require$$4__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$4$1);
var require$$1__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var require$$7__default = /*#__PURE__*/_interopDefaultLegacy(require$$7);
var require$$9__default = /*#__PURE__*/_interopDefaultLegacy(require$$9);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var roxBase = {exports: {}};

var delayed_stream;
var hasRequiredDelayed_stream;

function requireDelayed_stream () {
	if (hasRequiredDelayed_stream) return delayed_stream;
	hasRequiredDelayed_stream = 1;
	var Stream = require$$0__default["default"].Stream;
	var util = require$$1__default["default"];

	delayed_stream = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;

	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);

	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }

	  delayedStream.source = source;

	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };

	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }

	  return delayedStream;
	};

	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});

	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};

	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }

	  this.source.resume();
	};

	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};

	DelayedStream.prototype.release = function() {
	  this._released = true;

	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};

	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};

	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }

	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }

	  this._bufferedEvents.push(args);
	};

	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }

	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this.emit('error', new Error(message));
	};
	return delayed_stream;
}

var combined_stream;
var hasRequiredCombined_stream;

function requireCombined_stream () {
	if (hasRequiredCombined_stream) return combined_stream;
	hasRequiredCombined_stream = 1;
	var util = require$$1__default["default"];
	var Stream = require$$0__default["default"].Stream;
	var DelayedStream = requireDelayed_stream();

	combined_stream = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;

	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	  this._insideLoop = false;
	  this._pendingNext = false;
	}
	util.inherits(CombinedStream, Stream);

	CombinedStream.create = function(options) {
	  var combinedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }

	  return combinedStream;
	};

	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!Buffer.isBuffer(stream));
	};

	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);

	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }

	    this._handleErrors(stream);

	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }

	  this._streams.push(stream);
	  return this;
	};

	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};

	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;

	  if (this._insideLoop) {
	    this._pendingNext = true;
	    return; // defer call
	  }

	  this._insideLoop = true;
	  try {
	    do {
	      this._pendingNext = false;
	      this._realGetNext();
	    } while (this._pendingNext);
	  } finally {
	    this._insideLoop = false;
	  }
	};

	CombinedStream.prototype._realGetNext = function() {
	  var stream = this._streams.shift();


	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }

	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }

	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }

	    this._pipeNext(stream);
	  }.bind(this));
	};

	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;

	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }

	  var value = stream;
	  this.write(value);
	  this._getNext();
	};

	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};

	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};

	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};

	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};

	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};

	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};

	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};

	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};

	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;

	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }

	    self.dataSize += stream.dataSize;
	  });

	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};

	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};
	return combined_stream;
}

var mimeTypes = {};

var mimeDb = {exports: {}};

var require$$0 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/ace+cbor": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/at+jwt": {
	source: "iana"
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/city+json": {
	source: "iana",
	compressible: true
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cpl"
	]
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dash-patch+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpp"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/express": {
	source: "iana",
	extensions: [
		"exp"
	]
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpf"
	]
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/oblivious-dns-message": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21": {
	source: "iana"
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana",
	extensions: [
		"asc"
	]
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spdx+json": {
	source: "iana",
	compressible: true
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/token-introspection+jwt": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.age": {
	source: "iana",
	extensions: [
		"age"
	]
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.eclipse.ditto+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eu.kasparian.car+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.familysearch.gedcom+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hl7cda+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hl7v2+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxar.archive.3tz+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.nacamar.ybrid+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.syft+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wif"
	]
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-iwork-keynote-sffkey": {
	extensions: [
		"key"
	]
},
	"application/x-iwork-numbers-sffnumbers": {
	extensions: [
		"numbers"
	]
},
	"application/x-iwork-pages-sffpages": {
	extensions: [
		"pages"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana",
	extensions: [
		"avci"
	]
},
	"image/avcs": {
	source: "iana",
	extensions: [
		"avcs"
	]
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	compressible: true,
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step": {
	source: "iana"
},
	"model/step+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"stpx"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.familysearch.gedcom": {
	source: "iana",
	extensions: [
		"ged"
	]
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/jxsv": {
	source: "iana"
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeDb;

function requireMimeDb () {
	if (hasRequiredMimeDb) return mimeDb.exports;
	hasRequiredMimeDb = 1;
	(function (module) {
		/**
		 * Module exports.
		 */

		module.exports = require$$0;
} (mimeDb));
	return mimeDb.exports;
}

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredMimeTypes;

function requireMimeTypes () {
	if (hasRequiredMimeTypes) return mimeTypes;
	hasRequiredMimeTypes = 1;
	(function (exports) {

		/**
		 * Module dependencies.
		 * @private
		 */

		var db = requireMimeDb();
		var extname = require$$1__default$1["default"].extname;

		/**
		 * Module variables.
		 * @private
		 */

		var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
		var TEXT_TYPE_REGEXP = /^text\//i;

		/**
		 * Module exports.
		 * @public
		 */

		exports.charset = charset;
		exports.charsets = { lookup: charset };
		exports.contentType = contentType;
		exports.extension = extension;
		exports.extensions = Object.create(null);
		exports.lookup = lookup;
		exports.types = Object.create(null);

		// Populate the extensions/types maps
		populateMaps(exports.extensions, exports.types);

		/**
		 * Get the default charset for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function charset (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);
		  var mime = match && db[match[1].toLowerCase()];

		  if (mime && mime.charset) {
		    return mime.charset
		  }

		  // default text/* to utf-8
		  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
		    return 'UTF-8'
		  }

		  return false
		}

		/**
		 * Create a full Content-Type header given a MIME type or extension.
		 *
		 * @param {string} str
		 * @return {boolean|string}
		 */

		function contentType (str) {
		  // TODO: should this even be in this module?
		  if (!str || typeof str !== 'string') {
		    return false
		  }

		  var mime = str.indexOf('/') === -1
		    ? exports.lookup(str)
		    : str;

		  if (!mime) {
		    return false
		  }

		  // TODO: use content-type or other module
		  if (mime.indexOf('charset') === -1) {
		    var charset = exports.charset(mime);
		    if (charset) mime += '; charset=' + charset.toLowerCase();
		  }

		  return mime
		}

		/**
		 * Get the default extension for a MIME type.
		 *
		 * @param {string} type
		 * @return {boolean|string}
		 */

		function extension (type) {
		  if (!type || typeof type !== 'string') {
		    return false
		  }

		  // TODO: use media-typer
		  var match = EXTRACT_TYPE_REGEXP.exec(type);

		  // get extensions
		  var exts = match && exports.extensions[match[1].toLowerCase()];

		  if (!exts || !exts.length) {
		    return false
		  }

		  return exts[0]
		}

		/**
		 * Lookup the MIME type for a file path/extension.
		 *
		 * @param {string} path
		 * @return {boolean|string}
		 */

		function lookup (path) {
		  if (!path || typeof path !== 'string') {
		    return false
		  }

		  // get the extension ("ext" or ".ext" or full path)
		  var extension = extname('x.' + path)
		    .toLowerCase()
		    .substr(1);

		  if (!extension) {
		    return false
		  }

		  return exports.types[extension] || false
		}

		/**
		 * Populate the extensions and types maps.
		 * @private
		 */

		function populateMaps (extensions, types) {
		  // source preference (least -> most)
		  var preference = ['nginx', 'apache', undefined, 'iana'];

		  Object.keys(db).forEach(function forEachMimeType (type) {
		    var mime = db[type];
		    var exts = mime.extensions;

		    if (!exts || !exts.length) {
		      return
		    }

		    // mime -> extensions
		    extensions[type] = exts;

		    // extension -> mime
		    for (var i = 0; i < exts.length; i++) {
		      var extension = exts[i];

		      if (types[extension]) {
		        var from = preference.indexOf(db[types[extension]].source);
		        var to = preference.indexOf(mime.source);

		        if (types[extension] !== 'application/octet-stream' &&
		          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
		          // skip the remapping
		          continue
		        }
		      }

		      // set the extension -> mime
		      types[extension] = type;
		    }
		  });
		}
} (mimeTypes));
	return mimeTypes;
}

var defer_1;
var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer_1;
	hasRequiredDefer = 1;
	defer_1 = defer;

	/**
	 * Runs provided function on next iteration of the event loop
	 *
	 * @param {function} fn - function to run
	 */
	function defer(fn)
	{
	  var nextTick = typeof setImmediate == 'function'
	    ? setImmediate
	    : (
	      typeof process == 'object' && typeof process.nextTick == 'function'
	      ? process.nextTick
	      : null
	    );

	  if (nextTick)
	  {
	    nextTick(fn);
	  }
	  else
	  {
	    setTimeout(fn, 0);
	  }
	}
	return defer_1;
}

var async_1;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async_1;
	hasRequiredAsync = 1;
	var defer = requireDefer();

	// API
	async_1 = async;

	/**
	 * Runs provided callback asynchronously
	 * even if callback itself is not
	 *
	 * @param   {function} callback - callback to invoke
	 * @returns {function} - augmented callback
	 */
	function async(callback)
	{
	  var isAsync = false;

	  // check if async happened
	  defer(function() { isAsync = true; });

	  return function async_callback(err, result)
	  {
	    if (isAsync)
	    {
	      callback(err, result);
	    }
	    else
	    {
	      defer(function nextTick_callback()
	      {
	        callback(err, result);
	      });
	    }
	  };
	}
	return async_1;
}

var abort_1;
var hasRequiredAbort;

function requireAbort () {
	if (hasRequiredAbort) return abort_1;
	hasRequiredAbort = 1;
	// API
	abort_1 = abort;

	/**
	 * Aborts leftover active jobs
	 *
	 * @param {object} state - current state object
	 */
	function abort(state)
	{
	  Object.keys(state.jobs).forEach(clean.bind(state));

	  // reset leftover jobs
	  state.jobs = {};
	}

	/**
	 * Cleans up leftover job by invoking abort function for the provided job id
	 *
	 * @this  state
	 * @param {string|number} key - job id to abort
	 */
	function clean(key)
	{
	  if (typeof this.jobs[key] == 'function')
	  {
	    this.jobs[key]();
	  }
	}
	return abort_1;
}

var iterate_1;
var hasRequiredIterate;

function requireIterate () {
	if (hasRequiredIterate) return iterate_1;
	hasRequiredIterate = 1;
	var async = requireAsync()
	  , abort = requireAbort()
	  ;

	// API
	iterate_1 = iterate;

	/**
	 * Iterates over each job object
	 *
	 * @param {array|object} list - array or object (named list) to iterate over
	 * @param {function} iterator - iterator to run
	 * @param {object} state - current job status
	 * @param {function} callback - invoked when all elements processed
	 */
	function iterate(list, iterator, state, callback)
	{
	  // store current index
	  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

	  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
	  {
	    // don't repeat yourself
	    // skip secondary callbacks
	    if (!(key in state.jobs))
	    {
	      return;
	    }

	    // clean up jobs
	    delete state.jobs[key];

	    if (error)
	    {
	      // don't process rest of the results
	      // stop still active jobs
	      // and reset the list
	      abort(state);
	    }
	    else
	    {
	      state.results[key] = output;
	    }

	    // return salvaged results
	    callback(error, state.results);
	  });
	}

	/**
	 * Runs iterator over provided job element
	 *
	 * @param   {function} iterator - iterator to invoke
	 * @param   {string|number} key - key/index of the element in the list of jobs
	 * @param   {mixed} item - job description
	 * @param   {function} callback - invoked after iterator is done with the job
	 * @returns {function|mixed} - job abort function or something else
	 */
	function runJob(iterator, key, item, callback)
	{
	  var aborter;

	  // allow shortcut if iterator expects only two arguments
	  if (iterator.length == 2)
	  {
	    aborter = iterator(item, async(callback));
	  }
	  // otherwise go with full three arguments
	  else
	  {
	    aborter = iterator(item, key, async(callback));
	  }

	  return aborter;
	}
	return iterate_1;
}

var state_1;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state_1;
	hasRequiredState = 1;
	// API
	state_1 = state;

	/**
	 * Creates initial state object
	 * for iteration over list
	 *
	 * @param   {array|object} list - list to iterate over
	 * @param   {function|null} sortMethod - function to use for keys sort,
	 *                                     or `null` to keep them as is
	 * @returns {object} - initial state object
	 */
	function state(list, sortMethod)
	{
	  var isNamedList = !Array.isArray(list)
	    , initState =
	    {
	      index    : 0,
	      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
	      jobs     : {},
	      results  : isNamedList ? {} : [],
	      size     : isNamedList ? Object.keys(list).length : list.length
	    }
	    ;

	  if (sortMethod)
	  {
	    // sort array keys based on it's values
	    // sort object's keys just on own merit
	    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
	    {
	      return sortMethod(list[a], list[b]);
	    });
	  }

	  return initState;
	}
	return state_1;
}

var terminator_1;
var hasRequiredTerminator;

function requireTerminator () {
	if (hasRequiredTerminator) return terminator_1;
	hasRequiredTerminator = 1;
	var abort = requireAbort()
	  , async = requireAsync()
	  ;

	// API
	terminator_1 = terminator;

	/**
	 * Terminates jobs in the attached state context
	 *
	 * @this  AsyncKitState#
	 * @param {function} callback - final callback to invoke after termination
	 */
	function terminator(callback)
	{
	  if (!Object.keys(this.jobs).length)
	  {
	    return;
	  }

	  // fast forward iteration index
	  this.index = this.size;

	  // abort jobs
	  abort(this);

	  // send back results we have so far
	  async(callback)(null, this.results);
	}
	return terminator_1;
}

var parallel_1;
var hasRequiredParallel;

function requireParallel () {
	if (hasRequiredParallel) return parallel_1;
	hasRequiredParallel = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	parallel_1 = parallel;

	/**
	 * Runs iterator over provided array elements in parallel
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function parallel(list, iterator, callback)
	{
	  var state = initState(list);

	  while (state.index < (state['keyedList'] || list).length)
	  {
	    iterate(list, iterator, state, function(error, result)
	    {
	      if (error)
	      {
	        callback(error, result);
	        return;
	      }

	      // looks like it's the last one
	      if (Object.keys(state.jobs).length === 0)
	      {
	        callback(null, state.results);
	        return;
	      }
	    });

	    state.index++;
	  }

	  return terminator.bind(state, callback);
	}
	return parallel_1;
}

var serialOrdered = {exports: {}};

var hasRequiredSerialOrdered;

function requireSerialOrdered () {
	if (hasRequiredSerialOrdered) return serialOrdered.exports;
	hasRequiredSerialOrdered = 1;
	var iterate    = requireIterate()
	  , initState  = requireState()
	  , terminator = requireTerminator()
	  ;

	// Public API
	serialOrdered.exports = serialOrdered$1;
	// sorting helpers
	serialOrdered.exports.ascending  = ascending;
	serialOrdered.exports.descending = descending;

	/**
	 * Runs iterator over provided sorted array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} sortMethod - custom sort function
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serialOrdered$1(list, iterator, sortMethod, callback)
	{
	  var state = initState(list, sortMethod);

	  iterate(list, iterator, state, function iteratorHandler(error, result)
	  {
	    if (error)
	    {
	      callback(error, result);
	      return;
	    }

	    state.index++;

	    // are we there yet?
	    if (state.index < (state['keyedList'] || list).length)
	    {
	      iterate(list, iterator, state, iteratorHandler);
	      return;
	    }

	    // done here
	    callback(null, state.results);
	  });

	  return terminator.bind(state, callback);
	}

	/*
	 * -- Sort methods
	 */

	/**
	 * sort helper to sort array elements in ascending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function ascending(a, b)
	{
	  return a < b ? -1 : a > b ? 1 : 0;
	}

	/**
	 * sort helper to sort array elements in descending order
	 *
	 * @param   {mixed} a - an item to compare
	 * @param   {mixed} b - an item to compare
	 * @returns {number} - comparison result
	 */
	function descending(a, b)
	{
	  return -1 * ascending(a, b);
	}
	return serialOrdered.exports;
}

var serial_1;
var hasRequiredSerial;

function requireSerial () {
	if (hasRequiredSerial) return serial_1;
	hasRequiredSerial = 1;
	var serialOrdered = requireSerialOrdered();

	// Public API
	serial_1 = serial;

	/**
	 * Runs iterator over provided array elements in series
	 *
	 * @param   {array|object} list - array or object (named list) to iterate over
	 * @param   {function} iterator - iterator to run
	 * @param   {function} callback - invoked when all elements processed
	 * @returns {function} - jobs terminator
	 */
	function serial(list, iterator, callback)
	{
	  return serialOrdered(list, iterator, null, callback);
	}
	return serial_1;
}

var asynckit;
var hasRequiredAsynckit;

function requireAsynckit () {
	if (hasRequiredAsynckit) return asynckit;
	hasRequiredAsynckit = 1;
	asynckit =
	{
	  parallel      : requireParallel(),
	  serial        : requireSerial(),
	  serialOrdered : requireSerialOrdered()
	};
	return asynckit;
}

var populate;
var hasRequiredPopulate;

function requirePopulate () {
	if (hasRequiredPopulate) return populate;
	hasRequiredPopulate = 1;
	// populates missing values
	populate = function(dst, src) {

	  Object.keys(src).forEach(function(prop)
	  {
	    dst[prop] = dst[prop] || src[prop];
	  });

	  return dst;
	};
	return populate;
}

var form_data;
var hasRequiredForm_data;

function requireForm_data () {
	if (hasRequiredForm_data) return form_data;
	hasRequiredForm_data = 1;
	var CombinedStream = requireCombined_stream();
	var util = require$$1__default["default"];
	var path = require$$1__default$1["default"];
	var http = require$$3__default["default"];
	var https = require$$4__default["default"];
	var parseUrl = require$$0__default$1["default"].parse;
	var fs = require$$6__default["default"];
	var Stream = require$$0__default["default"].Stream;
	var mime = requireMimeTypes();
	var asynckit = requireAsynckit();
	var populate = requirePopulate();

	// Public API
	form_data = FormData;

	// make it a Stream
	util.inherits(FormData, CombinedStream);

	/**
	 * Create readable "multipart/form-data" streams.
	 * Can be used to submit forms
	 * and file uploads to other web applications.
	 *
	 * @constructor
	 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
	 */
	function FormData(options) {
	  if (!(this instanceof FormData)) {
	    return new FormData(options);
	  }

	  this._overheadLength = 0;
	  this._valueLength = 0;
	  this._valuesToMeasure = [];

	  CombinedStream.call(this);

	  options = options || {};
	  for (var option in options) {
	    this[option] = options[option];
	  }
	}

	FormData.LINE_BREAK = '\r\n';
	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

	FormData.prototype.append = function(field, value, options) {

	  options = options || {};

	  // allow filename as single option
	  if (typeof options == 'string') {
	    options = {filename: options};
	  }

	  var append = CombinedStream.prototype.append.bind(this);

	  // all that streamy business can't handle numbers
	  if (typeof value == 'number') {
	    value = '' + value;
	  }

	  // https://github.com/felixge/node-form-data/issues/38
	  if (util.isArray(value)) {
	    // Please convert your array into string
	    // the way web server expects it
	    this._error(new Error('Arrays are not supported.'));
	    return;
	  }

	  var header = this._multiPartHeader(field, value, options);
	  var footer = this._multiPartFooter();

	  append(header);
	  append(value);
	  append(footer);

	  // pass along options.knownLength
	  this._trackLength(header, value, options);
	};

	FormData.prototype._trackLength = function(header, value, options) {
	  var valueLength = 0;

	  // used w/ getLengthSync(), when length is known.
	  // e.g. for streaming directly from a remote server,
	  // w/ a known file a size, and not wanting to wait for
	  // incoming file to finish to get its size.
	  if (options.knownLength != null) {
	    valueLength += +options.knownLength;
	  } else if (Buffer.isBuffer(value)) {
	    valueLength = value.length;
	  } else if (typeof value === 'string') {
	    valueLength = Buffer.byteLength(value);
	  }

	  this._valueLength += valueLength;

	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	  this._overheadLength +=
	    Buffer.byteLength(header) +
	    FormData.LINE_BREAK.length;

	  // empty or either doesn't have path or not an http response or not a stream
	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
	    return;
	  }

	  // no need to bother with the length
	  if (!options.knownLength) {
	    this._valuesToMeasure.push(value);
	  }
	};

	FormData.prototype._lengthRetriever = function(value, callback) {

	  if (value.hasOwnProperty('fd')) {

	    // take read range into a account
	    // `end` = Infinity > read file till the end
	    //
	    // TODO: Looks like there is bug in Node fs.createReadStream
	    // it doesn't respect `end` options without `start` options
	    // Fix it when node fixes it.
	    // https://github.com/joyent/node/issues/7819
	    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

	      // when end specified
	      // no need to calculate range
	      // inclusive, starts with 0
	      callback(null, value.end + 1 - (value.start ? value.start : 0));

	    // not that fast snoopy
	    } else {
	      // still need to fetch file size from fs
	      fs.stat(value.path, function(err, stat) {

	        var fileSize;

	        if (err) {
	          callback(err);
	          return;
	        }

	        // update final size based on the range options
	        fileSize = stat.size - (value.start ? value.start : 0);
	        callback(null, fileSize);
	      });
	    }

	  // or http response
	  } else if (value.hasOwnProperty('httpVersion')) {
	    callback(null, +value.headers['content-length']);

	  // or request stream http://github.com/mikeal/request
	  } else if (value.hasOwnProperty('httpModule')) {
	    // wait till response come back
	    value.on('response', function(response) {
	      value.pause();
	      callback(null, +response.headers['content-length']);
	    });
	    value.resume();

	  // something else
	  } else {
	    callback('Unknown stream');
	  }
	};

	FormData.prototype._multiPartHeader = function(field, value, options) {
	  // custom header specified (as string)?
	  // it becomes responsible for boundary
	  // (e.g. to handle extra CRLFs on .NET servers)
	  if (typeof options.header == 'string') {
	    return options.header;
	  }

	  var contentDisposition = this._getContentDisposition(value, options);
	  var contentType = this._getContentType(value, options);

	  var contents = '';
	  var headers  = {
	    // add custom disposition as third element or keep it two elements if not
	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    // if no content type. allow it to be empty array
	    'Content-Type': [].concat(contentType || [])
	  };

	  // allow custom headers.
	  if (typeof options.header == 'object') {
	    populate(headers, options.header);
	  }

	  var header;
	  for (var prop in headers) {
	    if (!headers.hasOwnProperty(prop)) continue;
	    header = headers[prop];

	    // skip nullish headers.
	    if (header == null) {
	      continue;
	    }

	    // convert all headers to arrays.
	    if (!Array.isArray(header)) {
	      header = [header];
	    }

	    // add non-empty headers.
	    if (header.length) {
	      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
	    }
	  }

	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	};

	FormData.prototype._getContentDisposition = function(value, options) {

	  var filename
	    , contentDisposition
	    ;

	  if (typeof options.filepath === 'string') {
	    // custom filepath for relative paths
	    filename = path.normalize(options.filepath).replace(/\\/g, '/');
	  } else if (options.filename || value.name || value.path) {
	    // custom filename take precedence
	    // formidable and the browser add a name property
	    // fs- and request- streams have path property
	    filename = path.basename(options.filename || value.name || value.path);
	  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
	    // or try http response
	    filename = path.basename(value.client._httpMessage.path || '');
	  }

	  if (filename) {
	    contentDisposition = 'filename="' + filename + '"';
	  }

	  return contentDisposition;
	};

	FormData.prototype._getContentType = function(value, options) {

	  // use custom content-type above all
	  var contentType = options.contentType;

	  // or try `name` from formidable, browser
	  if (!contentType && value.name) {
	    contentType = mime.lookup(value.name);
	  }

	  // or try `path` from fs-, request- streams
	  if (!contentType && value.path) {
	    contentType = mime.lookup(value.path);
	  }

	  // or if it's http-reponse
	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    contentType = value.headers['content-type'];
	  }

	  // or guess it from the filepath or filename
	  if (!contentType && (options.filepath || options.filename)) {
	    contentType = mime.lookup(options.filepath || options.filename);
	  }

	  // fallback to the default content type if `value` is not simple value
	  if (!contentType && typeof value == 'object') {
	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	  }

	  return contentType;
	};

	FormData.prototype._multiPartFooter = function() {
	  return function(next) {
	    var footer = FormData.LINE_BREAK;

	    var lastPart = (this._streams.length === 0);
	    if (lastPart) {
	      footer += this._lastBoundary();
	    }

	    next(footer);
	  }.bind(this);
	};

	FormData.prototype._lastBoundary = function() {
	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	};

	FormData.prototype.getHeaders = function(userHeaders) {
	  var header;
	  var formHeaders = {
	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	  };

	  for (header in userHeaders) {
	    if (userHeaders.hasOwnProperty(header)) {
	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    }
	  }

	  return formHeaders;
	};

	FormData.prototype.setBoundary = function(boundary) {
	  this._boundary = boundary;
	};

	FormData.prototype.getBoundary = function() {
	  if (!this._boundary) {
	    this._generateBoundary();
	  }

	  return this._boundary;
	};

	FormData.prototype.getBuffer = function() {
	  var dataBuffer = new Buffer.alloc( 0 );
	  var boundary = this.getBoundary();

	  // Create the form content. Add Line breaks to the end of data.
	  for (var i = 0, len = this._streams.length; i < len; i++) {
	    if (typeof this._streams[i] !== 'function') {

	      // Add content to the buffer.
	      if(Buffer.isBuffer(this._streams[i])) {
	        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
	      }else {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
	      }

	      // Add break after content.
	      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
	        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
	      }
	    }
	  }

	  // Add the footer and return the Buffer object.
	  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
	};

	FormData.prototype._generateBoundary = function() {
	  // This generates a 50 character boundary similar to those used by Firefox.
	  // They are optimized for boyer-moore parsing.
	  var boundary = '--------------------------';
	  for (var i = 0; i < 24; i++) {
	    boundary += Math.floor(Math.random() * 10).toString(16);
	  }

	  this._boundary = boundary;
	};

	// Note: getLengthSync DOESN'T calculate streams length
	// As workaround one can calculate file size manually
	// and add it as knownLength option
	FormData.prototype.getLengthSync = function() {
	  var knownLength = this._overheadLength + this._valueLength;

	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	  // so it basically checks if there is any value added to the form
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  // https://github.com/form-data/form-data/issues/40
	  if (!this.hasKnownLength()) {
	    // Some async length retrievers are present
	    // therefore synchronous length calculation is false.
	    // Please use getLength(callback) to get proper length
	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	  }

	  return knownLength;
	};

	// Public API to check if length of added values is known
	// https://github.com/form-data/form-data/issues/196
	// https://github.com/form-data/form-data/issues/262
	FormData.prototype.hasKnownLength = function() {
	  var hasKnownLength = true;

	  if (this._valuesToMeasure.length) {
	    hasKnownLength = false;
	  }

	  return hasKnownLength;
	};

	FormData.prototype.getLength = function(cb) {
	  var knownLength = this._overheadLength + this._valueLength;

	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }

	  if (!this._valuesToMeasure.length) {
	    process.nextTick(cb.bind(this, null, knownLength));
	    return;
	  }

	  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
	    if (err) {
	      cb(err);
	      return;
	    }

	    values.forEach(function(length) {
	      knownLength += length;
	    });

	    cb(null, knownLength);
	  });
	};

	FormData.prototype.submit = function(params, cb) {
	  var request
	    , options
	    , defaults = {method: 'post'}
	    ;

	  // parse provided url if it's string
	  // or treat it as options object
	  if (typeof params == 'string') {

	    params = parseUrl(params);
	    options = populate({
	      port: params.port,
	      path: params.pathname,
	      host: params.hostname,
	      protocol: params.protocol
	    }, defaults);

	  // use custom params
	  } else {

	    options = populate(params, defaults);
	    // if no port provided use default one
	    if (!options.port) {
	      options.port = options.protocol == 'https:' ? 443 : 80;
	    }
	  }

	  // put that good code in getHeaders to some use
	  options.headers = this.getHeaders(params.headers);

	  // https if specified, fallback to http in any other case
	  if (options.protocol == 'https:') {
	    request = https.request(options);
	  } else {
	    request = http.request(options);
	  }

	  // get content length and fire away
	  this.getLength(function(err, length) {
	    if (err && err !== 'Unknown stream') {
	      this._error(err);
	      return;
	    }

	    // add content length
	    if (length) {
	      request.setHeader('Content-Length', length);
	    }

	    this.pipe(request);
	    if (cb) {
	      var onResponse;

	      var callback = function (error, responce) {
	        request.removeListener('error', callback);
	        request.removeListener('response', onResponse);

	        return cb.call(this, error, responce);
	      };

	      onResponse = callback.bind(this, null);

	      request.on('error', callback);
	      request.on('response', onResponse);
	    }
	  }.bind(this));

	  return request;
	};

	FormData.prototype._error = function(err) {
	  if (!this.error) {
	    this.error = err;
	    this.pause();
	    this.emit('error', err);
	  }
	};

	FormData.prototype.toString = function () {
	  return '[object FormData]';
	};
	return form_data;
}

var proxyFromEnv = {};

var hasRequiredProxyFromEnv;

function requireProxyFromEnv () {
	if (hasRequiredProxyFromEnv) return proxyFromEnv;
	hasRequiredProxyFromEnv = 1;

	var parseUrl = require$$0__default$1["default"].parse;

	var DEFAULT_PORTS = {
	  ftp: 21,
	  gopher: 70,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443,
	};

	var stringEndsWith = String.prototype.endsWith || function(s) {
	  return s.length <= this.length &&
	    this.indexOf(s, this.length - s.length) !== -1;
	};

	/**
	 * @param {string|object} url - The URL, or the result from url.parse.
	 * @return {string} The URL of the proxy that should handle the request to the
	 *  given URL. If no proxy is set, this will be an empty string.
	 */
	function getProxyForUrl(url) {
	  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
	  var proto = parsedUrl.protocol;
	  var hostname = parsedUrl.host;
	  var port = parsedUrl.port;
	  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
	    return '';  // Don't proxy URLs without a valid scheme or host.
	  }

	  proto = proto.split(':', 1)[0];
	  // Stripping ports in this way instead of using parsedUrl.hostname to make
	  // sure that the brackets around IPv6 addresses are kept.
	  hostname = hostname.replace(/:\d*$/, '');
	  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
	  if (!shouldProxy(hostname, port)) {
	    return '';  // Don't proxy URLs that match NO_PROXY.
	  }

	  var proxy =
	    getEnv('npm_config_' + proto + '_proxy') ||
	    getEnv(proto + '_proxy') ||
	    getEnv('npm_config_proxy') ||
	    getEnv('all_proxy');
	  if (proxy && proxy.indexOf('://') === -1) {
	    // Missing scheme in proxy, default to the requested URL's scheme.
	    proxy = proto + '://' + proxy;
	  }
	  return proxy;
	}

	/**
	 * Determines whether a given URL should be proxied.
	 *
	 * @param {string} hostname - The host name of the URL.
	 * @param {number} port - The effective port of the URL.
	 * @returns {boolean} Whether the given URL should be proxied.
	 * @private
	 */
	function shouldProxy(hostname, port) {
	  var NO_PROXY =
	    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
	  if (!NO_PROXY) {
	    return true;  // Always proxy if NO_PROXY is not set.
	  }
	  if (NO_PROXY === '*') {
	    return false;  // Never proxy if wildcard is set.
	  }

	  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
	    if (!proxy) {
	      return true;  // Skip zero-length hosts.
	    }
	    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
	    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
	    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
	    if (parsedProxyPort && parsedProxyPort !== port) {
	      return true;  // Skip if ports don't match.
	    }

	    if (!/^[.*]/.test(parsedProxyHostname)) {
	      // No wildcards, so stop proxying if there is an exact match.
	      return hostname !== parsedProxyHostname;
	    }

	    if (parsedProxyHostname.charAt(0) === '*') {
	      // Remove leading wildcard.
	      parsedProxyHostname = parsedProxyHostname.slice(1);
	    }
	    // Stop proxying if the hostname ends with the no_proxy host.
	    return !stringEndsWith.call(hostname, parsedProxyHostname);
	  });
	}

	/**
	 * Get the value for an environment variable.
	 *
	 * @param {string} key - The name of the environment variable.
	 * @return {string} The value of the environment variable.
	 * @private
	 */
	function getEnv(key) {
	  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
	}

	proxyFromEnv.getProxyForUrl = getProxyForUrl;
	return proxyFromEnv;
}

var followRedirects = {exports: {}};

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;

			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}

				namespaces = split[i].replace(/\*/g, '.*?');

				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}

			let i;
			let len;

			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}

			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug');
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		};
} (browser, browser.exports));
	return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0__default$2["default"];
	const tty = require$$1__default$2["default"];
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$1__default$2["default"];
		const util = require$$1__default["default"];

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.format()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.format(...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		};
} (node, node.exports));
	return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	(function (module) {
		if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
			module.exports = requireBrowser();
		} else {
			module.exports = requireNode();
		}
} (src));
	return src.exports;
}

var debug_1;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug_1;
	hasRequiredDebug = 1;
	var debug;

	debug_1 = function () {
	  if (!debug) {
	    try {
	      /* eslint global-require: off */
	      debug = requireSrc()("follow-redirects");
	    }
	    catch (error) { /* */ }
	    if (typeof debug !== "function") {
	      debug = function () { /* */ };
	    }
	  }
	  debug.apply(null, arguments);
	};
	return debug_1;
}

var hasRequiredFollowRedirects;

function requireFollowRedirects () {
	if (hasRequiredFollowRedirects) return followRedirects.exports;
	hasRequiredFollowRedirects = 1;
	var url = require$$0__default$1["default"];
	var URL = url.URL;
	var http = require$$3__default["default"];
	var https = require$$4__default["default"];
	var Writable = require$$0__default["default"].Writable;
	var assert = require$$4__default$1["default"];
	var debug = requireDebug();

	// Whether to use the native URL object or the legacy url module
	var useNativeURL = false;
	try {
	  assert(new URL());
	}
	catch (error) {
	  useNativeURL = error.code === "ERR_INVALID_URL";
	}

	// URL fields to preserve in copy operations
	var preservedUrlFields = [
	  "auth",
	  "host",
	  "hostname",
	  "href",
	  "path",
	  "pathname",
	  "port",
	  "protocol",
	  "query",
	  "search",
	  "hash",
	];

	// Create handlers that pass events from native requests
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
	  eventHandlers[event] = function (arg1, arg2, arg3) {
	    this._redirectable.emit(event, arg1, arg2, arg3);
	  };
	});

	// Error types with codes
	var InvalidUrlError = createErrorType(
	  "ERR_INVALID_URL",
	  "Invalid URL",
	  TypeError
	);
	var RedirectionError = createErrorType(
	  "ERR_FR_REDIRECTION_FAILURE",
	  "Redirected request failed"
	);
	var TooManyRedirectsError = createErrorType(
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "Maximum number of redirects exceeded",
	  RedirectionError
	);
	var MaxBodyLengthExceededError = createErrorType(
	  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
	  "Request body larger than maxBodyLength limit"
	);
	var WriteAfterEndError = createErrorType(
	  "ERR_STREAM_WRITE_AFTER_END",
	  "write after end"
	);

	// istanbul ignore next
	var destroy = Writable.prototype.destroy || noop;

	// An HTTP(S) request that can be redirected
	function RedirectableRequest(options, responseCallback) {
	  // Initialize the request
	  Writable.call(this);
	  this._sanitizeOptions(options);
	  this._options = options;
	  this._ended = false;
	  this._ending = false;
	  this._redirectCount = 0;
	  this._redirects = [];
	  this._requestBodyLength = 0;
	  this._requestBodyBuffers = [];

	  // Attach a callback if passed
	  if (responseCallback) {
	    this.on("response", responseCallback);
	  }

	  // React to responses of native requests
	  var self = this;
	  this._onNativeResponse = function (response) {
	    try {
	      self._processResponse(response);
	    }
	    catch (cause) {
	      self.emit("error", cause instanceof RedirectionError ?
	        cause : new RedirectionError({ cause: cause }));
	    }
	  };

	  // Perform the first request
	  this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);

	RedirectableRequest.prototype.abort = function () {
	  destroyRequest(this._currentRequest);
	  this._currentRequest.abort();
	  this.emit("abort");
	};

	RedirectableRequest.prototype.destroy = function (error) {
	  destroyRequest(this._currentRequest, error);
	  destroy.call(this, error);
	  return this;
	};

	// Writes buffered data to the current native request
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
	  // Writing is not allowed if end has been called
	  if (this._ending) {
	    throw new WriteAfterEndError();
	  }

	  // Validate input and shift parameters if necessary
	  if (!isString(data) && !isBuffer(data)) {
	    throw new TypeError("data should be a string, Buffer or Uint8Array");
	  }
	  if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Ignore empty buffers, since writing them doesn't invoke the callback
	  // https://github.com/nodejs/node/issues/22066
	  if (data.length === 0) {
	    if (callback) {
	      callback();
	    }
	    return;
	  }
	  // Only write when we don't exceed the maximum body length
	  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
	    this._requestBodyLength += data.length;
	    this._requestBodyBuffers.push({ data: data, encoding: encoding });
	    this._currentRequest.write(data, encoding, callback);
	  }
	  // Error when we exceed the maximum body length
	  else {
	    this.emit("error", new MaxBodyLengthExceededError());
	    this.abort();
	  }
	};

	// Ends the current native request
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
	  // Shift parameters if necessary
	  if (isFunction(data)) {
	    callback = data;
	    data = encoding = null;
	  }
	  else if (isFunction(encoding)) {
	    callback = encoding;
	    encoding = null;
	  }

	  // Write data if needed and end
	  if (!data) {
	    this._ended = this._ending = true;
	    this._currentRequest.end(null, null, callback);
	  }
	  else {
	    var self = this;
	    var currentRequest = this._currentRequest;
	    this.write(data, encoding, function () {
	      self._ended = true;
	      currentRequest.end(null, null, callback);
	    });
	    this._ending = true;
	  }
	};

	// Sets a header value on the current native request
	RedirectableRequest.prototype.setHeader = function (name, value) {
	  this._options.headers[name] = value;
	  this._currentRequest.setHeader(name, value);
	};

	// Clears a header value on the current native request
	RedirectableRequest.prototype.removeHeader = function (name) {
	  delete this._options.headers[name];
	  this._currentRequest.removeHeader(name);
	};

	// Global timeout for all underlying requests
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
	  var self = this;

	  // Destroys the socket on timeout
	  function destroyOnTimeout(socket) {
	    socket.setTimeout(msecs);
	    socket.removeListener("timeout", socket.destroy);
	    socket.addListener("timeout", socket.destroy);
	  }

	  // Sets up a timer to trigger a timeout event
	  function startTimer(socket) {
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	    }
	    self._timeout = setTimeout(function () {
	      self.emit("timeout");
	      clearTimer();
	    }, msecs);
	    destroyOnTimeout(socket);
	  }

	  // Stops a timeout from triggering
	  function clearTimer() {
	    // Clear the timeout
	    if (self._timeout) {
	      clearTimeout(self._timeout);
	      self._timeout = null;
	    }

	    // Clean up all attached listeners
	    self.removeListener("abort", clearTimer);
	    self.removeListener("error", clearTimer);
	    self.removeListener("response", clearTimer);
	    self.removeListener("close", clearTimer);
	    if (callback) {
	      self.removeListener("timeout", callback);
	    }
	    if (!self.socket) {
	      self._currentRequest.removeListener("socket", startTimer);
	    }
	  }

	  // Attach callback if passed
	  if (callback) {
	    this.on("timeout", callback);
	  }

	  // Start the timer if or when the socket is opened
	  if (this.socket) {
	    startTimer(this.socket);
	  }
	  else {
	    this._currentRequest.once("socket", startTimer);
	  }

	  // Clean up on events
	  this.on("socket", destroyOnTimeout);
	  this.on("abort", clearTimer);
	  this.on("error", clearTimer);
	  this.on("response", clearTimer);
	  this.on("close", clearTimer);

	  return this;
	};

	// Proxy all other public ClientRequest methods
	[
	  "flushHeaders", "getHeader",
	  "setNoDelay", "setSocketKeepAlive",
	].forEach(function (method) {
	  RedirectableRequest.prototype[method] = function (a, b) {
	    return this._currentRequest[method](a, b);
	  };
	});

	// Proxy all public ClientRequest properties
	["aborted", "connection", "socket"].forEach(function (property) {
	  Object.defineProperty(RedirectableRequest.prototype, property, {
	    get: function () { return this._currentRequest[property]; },
	  });
	});

	RedirectableRequest.prototype._sanitizeOptions = function (options) {
	  // Ensure headers are always present
	  if (!options.headers) {
	    options.headers = {};
	  }

	  // Since http.request treats host as an alias of hostname,
	  // but the url module interprets host as hostname plus port,
	  // eliminate the host property to avoid confusion.
	  if (options.host) {
	    // Use hostname if set, because it has precedence
	    if (!options.hostname) {
	      options.hostname = options.host;
	    }
	    delete options.host;
	  }

	  // Complete the URL object when necessary
	  if (!options.pathname && options.path) {
	    var searchPos = options.path.indexOf("?");
	    if (searchPos < 0) {
	      options.pathname = options.path;
	    }
	    else {
	      options.pathname = options.path.substring(0, searchPos);
	      options.search = options.path.substring(searchPos);
	    }
	  }
	};


	// Executes the next native request (initial or redirect)
	RedirectableRequest.prototype._performRequest = function () {
	  // Load the native protocol
	  var protocol = this._options.protocol;
	  var nativeProtocol = this._options.nativeProtocols[protocol];
	  if (!nativeProtocol) {
	    throw new TypeError("Unsupported protocol " + protocol);
	  }

	  // If specified, use the agent corresponding to the protocol
	  // (HTTP and HTTPS use different types of agents)
	  if (this._options.agents) {
	    var scheme = protocol.slice(0, -1);
	    this._options.agent = this._options.agents[scheme];
	  }

	  // Create the native request and set up its event handlers
	  var request = this._currentRequest =
	        nativeProtocol.request(this._options, this._onNativeResponse);
	  request._redirectable = this;
	  for (var event of events) {
	    request.on(event, eventHandlers[event]);
	  }

	  // RFC72305.3.1: When making a request directly to an origin server, []
	  // a client MUST send only the absolute path [] as the request-target.
	  this._currentUrl = /^\//.test(this._options.path) ?
	    url.format(this._options) :
	    // When making a request to a proxy, []
	    // a client MUST send the target URI in absolute-form [].
	    this._options.path;

	  // End a redirected request
	  // (The first request must be ended explicitly with RedirectableRequest#end)
	  if (this._isRedirect) {
	    // Write the request entity and end
	    var i = 0;
	    var self = this;
	    var buffers = this._requestBodyBuffers;
	    (function writeNext(error) {
	      // Only write if this request has not been redirected yet
	      /* istanbul ignore else */
	      if (request === self._currentRequest) {
	        // Report any write errors
	        /* istanbul ignore if */
	        if (error) {
	          self.emit("error", error);
	        }
	        // Write the next buffer if there are still left
	        else if (i < buffers.length) {
	          var buffer = buffers[i++];
	          /* istanbul ignore else */
	          if (!request.finished) {
	            request.write(buffer.data, buffer.encoding, writeNext);
	          }
	        }
	        // End the request if `end` has been called on us
	        else if (self._ended) {
	          request.end();
	        }
	      }
	    }());
	  }
	};

	// Processes a response from the current native request
	RedirectableRequest.prototype._processResponse = function (response) {
	  // Store the redirected response
	  var statusCode = response.statusCode;
	  if (this._options.trackRedirects) {
	    this._redirects.push({
	      url: this._currentUrl,
	      headers: response.headers,
	      statusCode: statusCode,
	    });
	  }

	  // RFC72316.4: The 3xx (Redirection) class of status code indicates
	  // that further action needs to be taken by the user agent in order to
	  // fulfill the request. If a Location header field is provided,
	  // the user agent MAY automatically redirect its request to the URI
	  // referenced by the Location field value,
	  // even if the specific status code is not understood.

	  // If the response is not a redirect; return it as-is
	  var location = response.headers.location;
	  if (!location || this._options.followRedirects === false ||
	      statusCode < 300 || statusCode >= 400) {
	    response.responseUrl = this._currentUrl;
	    response.redirects = this._redirects;
	    this.emit("response", response);

	    // Clean up
	    this._requestBodyBuffers = [];
	    return;
	  }

	  // The response is a redirect, so abort the current request
	  destroyRequest(this._currentRequest);
	  // Discard the remainder of the response to avoid waiting for data
	  response.destroy();

	  // RFC72316.4: A client SHOULD detect and intervene
	  // in cyclical redirections (i.e., "infinite" redirection loops).
	  if (++this._redirectCount > this._options.maxRedirects) {
	    throw new TooManyRedirectsError();
	  }

	  // Store the request headers if applicable
	  var requestHeaders;
	  var beforeRedirect = this._options.beforeRedirect;
	  if (beforeRedirect) {
	    requestHeaders = Object.assign({
	      // The Host header was set by nativeProtocol.request
	      Host: response.req.getHeader("host"),
	    }, this._options.headers);
	  }

	  // RFC72316.4: Automatic redirection needs to done with
	  // care for methods not known to be safe, []
	  // RFC72316.4.23: For historical reasons, a user agent MAY change
	  // the request method from POST to GET for the subsequent request.
	  var method = this._options.method;
	  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
	      // RFC72316.4.4: The 303 (See Other) status code indicates that
	      // the server is redirecting the user agent to a different resource []
	      // A user agent can perform a retrieval request targeting that URI
	      // (a GET or HEAD request if using HTTP) []
	      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
	    this._options.method = "GET";
	    // Drop a possible entity and headers related to it
	    this._requestBodyBuffers = [];
	    removeMatchingHeaders(/^content-/i, this._options.headers);
	  }

	  // Drop the Host header, as the redirect might lead to a different host
	  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

	  // If the redirect is relative, carry over the host of the last request
	  var currentUrlParts = parseUrl(this._currentUrl);
	  var currentHost = currentHostHeader || currentUrlParts.host;
	  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
	    url.format(Object.assign(currentUrlParts, { host: currentHost }));

	  // Create the redirected request
	  var redirectUrl = resolveUrl(location, currentUrl);
	  debug("redirecting to", redirectUrl.href);
	  this._isRedirect = true;
	  spreadUrlObject(redirectUrl, this._options);

	  // Drop confidential headers when redirecting to a less secure protocol
	  // or to a different domain that is not a superdomain
	  if (redirectUrl.protocol !== currentUrlParts.protocol &&
	     redirectUrl.protocol !== "https:" ||
	     redirectUrl.host !== currentHost &&
	     !isSubdomain(redirectUrl.host, currentHost)) {
	    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
	  }

	  // Evaluate the beforeRedirect callback
	  if (isFunction(beforeRedirect)) {
	    var responseDetails = {
	      headers: response.headers,
	      statusCode: statusCode,
	    };
	    var requestDetails = {
	      url: currentUrl,
	      method: method,
	      headers: requestHeaders,
	    };
	    beforeRedirect(this._options, responseDetails, requestDetails);
	    this._sanitizeOptions(this._options);
	  }

	  // Perform the redirected request
	  this._performRequest();
	};

	// Wraps the key/value object of protocols with redirect functionality
	function wrap(protocols) {
	  // Default settings
	  var exports = {
	    maxRedirects: 21,
	    maxBodyLength: 10 * 1024 * 1024,
	  };

	  // Wrap each protocol
	  var nativeProtocols = {};
	  Object.keys(protocols).forEach(function (scheme) {
	    var protocol = scheme + ":";
	    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
	    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

	    // Executes a request, following redirects
	    function request(input, options, callback) {
	      // Parse parameters, ensuring that input is an object
	      if (isURL(input)) {
	        input = spreadUrlObject(input);
	      }
	      else if (isString(input)) {
	        input = spreadUrlObject(parseUrl(input));
	      }
	      else {
	        callback = options;
	        options = validateUrl(input);
	        input = { protocol: protocol };
	      }
	      if (isFunction(options)) {
	        callback = options;
	        options = null;
	      }

	      // Set defaults
	      options = Object.assign({
	        maxRedirects: exports.maxRedirects,
	        maxBodyLength: exports.maxBodyLength,
	      }, input, options);
	      options.nativeProtocols = nativeProtocols;
	      if (!isString(options.host) && !isString(options.hostname)) {
	        options.hostname = "::1";
	      }

	      assert.equal(options.protocol, protocol, "protocol mismatch");
	      debug("options", options);
	      return new RedirectableRequest(options, callback);
	    }

	    // Executes a GET request, following redirects
	    function get(input, options, callback) {
	      var wrappedRequest = wrappedProtocol.request(input, options, callback);
	      wrappedRequest.end();
	      return wrappedRequest;
	    }

	    // Expose the properties on the wrapped protocol
	    Object.defineProperties(wrappedProtocol, {
	      request: { value: request, configurable: true, enumerable: true, writable: true },
	      get: { value: get, configurable: true, enumerable: true, writable: true },
	    });
	  });
	  return exports;
	}

	function noop() { /* empty */ }

	function parseUrl(input) {
	  var parsed;
	  /* istanbul ignore else */
	  if (useNativeURL) {
	    parsed = new URL(input);
	  }
	  else {
	    // Ensure the URL is valid and absolute
	    parsed = validateUrl(url.parse(input));
	    if (!isString(parsed.protocol)) {
	      throw new InvalidUrlError({ input });
	    }
	  }
	  return parsed;
	}

	function resolveUrl(relative, base) {
	  /* istanbul ignore next */
	  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
	}

	function validateUrl(input) {
	  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
	    throw new InvalidUrlError({ input: input.href || input });
	  }
	  return input;
	}

	function spreadUrlObject(urlObject, target) {
	  var spread = target || {};
	  for (var key of preservedUrlFields) {
	    spread[key] = urlObject[key];
	  }

	  // Fix IPv6 hostname
	  if (spread.hostname.startsWith("[")) {
	    spread.hostname = spread.hostname.slice(1, -1);
	  }
	  // Ensure port is a number
	  if (spread.port !== "") {
	    spread.port = Number(spread.port);
	  }
	  // Concatenate path
	  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

	  return spread;
	}

	function removeMatchingHeaders(regex, headers) {
	  var lastValue;
	  for (var header in headers) {
	    if (regex.test(header)) {
	      lastValue = headers[header];
	      delete headers[header];
	    }
	  }
	  return (lastValue === null || typeof lastValue === "undefined") ?
	    undefined : String(lastValue).trim();
	}

	function createErrorType(code, message, baseClass) {
	  // Create constructor
	  function CustomError(properties) {
	    Error.captureStackTrace(this, this.constructor);
	    Object.assign(this, properties || {});
	    this.code = code;
	    this.message = this.cause ? message + ": " + this.cause.message : message;
	  }

	  // Attach constructor and set default properties
	  CustomError.prototype = new (baseClass || Error)();
	  Object.defineProperties(CustomError.prototype, {
	    constructor: {
	      value: CustomError,
	      enumerable: false,
	    },
	    name: {
	      value: "Error [" + code + "]",
	      enumerable: false,
	    },
	  });
	  return CustomError;
	}

	function destroyRequest(request, error) {
	  for (var event of events) {
	    request.removeListener(event, eventHandlers[event]);
	  }
	  request.on("error", noop);
	  request.destroy(error);
	}

	function isSubdomain(subdomain, domain) {
	  assert(isString(subdomain) && isString(domain));
	  var dot = subdomain.length - domain.length - 1;
	  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}

	function isString(value) {
	  return typeof value === "string" || value instanceof String;
	}

	function isFunction(value) {
	  return typeof value === "function";
	}

	function isBuffer(value) {
	  return typeof value === "object" && ("length" in value);
	}

	function isURL(value) {
	  return URL && value instanceof URL;
	}

	// Exports
	followRedirects.exports = wrap({ http: http, https: https });
	followRedirects.exports.wrap = wrap;
	return followRedirects.exports;
}

var axios_1;
var hasRequiredAxios;

function requireAxios () {
	if (hasRequiredAxios) return axios_1;
	hasRequiredAxios = 1;

	const FormData$1 = requireForm_data();
	const url = require$$0__default$1["default"];
	const proxyFromEnv = requireProxyFromEnv();
	const http = require$$3__default["default"];
	const https = require$$4__default["default"];
	const util = require$$1__default["default"];
	const followRedirects = requireFollowRedirects();
	const zlib = require$$7__default["default"];
	const stream = require$$0__default["default"];
	const EventEmitter = require$$9__default["default"];

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
	const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
	const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
	const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
	const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
	const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
	const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
	const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
	const EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {toString} = Object.prototype;
	const {getPrototypeOf} = Object;

	const kindOf = (cache => thing => {
	    const str = toString.call(thing);
	    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));

	const kindOfTest = (type) => {
	  type = type.toLowerCase();
	  return (thing) => kindOf(thing) === type
	};

	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {isArray} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');


	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = (thing) => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = (val) => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }

	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = (val) => isObject(val) && isFunction(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = (thing) => {
	  let kind;
	  return thing && (
	    (typeof FormData === 'function' && thing instanceof FormData) || (
	      isFunction(thing.append) && (
	        (kind = kindOf(thing)) === 'formdata' ||
	        // detect form-data instance
	        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
	      )
	    )
	  )
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = (str) => str.trim ?
	  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {allOwnKeys = false} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;

	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}

	function findKey(obj, key) {
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}

	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : commonjsGlobal)
	})();

	const isContextDefined = (context) => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  const {caseless} = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };

	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {allOwnKeys});
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = (content) => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};

	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;

	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};


	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = (thing) => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[Symbol.iterator];

	  const iterator = generator.call(obj);

	  let result;

	  while ((result = iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];

	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }

	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');

	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
	    function replacer(m, p1, p2) {
	      return p1.toUpperCase() + p2;
	    }
	  );
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');

	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};

	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });

	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = (obj) => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }

	    const value = obj[name];

	    if (!isFunction(value)) return;

	    descriptor.enumerable = false;

	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }

	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};

	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};

	  const define = (arr) => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };

	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

	  return obj;
	};

	const noop = () => {};

	const toFiniteNumber = (value, defaultValue) => {
	  value = +value;
	  return Number.isFinite(value) ? value : defaultValue;
	};

	const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

	const DIGIT = '0123456789';

	const ALPHABET = {
	  DIGIT,
	  ALPHA,
	  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
	};

	const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
	  let str = '';
	  const {length} = alphabet;
	  while (size--) {
	    str += alphabet[Math.random() * length|0];
	  }

	  return str;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
	}

	const toJSONObject = (obj) => {
	  const stack = new Array(10);

	  const visit = (source, i) => {

	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }

	      if(!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};

	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });

	        stack[i] = undefined;

	        return target;
	      }
	    }

	    return source;
	  };

	  return visit(obj, 0);
	};

	const isAsyncFn = kindOfTest('AsyncFunction');

	const isThenable = (thing) =>
	  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

	const utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  ALPHABET,
	  generateString,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = (new Error()).stack;
	  }

	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  response && (this.response = response);
	}

	utils$1.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.response && this.response.status ? this.response.status : null
	    };
	  }
	});

	const prototype$1 = AxiosError.prototype;
	const descriptors = {};

	[
	  'ERR_BAD_OPTION_VALUE',
	  'ERR_BAD_OPTION',
	  'ECONNABORTED',
	  'ETIMEDOUT',
	  'ERR_NETWORK',
	  'ERR_FR_TOO_MANY_REDIRECTS',
	  'ERR_DEPRECATED',
	  'ERR_BAD_RESPONSE',
	  'ERR_BAD_REQUEST',
	  'ERR_CANCELED',
	  'ERR_NOT_SUPPORT',
	  'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {value: code};
	});

	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

	// eslint-disable-next-line func-names
	AxiosError.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);

	  utils$1.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });

	  AxiosError.call(axiosError, error.message, code, config, request, response);

	  axiosError.cause = error;

	  axiosError.name = error.name;

	  customProps && Object.assign(axiosError, customProps);

	  return axiosError;
	};

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}

	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData__default["default"] || FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$1.isUndefined(source[option]);
	  });

	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }

	  function convertValue(value) {
	    if (value === null) return '';

	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }

	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
	    }

	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }

	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;

	    if (value && !path && typeof value === 'object') {
	      if (utils$1.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (
	        (utils$1.isArray(value) && isFlatArray(value)) ||
	        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
	        )) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);

	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	            // eslint-disable-next-line no-nested-ternary
	            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
	            convertValue(el)
	          );
	        });
	        return false;
	      }
	    }

	    if (isVisitable(value)) {
	      return true;
	    }

	    formData.append(renderKey(path, key, dots), convertValue(value));

	    return false;
	  }

	  const stack = [];

	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });

	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;

	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }

	    stack.push(value);

	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
	        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
	      );

	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });

	    stack.pop();
	  }

	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }

	  build(obj);

	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$1(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];

	  params && toFormData(params, this, options);
	}

	const prototype = AxiosURLSearchParams.prototype;

	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};

	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function(value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;

	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?object} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  
	  const _encode = options && options.encode || encode;

	  const serializeFn = options && options.serialize;

	  let serializedParams;

	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ?
	      params.toString() :
	      new AxiosURLSearchParams(params, options).toString(_encode);
	  }

	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");

	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}

	const InterceptorManager$1 = InterceptorManager;

	const transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	const URLSearchParams = url__default["default"].URLSearchParams;

	const platform$1 = {
	  isNode: true,
	  classes: {
	    URLSearchParams,
	    FormData: FormData__default["default"],
	    Blob: typeof Blob !== 'undefined' && Blob || null
	  },
	  protocols: [ 'http', 'https', 'file', 'data' ]
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = (
	  (product) => {
	    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
	  })(typeof navigator !== 'undefined' && navigator.product);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return (
	    typeof WorkerGlobalScope !== 'undefined' &&
	    // eslint-disable-next-line no-undef
	    self instanceof WorkerGlobalScope &&
	    typeof self.importScripts === 'function'
	  );
	})();

	const utils = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  hasBrowserEnv: hasBrowserEnv,
	  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
	  hasStandardBrowserEnv: hasStandardBrowserEnv
	});

	const platform = {
	  ...utils,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
	    visitor: function(value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }

	      return helpers.defaultVisitor.apply(this, arguments);
	    }
	  }, options));
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];

	    if (name === '__proto__') return true;

	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;

	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }

	      return !isNumericKey;
	    }

	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }

	    const result = buildPath(path, value, target[name], index);

	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }

	    return !isNumericKey;
	  }

	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};

	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });

	    return obj;
	  }

	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	const defaults = {

	  transitional: transitionalDefaults,

	  adapter: ['xhr', 'http'],

	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$1.isObject(data);

	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }

	    const isFormData = utils$1.isFormData(data);

	    if (isFormData) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }

	    if (utils$1.isArrayBuffer(data) ||
	      utils$1.isBuffer(data) ||
	      utils$1.isStream(data) ||
	      utils$1.isFile(data) ||
	      utils$1.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }

	    let isFileList;

	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }

	      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;

	        return toFormData(
	          isFileList ? {'files[]': data} : data,
	          _FormData && new _FormData(),
	          this.formSerializer
	        );
	      }
	    }

	    if (isObjectPayload || hasJSONContentType ) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }

	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';

	    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;

	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },

	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};

	utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
	  defaults.headers[method] = {};
	});

	const defaults$1 = defaults;

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$1.toObjectSet([
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	]);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	const parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;

	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();

	    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
	      return;
	    }

	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};

	const $internals = Symbol('internals');

	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}

	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }

	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}

	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;

	  while ((match = tokensRE.exec(str))) {
	    tokens[match[1]] = match[2];
	  }

	  return tokens;
	}

	const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }

	  if (isHeaderNameFilter) {
	    value = header;
	  }

	  if (!utils$1.isString(value)) return;

	  if (utils$1.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }

	  if (utils$1.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}

	function formatHeader(header) {
	  return header.trim()
	    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	      return char.toUpperCase() + str;
	    });
	}

	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(' ' + header);

	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function(arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}

	class AxiosHeaders {
	  constructor(headers) {
	    headers && this.set(headers);
	  }

	  set(header, valueOrRewrite, rewrite) {
	    const self = this;

	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);

	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }

	      const key = utils$1.findKey(self, lHeader);

	      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }

	    const setHeaders = (headers, _rewrite) =>
	      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }

	    return this;
	  }

	  get(header, parser) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      if (key) {
	        const value = this[key];

	        if (!parser) {
	          return value;
	        }

	        if (parser === true) {
	          return parseTokens(value);
	        }

	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }

	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }

	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }

	  has(header, matcher) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }

	    return false;
	  }

	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;

	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);

	      if (_header) {
	        const key = utils$1.findKey(self, _header);

	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];

	          deleted = true;
	        }
	      }
	    }

	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }

	    return deleted;
	  }

	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;

	    while (i--) {
	      const key = keys[i];
	      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }

	    return deleted;
	  }

	  normalize(format) {
	    const self = this;
	    const headers = {};

	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);

	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }

	      const normalized = format ? formatHeader(header) : String(header).trim();

	      if (normalized !== header) {
	        delete self[header];
	      }

	      self[normalized] = normalizeValue(value);

	      headers[normalized] = true;
	    });

	    return this;
	  }

	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }

	  toJSON(asStrings) {
	    const obj = Object.create(null);

	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
	    });

	    return obj;
	  }

	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }

	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }

	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }

	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }

	  static concat(first, ...targets) {
	    const computed = new this(first);

	    targets.forEach((target) => computed.set(target));

	    return computed;
	  }

	  static accessor(header) {
	    const internals = this[$internals] = (this[$internals] = {
	      accessors: {}
	    });

	    const accessors = internals.accessors;
	    const prototype = this.prototype;

	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);

	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }

	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

	    return this;
	  }
	}

	AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  }
	});

	utils$1.freezeMethods(AxiosHeaders);

	const AxiosHeaders$1 = AxiosHeaders;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults$1;
	  const context = response || config;
	  const headers = AxiosHeaders$1.from(context.headers);
	  let data = context.data;

	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });

	  headers.normalize();

	  return data;
	}

	function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}

	utils$1.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError(
	      'Request failed with status code ' + response.status,
	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	}

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	const VERSION = "1.6.7";

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

	/**
	 * Parse data uri to a Buffer or Blob
	 *
	 * @param {String} uri
	 * @param {?Boolean} asBlob
	 * @param {?Object} options
	 * @param {?Function} options.Blob
	 *
	 * @returns {Buffer|Blob}
	 */
	function fromDataURI(uri, asBlob, options) {
	  const _Blob = options && options.Blob || platform.classes.Blob;
	  const protocol = parseProtocol(uri);

	  if (asBlob === undefined && _Blob) {
	    asBlob = true;
	  }

	  if (protocol === 'data') {
	    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

	    const match = DATA_URL_PATTERN.exec(uri);

	    if (!match) {
	      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
	    }

	    const mime = match[1];
	    const isBase64 = match[2];
	    const body = match[3];
	    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

	    if (asBlob) {
	      if (!_Blob) {
	        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
	      }

	      return new _Blob([buffer], {type: mime});
	    }

	    return buffer;
	  }

	  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
	}

	/**
	 * Throttle decorator
	 * @param {Function} fn
	 * @param {Number} freq
	 * @return {Function}
	 */
	function throttle(fn, freq) {
	  let timestamp = 0;
	  const threshold = 1000 / freq;
	  let timer = null;
	  return function throttled(force, args) {
	    const now = Date.now();
	    if (force || now - timestamp > threshold) {
	      if (timer) {
	        clearTimeout(timer);
	        timer = null;
	      }
	      timestamp = now;
	      return fn.apply(null, args);
	    }
	    if (!timer) {
	      timer = setTimeout(() => {
	        timer = null;
	        timestamp = Date.now();
	        return fn.apply(null, args);
	      }, threshold - (now - timestamp));
	    }
	  };
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;

	  min = min !== undefined ? min : 1000;

	  return function push(chunkLength) {
	    const now = Date.now();

	    const startedAt = timestamps[tail];

	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }

	    bytes[head] = chunkLength;
	    timestamps[head] = now;

	    let i = tail;
	    let bytesCount = 0;

	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }

	    head = (head + 1) % samplesCount;

	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }

	    if (now - firstSampleTS < min) {
	      return;
	    }

	    const passed = startedAt && now - startedAt;

	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	const kInternals = Symbol('internals');

	class AxiosTransformStream extends stream__default["default"].Transform{
	  constructor(options) {
	    options = utils$1.toFlatObject(options, {
	      maxRate: 0,
	      chunkSize: 64 * 1024,
	      minChunkSize: 100,
	      timeWindow: 500,
	      ticksRate: 2,
	      samplesCount: 15
	    }, null, (prop, source) => {
	      return !utils$1.isUndefined(source[prop]);
	    });

	    super({
	      readableHighWaterMark: options.chunkSize
	    });

	    const self = this;

	    const internals = this[kInternals] = {
	      length: options.length,
	      timeWindow: options.timeWindow,
	      ticksRate: options.ticksRate,
	      chunkSize: options.chunkSize,
	      maxRate: options.maxRate,
	      minChunkSize: options.minChunkSize,
	      bytesSeen: 0,
	      isCaptured: false,
	      notifiedBytesLoaded: 0,
	      ts: Date.now(),
	      bytes: 0,
	      onReadCallback: null
	    };

	    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);

	    this.on('newListener', event => {
	      if (event === 'progress') {
	        if (!internals.isCaptured) {
	          internals.isCaptured = true;
	        }
	      }
	    });

	    let bytesNotified = 0;

	    internals.updateProgress = throttle(function throttledHandler() {
	      const totalBytes = internals.length;
	      const bytesTransferred = internals.bytesSeen;
	      const progressBytes = bytesTransferred - bytesNotified;
	      if (!progressBytes || self.destroyed) return;

	      const rate = _speedometer(progressBytes);

	      bytesNotified = bytesTransferred;

	      process.nextTick(() => {
	        self.emit('progress', {
	          'loaded': bytesTransferred,
	          'total': totalBytes,
	          'progress': totalBytes ? (bytesTransferred / totalBytes) : undefined,
	          'bytes': progressBytes,
	          'rate': rate ? rate : undefined,
	          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ?
	            (totalBytes - bytesTransferred) / rate : undefined
	        });
	      });
	    }, internals.ticksRate);

	    const onFinish = () => {
	      internals.updateProgress(true);
	    };

	    this.once('end', onFinish);
	    this.once('error', onFinish);
	  }

	  _read(size) {
	    const internals = this[kInternals];

	    if (internals.onReadCallback) {
	      internals.onReadCallback();
	    }

	    return super._read(size);
	  }

	  _transform(chunk, encoding, callback) {
	    const self = this;
	    const internals = this[kInternals];
	    const maxRate = internals.maxRate;

	    const readableHighWaterMark = this.readableHighWaterMark;

	    const timeWindow = internals.timeWindow;

	    const divider = 1000 / timeWindow;
	    const bytesThreshold = (maxRate / divider);
	    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

	    function pushChunk(_chunk, _callback) {
	      const bytes = Buffer.byteLength(_chunk);
	      internals.bytesSeen += bytes;
	      internals.bytes += bytes;

	      if (internals.isCaptured) {
	        internals.updateProgress();
	      }

	      if (self.push(_chunk)) {
	        process.nextTick(_callback);
	      } else {
	        internals.onReadCallback = () => {
	          internals.onReadCallback = null;
	          process.nextTick(_callback);
	        };
	      }
	    }

	    const transformChunk = (_chunk, _callback) => {
	      const chunkSize = Buffer.byteLength(_chunk);
	      let chunkRemainder = null;
	      let maxChunkSize = readableHighWaterMark;
	      let bytesLeft;
	      let passed = 0;

	      if (maxRate) {
	        const now = Date.now();

	        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
	          internals.ts = now;
	          bytesLeft = bytesThreshold - internals.bytes;
	          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
	          passed = 0;
	        }

	        bytesLeft = bytesThreshold - internals.bytes;
	      }

	      if (maxRate) {
	        if (bytesLeft <= 0) {
	          // next time window
	          return setTimeout(() => {
	            _callback(null, _chunk);
	          }, timeWindow - passed);
	        }

	        if (bytesLeft < maxChunkSize) {
	          maxChunkSize = bytesLeft;
	        }
	      }

	      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
	        chunkRemainder = _chunk.subarray(maxChunkSize);
	        _chunk = _chunk.subarray(0, maxChunkSize);
	      }

	      pushChunk(_chunk, chunkRemainder ? () => {
	        process.nextTick(_callback, null, chunkRemainder);
	      } : _callback);
	    };

	    transformChunk(chunk, function transformNextChunk(err, _chunk) {
	      if (err) {
	        return callback(err);
	      }

	      if (_chunk) {
	        transformChunk(_chunk, transformNextChunk);
	      } else {
	        callback(null);
	      }
	    });
	  }

	  setLength(length) {
	    this[kInternals].length = +length;
	    return this;
	  }
	}

	const AxiosTransformStream$1 = AxiosTransformStream;

	const {asyncIterator} = Symbol;

	const readBlob = async function* (blob) {
	  if (blob.stream) {
	    yield* blob.stream();
	  } else if (blob.arrayBuffer) {
	    yield await blob.arrayBuffer();
	  } else if (blob[asyncIterator]) {
	    yield* blob[asyncIterator]();
	  } else {
	    yield blob;
	  }
	};

	const readBlob$1 = readBlob;

	const BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + '-_';

	const textEncoder = new util.TextEncoder();

	const CRLF = '\r\n';
	const CRLF_BYTES = textEncoder.encode(CRLF);
	const CRLF_BYTES_COUNT = 2;

	class FormDataPart {
	  constructor(name, value) {
	    const {escapeName} = this.constructor;
	    const isStringValue = utils$1.isString(value);

	    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
	      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
	    }${CRLF}`;

	    if (isStringValue) {
	      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
	    } else {
	      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
	    }

	    this.headers = textEncoder.encode(headers + CRLF);

	    this.contentLength = isStringValue ? value.byteLength : value.size;

	    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

	    this.name = name;
	    this.value = value;
	  }

	  async *encode(){
	    yield this.headers;

	    const {value} = this;

	    if(utils$1.isTypedArray(value)) {
	      yield value;
	    } else {
	      yield* readBlob$1(value);
	    }

	    yield CRLF_BYTES;
	  }

	  static escapeName(name) {
	      return String(name).replace(/[\r\n"]/g, (match) => ({
	        '\r' : '%0D',
	        '\n' : '%0A',
	        '"' : '%22',
	      }[match]));
	  }
	}

	const formDataToStream = (form, headersHandler, options) => {
	  const {
	    tag = 'form-data-boundary',
	    size = 25,
	    boundary = tag + '-' + utils$1.generateString(size, BOUNDARY_ALPHABET)
	  } = options || {};

	  if(!utils$1.isFormData(form)) {
	    throw TypeError('FormData instance required');
	  }

	  if (boundary.length < 1 || boundary.length > 70) {
	    throw Error('boundary must be 10-70 characters long')
	  }

	  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
	  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF + CRLF);
	  let contentLength = footerBytes.byteLength;

	  const parts = Array.from(form.entries()).map(([name, value]) => {
	    const part = new FormDataPart(name, value);
	    contentLength += part.size;
	    return part;
	  });

	  contentLength += boundaryBytes.byteLength * parts.length;

	  contentLength = utils$1.toFiniteNumber(contentLength);

	  const computedHeaders = {
	    'Content-Type': `multipart/form-data; boundary=${boundary}`
	  };

	  if (Number.isFinite(contentLength)) {
	    computedHeaders['Content-Length'] = contentLength;
	  }

	  headersHandler && headersHandler(computedHeaders);

	  return stream.Readable.from((async function *() {
	    for(const part of parts) {
	      yield boundaryBytes;
	      yield* part.encode();
	    }

	    yield footerBytes;
	  })());
	};

	const formDataToStream$1 = formDataToStream;

	class ZlibHeaderTransformStream extends stream__default["default"].Transform {
	  __transform(chunk, encoding, callback) {
	    this.push(chunk);
	    callback();
	  }

	  _transform(chunk, encoding, callback) {
	    if (chunk.length !== 0) {
	      this._transform = this.__transform;

	      // Add Default Compression headers if no zlib headers are present
	      if (chunk[0] !== 120) { // Hex: 78
	        const header = Buffer.alloc(2);
	        header[0] = 120; // Hex: 78
	        header[1] = 156; // Hex: 9C 
	        this.push(header, encoding);
	      }
	    }

	    this.__transform(chunk, encoding, callback);
	  }
	}

	const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

	const callbackify = (fn, reducer) => {
	  return utils$1.isAsyncFn(fn) ? function (...args) {
	    const cb = args.pop();
	    fn.apply(this, args).then((value) => {
	      try {
	        reducer ? cb(null, ...reducer(value)) : cb(null, value);
	      } catch (err) {
	        cb(err);
	      }
	    }, cb);
	  } : fn;
	};

	const callbackify$1 = callbackify;

	const zlibOptions = {
	  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
	  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
	};

	const brotliOptions = {
	  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
	  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
	};

	const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);

	const {http: httpFollow, https: httpsFollow} = followRedirects__default["default"];

	const isHttps = /https:?/;

	const supportedProtocols = platform.protocols.map(protocol => {
	  return protocol + ':';
	});

	/**
	 * If the proxy or config beforeRedirects functions are defined, call them with the options
	 * object.
	 *
	 * @param {Object<string, any>} options - The options object that was passed to the request.
	 *
	 * @returns {Object<string, any>}
	 */
	function dispatchBeforeRedirect(options, responseDetails) {
	  if (options.beforeRedirects.proxy) {
	    options.beforeRedirects.proxy(options);
	  }
	  if (options.beforeRedirects.config) {
	    options.beforeRedirects.config(options, responseDetails);
	  }
	}

	/**
	 * If the proxy or config afterRedirects functions are defined, call them with the options
	 *
	 * @param {http.ClientRequestArgs} options
	 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
	 * @param {string} location
	 *
	 * @returns {http.ClientRequestArgs}
	 */
	function setProxy(options, configProxy, location) {
	  let proxy = configProxy;
	  if (!proxy && proxy !== false) {
	    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
	    if (proxyUrl) {
	      proxy = new URL(proxyUrl);
	    }
	  }
	  if (proxy) {
	    // Basic proxy authorization
	    if (proxy.username) {
	      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
	    }

	    if (proxy.auth) {
	      // Support proxy auth object form
	      if (proxy.auth.username || proxy.auth.password) {
	        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
	      }
	      const base64 = Buffer
	        .from(proxy.auth, 'utf8')
	        .toString('base64');
	      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
	    }

	    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
	    const proxyHost = proxy.hostname || proxy.host;
	    options.hostname = proxyHost;
	    // Replace 'host' since options is not a URL object
	    options.host = proxyHost;
	    options.port = proxy.port;
	    options.path = location;
	    if (proxy.protocol) {
	      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
	    }
	  }

	  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
	    // Configure proxy for redirected request, passing the original config proxy to apply
	    // the exact same logic as if the redirected request was performed by axios directly.
	    setProxy(redirectOptions, configProxy, redirectOptions.href);
	  };
	}

	const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

	// temporary hotfix

	const wrapAsync = (asyncExecutor) => {
	  return new Promise((resolve, reject) => {
	    let onDone;
	    let isDone;

	    const done = (value, isRejected) => {
	      if (isDone) return;
	      isDone = true;
	      onDone && onDone(value, isRejected);
	    };

	    const _resolve = (value) => {
	      done(value);
	      resolve(value);
	    };

	    const _reject = (reason) => {
	      done(reason, true);
	      reject(reason);
	    };

	    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
	  })
	};

	const resolveFamily = ({address, family}) => {
	  if (!utils$1.isString(address)) {
	    throw TypeError('address must be a string');
	  }
	  return ({
	    address,
	    family: family || (address.indexOf('.') < 0 ? 6 : 4)
	  });
	};

	const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

	/*eslint consistent-return:0*/
	const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
	  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
	    let {data, lookup, family} = config;
	    const {responseType, responseEncoding} = config;
	    const method = config.method.toUpperCase();
	    let isDone;
	    let rejected = false;
	    let req;

	    if (lookup) {
	      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
	      // hotfix to support opt.all option which is required for node 20.x
	      lookup = (hostname, opt, cb) => {
	        _lookup(hostname, opt, (err, arg0, arg1) => {
	          if (err) {
	            return cb(err);
	          }

	          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

	          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
	        });
	      };
	    }

	    // temporary internal emitter until the AxiosRequest class will be implemented
	    const emitter = new EventEmitter__default["default"]();

	    const onFinished = () => {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(abort);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', abort);
	      }

	      emitter.removeAllListeners();
	    };

	    onDone((value, isRejected) => {
	      isDone = true;
	      if (isRejected) {
	        rejected = true;
	        onFinished();
	      }
	    });

	    function abort(reason) {
	      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
	    }

	    emitter.once('abort', reject);

	    if (config.cancelToken || config.signal) {
	      config.cancelToken && config.cancelToken.subscribe(abort);
	      if (config.signal) {
	        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
	      }
	    }

	    // Parse url
	    const fullPath = buildFullPath(config.baseURL, config.url);
	    const parsed = new URL(fullPath, 'http://localhost');
	    const protocol = parsed.protocol || supportedProtocols[0];

	    if (protocol === 'data:') {
	      let convertedData;

	      if (method !== 'GET') {
	        return settle(resolve, reject, {
	          status: 405,
	          statusText: 'method not allowed',
	          headers: {},
	          config
	        });
	      }

	      try {
	        convertedData = fromDataURI(config.url, responseType === 'blob', {
	          Blob: config.env && config.env.Blob
	        });
	      } catch (err) {
	        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
	      }

	      if (responseType === 'text') {
	        convertedData = convertedData.toString(responseEncoding);

	        if (!responseEncoding || responseEncoding === 'utf8') {
	          convertedData = utils$1.stripBOM(convertedData);
	        }
	      } else if (responseType === 'stream') {
	        convertedData = stream__default["default"].Readable.from(convertedData);
	      }

	      return settle(resolve, reject, {
	        data: convertedData,
	        status: 200,
	        statusText: 'OK',
	        headers: new AxiosHeaders$1(),
	        config
	      });
	    }

	    if (supportedProtocols.indexOf(protocol) === -1) {
	      return reject(new AxiosError(
	        'Unsupported protocol ' + protocol,
	        AxiosError.ERR_BAD_REQUEST,
	        config
	      ));
	    }

	    const headers = AxiosHeaders$1.from(config.headers).normalize();

	    // Set User-Agent (required by some servers)
	    // See https://github.com/axios/axios/issues/69
	    // User-Agent is specified; handle case where no UA header is desired
	    // Only set header if it hasn't been set in config
	    headers.set('User-Agent', 'axios/' + VERSION, false);

	    const onDownloadProgress = config.onDownloadProgress;
	    const onUploadProgress = config.onUploadProgress;
	    const maxRate = config.maxRate;
	    let maxUploadRate = undefined;
	    let maxDownloadRate = undefined;

	    // support for spec compliant FormData objects
	    if (utils$1.isSpecCompliantForm(data)) {
	      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

	      data = formDataToStream$1(data, (formHeaders) => {
	        headers.set(formHeaders);
	      }, {
	        tag: `axios-${VERSION}-boundary`,
	        boundary: userBoundary && userBoundary[1] || undefined
	      });
	      // support for https://www.npmjs.com/package/form-data api
	    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
	      headers.set(data.getHeaders());

	      if (!headers.hasContentLength()) {
	        try {
	          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
	          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
	          /*eslint no-empty:0*/
	        } catch (e) {
	        }
	      }
	    } else if (utils$1.isBlob(data)) {
	      data.size && headers.setContentType(data.type || 'application/octet-stream');
	      headers.setContentLength(data.size || 0);
	      data = stream__default["default"].Readable.from(readBlob$1(data));
	    } else if (data && !utils$1.isStream(data)) {
	      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
	        data = Buffer.from(new Uint8Array(data));
	      } else if (utils$1.isString(data)) {
	        data = Buffer.from(data, 'utf-8');
	      } else {
	        return reject(new AxiosError(
	          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }

	      // Add Content-Length header if data exists
	      headers.setContentLength(data.length, false);

	      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
	        return reject(new AxiosError(
	          'Request body larger than maxBodyLength limit',
	          AxiosError.ERR_BAD_REQUEST,
	          config
	        ));
	      }
	    }

	    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

	    if (utils$1.isArray(maxRate)) {
	      maxUploadRate = maxRate[0];
	      maxDownloadRate = maxRate[1];
	    } else {
	      maxUploadRate = maxDownloadRate = maxRate;
	    }

	    if (data && (onUploadProgress || maxUploadRate)) {
	      if (!utils$1.isStream(data)) {
	        data = stream__default["default"].Readable.from(data, {objectMode: false});
	      }

	      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
	        length: contentLength,
	        maxRate: utils$1.toFiniteNumber(maxUploadRate)
	      })], utils$1.noop);

	      onUploadProgress && data.on('progress', progress => {
	        onUploadProgress(Object.assign(progress, {
	          upload: true
	        }));
	      });
	    }

	    // HTTP basic authentication
	    let auth = undefined;
	    if (config.auth) {
	      const username = config.auth.username || '';
	      const password = config.auth.password || '';
	      auth = username + ':' + password;
	    }

	    if (!auth && parsed.username) {
	      const urlUsername = parsed.username;
	      const urlPassword = parsed.password;
	      auth = urlUsername + ':' + urlPassword;
	    }

	    auth && headers.delete('authorization');

	    let path;

	    try {
	      path = buildURL(
	        parsed.pathname + parsed.search,
	        config.params,
	        config.paramsSerializer
	      ).replace(/^\?/, '');
	    } catch (err) {
	      const customErr = new Error(err.message);
	      customErr.config = config;
	      customErr.url = config.url;
	      customErr.exists = true;
	      return reject(customErr);
	    }

	    headers.set(
	      'Accept-Encoding',
	      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
	      );

	    const options = {
	      path,
	      method: method,
	      headers: headers.toJSON(),
	      agents: { http: config.httpAgent, https: config.httpsAgent },
	      auth,
	      protocol,
	      family,
	      beforeRedirect: dispatchBeforeRedirect,
	      beforeRedirects: {}
	    };

	    // cacheable-lookup integration hotfix
	    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

	    if (config.socketPath) {
	      options.socketPath = config.socketPath;
	    } else {
	      options.hostname = parsed.hostname;
	      options.port = parsed.port;
	      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
	    }

	    let transport;
	    const isHttpsRequest = isHttps.test(options.protocol);
	    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
	    if (config.transport) {
	      transport = config.transport;
	    } else if (config.maxRedirects === 0) {
	      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
	    } else {
	      if (config.maxRedirects) {
	        options.maxRedirects = config.maxRedirects;
	      }
	      if (config.beforeRedirect) {
	        options.beforeRedirects.config = config.beforeRedirect;
	      }
	      transport = isHttpsRequest ? httpsFollow : httpFollow;
	    }

	    if (config.maxBodyLength > -1) {
	      options.maxBodyLength = config.maxBodyLength;
	    } else {
	      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
	      options.maxBodyLength = Infinity;
	    }

	    if (config.insecureHTTPParser) {
	      options.insecureHTTPParser = config.insecureHTTPParser;
	    }

	    // Create the request
	    req = transport.request(options, function handleResponse(res) {
	      if (req.destroyed) return;

	      const streams = [res];

	      const responseLength = +res.headers['content-length'];

	      if (onDownloadProgress) {
	        const transformStream = new AxiosTransformStream$1({
	          length: utils$1.toFiniteNumber(responseLength),
	          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
	        });

	        onDownloadProgress && transformStream.on('progress', progress => {
	          onDownloadProgress(Object.assign(progress, {
	            download: true
	          }));
	        });

	        streams.push(transformStream);
	      }

	      // decompress the response body transparently if required
	      let responseStream = res;

	      // return the last request in case of redirects
	      const lastRequest = res.req || req;

	      // if decompress disabled we should not decompress
	      if (config.decompress !== false && res.headers['content-encoding']) {
	        // if no content, but headers still say that it is encoded,
	        // remove the header not confuse downstream operations
	        if (method === 'HEAD' || res.statusCode === 204) {
	          delete res.headers['content-encoding'];
	        }

	        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
	        /*eslint default-case:0*/
	        case 'gzip':
	        case 'x-gzip':
	        case 'compress':
	        case 'x-compress':
	          // add the unzipper to the body stream processing pipeline
	          streams.push(zlib__default["default"].createUnzip(zlibOptions));

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	        case 'deflate':
	          streams.push(new ZlibHeaderTransformStream$1());

	          // add the unzipper to the body stream processing pipeline
	          streams.push(zlib__default["default"].createUnzip(zlibOptions));

	          // remove the content-encoding in order to not confuse downstream operations
	          delete res.headers['content-encoding'];
	          break;
	        case 'br':
	          if (isBrotliSupported) {
	            streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
	            delete res.headers['content-encoding'];
	          }
	        }
	      }

	      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];

	      const offListeners = stream__default["default"].finished(responseStream, () => {
	        offListeners();
	        onFinished();
	      });

	      const response = {
	        status: res.statusCode,
	        statusText: res.statusMessage,
	        headers: new AxiosHeaders$1(res.headers),
	        config,
	        request: lastRequest
	      };

	      if (responseType === 'stream') {
	        response.data = responseStream;
	        settle(resolve, reject, response);
	      } else {
	        const responseBuffer = [];
	        let totalResponseBytes = 0;

	        responseStream.on('data', function handleStreamData(chunk) {
	          responseBuffer.push(chunk);
	          totalResponseBytes += chunk.length;

	          // make sure the content length is not over the maxContentLength if specified
	          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
	            // stream.destroy() emit aborted event before calling reject() on Node.js v16
	            rejected = true;
	            responseStream.destroy();
	            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
	              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
	          }
	        });

	        responseStream.on('aborted', function handlerStreamAborted() {
	          if (rejected) {
	            return;
	          }

	          const err = new AxiosError(
	            'maxContentLength size of ' + config.maxContentLength + ' exceeded',
	            AxiosError.ERR_BAD_RESPONSE,
	            config,
	            lastRequest
	          );
	          responseStream.destroy(err);
	          reject(err);
	        });

	        responseStream.on('error', function handleStreamError(err) {
	          if (req.destroyed) return;
	          reject(AxiosError.from(err, null, config, lastRequest));
	        });

	        responseStream.on('end', function handleStreamEnd() {
	          try {
	            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
	            if (responseType !== 'arraybuffer') {
	              responseData = responseData.toString(responseEncoding);
	              if (!responseEncoding || responseEncoding === 'utf8') {
	                responseData = utils$1.stripBOM(responseData);
	              }
	            }
	            response.data = responseData;
	          } catch (err) {
	            return reject(AxiosError.from(err, null, config, response.request, response));
	          }
	          settle(resolve, reject, response);
	        });
	      }

	      emitter.once('abort', err => {
	        if (!responseStream.destroyed) {
	          responseStream.emit('error', err);
	          responseStream.destroy();
	        }
	      });
	    });

	    emitter.once('abort', err => {
	      reject(err);
	      req.destroy(err);
	    });

	    // Handle errors
	    req.on('error', function handleRequestError(err) {
	      // @todo remove
	      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
	      reject(AxiosError.from(err, null, config, req));
	    });

	    // set tcp keep alive to prevent drop connection by peer
	    req.on('socket', function handleRequestSocket(socket) {
	      // default interval of sending ack packet is 1 minute
	      socket.setKeepAlive(true, 1000 * 60);
	    });

	    // Handle request timeout
	    if (config.timeout) {
	      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
	      const timeout = parseInt(config.timeout, 10);

	      if (Number.isNaN(timeout)) {
	        reject(new AxiosError(
	          'error trying to parse `config.timeout` to int',
	          AxiosError.ERR_BAD_OPTION_VALUE,
	          config,
	          req
	        ));

	        return;
	      }

	      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
	      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
	      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
	      // And then these socket which be hang up will devouring CPU little by little.
	      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
	      req.setTimeout(timeout, function handleRequestTimeout() {
	        if (isDone) return;
	        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	        const transitional = config.transitional || transitionalDefaults;
	        if (config.timeoutErrorMessage) {
	          timeoutErrorMessage = config.timeoutErrorMessage;
	        }
	        reject(new AxiosError(
	          timeoutErrorMessage,
	          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	          config,
	          req
	        ));
	        abort();
	      });
	    }


	    // Send the request
	    if (utils$1.isStream(data)) {
	      let ended = false;
	      let errored = false;

	      data.on('end', () => {
	        ended = true;
	      });

	      data.once('error', err => {
	        errored = true;
	        req.destroy(err);
	      });

	      data.on('close', () => {
	        if (!ended && !errored) {
	          abort(new CanceledError('Request stream has been aborted', config, req));
	        }
	      });

	      data.pipe(req);
	    } else {
	      req.end(data);
	    }
	  });
	};

	const cookies = platform.hasStandardBrowserEnv ?

	  // Standard browser envs support document.cookie
	  {
	    write(name, value, expires, path, domain, secure) {
	      const cookie = [name + '=' + encodeURIComponent(value)];

	      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

	      utils$1.isString(path) && cookie.push('path=' + path);

	      utils$1.isString(domain) && cookie.push('domain=' + domain);

	      secure === true && cookie.push('secure');

	      document.cookie = cookie.join('; ');
	    },

	    read(name) {
	      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return (match ? decodeURIComponent(match[3]) : null);
	    },

	    remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  }

	  :

	  // Non-standard browser env (web workers, react-native) lack needed support.
	  {
	    write() {},
	    read() {
	      return null;
	    },
	    remove() {}
	  };

	const isURLSameOrigin = platform.hasStandardBrowserEnv ?

	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    const msie = /(msie|trident)/i.test(navigator.userAgent);
	    const urlParsingNode = document.createElement('a');
	    let originURL;

	    /**
	    * Parse a URL to discover its components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      let href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	          urlParsingNode.pathname :
	          '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	          parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })();

	function progressEventReducer(listener, isDownloadStream) {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);

	  return e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;

	    bytesNotified = loaded;

	    const data = {
	      loaded,
	      total,
	      progress: total ? (loaded / total) : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e
	    };

	    data[isDownloadStream ? 'download' : 'upload'] = true;

	    listener(data);
	  };
	}

	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

	const xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    let requestData = config.data;
	    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
	    let {responseType, withXSRFToken} = config;
	    let onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }

	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }

	    let contentType;

	    if (utils$1.isFormData(requestData)) {
	      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	        requestHeaders.setContentType(false); // Let the browser set it
	      } else if ((contentType = requestHeaders.getContentType()) !== false) {
	        // fix semicolon duplication issue for ReactNative FormData implementation
	        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
	        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
	      }
	    }

	    let request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      const username = config.auth.username || '';
	      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
	    }

	    const fullPath = buildFullPath(config.baseURL, config.url);

	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders$1.from(
	        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
	      );
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
	        request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };

	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = config.transitional || transitionalDefaults;
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(
	        timeoutErrorMessage,
	        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	        config,
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if(platform.hasStandardBrowserEnv) {
	      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

	      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
	        // Add xsrf header
	        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

	        if (xsrfValue) {
	          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
	        }
	      }
	    }

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
	    }

	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };

	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }

	    const protocol = parseProtocol(fullPath);

	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }


	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter
	};

	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {value});
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {value});
	  }
	});

	const renderReason = (reason) => `- ${reason}`;

	const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

	const adapters = {
	  getAdapter: (adapters) => {
	    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

	    const {length} = adapters;
	    let nameOrAdapter;
	    let adapter;

	    const rejectedReasons = {};

	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters[i];
	      let id;

	      adapter = nameOrAdapter;

	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

	        if (adapter === undefined) {
	          throw new AxiosError(`Unknown adapter '${id}'`);
	        }
	      }

	      if (adapter) {
	        break;
	      }

	      rejectedReasons[id || '#' + i] = adapter;
	    }

	    if (!adapter) {

	      const reasons = Object.entries(rejectedReasons)
	        .map(([id, state]) => `adapter ${id} ` +
	          (state === false ? 'is not supported by the environment' : 'is not available in the build')
	        );

	      let s = length ?
	        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
	        'as no adapter specified';

	      throw new AxiosError(
	        `There is no suitable adapter to dispatch the request ` + s,
	        'ERR_NOT_SUPPORT'
	      );
	    }

	    return adapter;
	  },
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }

	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  config.headers = AxiosHeaders$1.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(
	    config,
	    config.transformRequest
	  );

	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }

	  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(
	      config,
	      config.transformResponse,
	      response
	    );

	    response.headers = AxiosHeaders$1.from(response.headers);

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          config.transformResponse,
	          reason.response
	        );
	        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
	      }
	    }

	    return Promise.reject(reason);
	  });
	}

	const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};

	  function getMergedValue(target, source, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({caseless}, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a, caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
	  };

	  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
	  });

	  return config;
	}

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError(
	        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
	        AxiosError.ERR_DEPRECATED
	      );
	    }

	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
	    }
	  }
	}

	const validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	class Axios {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig;
	    this.interceptors = {
	      request: new InterceptorManager$1(),
	      response: new InterceptorManager$1()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy;

	        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

	        // slice off the Error: ... line
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';

	        if (!err.stack) {
	          err.stack = stack;
	          // match without the 2 top stack lines
	        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
	          err.stack += '\n' + stack;
	        }
	      }

	      throw err;
	    }
	  }

	  _request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }

	    config = mergeConfig(this.defaults, config);

	    const {transitional, paramsSerializer, headers} = config;

	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }

	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$1.merge(
	      headers.common,
	      headers[config.method]
	    );

	    headers && utils$1.forEach(
	      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	      (method) => {
	        delete headers[method];
	      }
	    );

	    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }

	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });

	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });

	    let promise;
	    let i = 0;
	    let len;

	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift.apply(chain, requestInterceptorChain);
	      chain.push.apply(chain, responseInterceptorChain);
	      len = chain.length;

	      promise = Promise.resolve(config);

	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }

	      return promise;
	    }

	    len = requestInterceptorChain.length;

	    let newConfig = config;

	    i = 0;

	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }

	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }

	    i = 0;
	    len = responseInterceptorChain.length;

	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }

	    return promise;
	  }

	  getUri(config) {
	    config = mergeConfig(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }

	  Axios.prototype[method] = generateHTTPMethod();

	  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	const Axios$1 = Axios;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	class CancelToken {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }

	    let resolvePromise;

	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });

	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;

	      let i = token._listeners.length;

	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);

	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };

	      return promise;
	    };

	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }

	      token.reason = new CanceledError(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }

	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}

	const CancelToken$1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError(payload) {
	  return utils$1.isObject(payload) && (payload.isAxiosError === true);
	}

	const HttpStatusCode = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511,
	};

	Object.entries(HttpStatusCode).forEach(([key, value]) => {
	  HttpStatusCode[value] = key;
	});

	const HttpStatusCode$1 = HttpStatusCode;

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios$1(defaultConfig);
	  const instance = bind(Axios$1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

	  // Copy context to instance
	  utils$1.extend(instance, context, null, {allOwnKeys: true});

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	  };

	  return instance;
	}

	// Create the default instance to be exported
	const axios = createInstance(defaults$1);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios$1;

	// Expose Cancel & CancelToken
	axios.CanceledError = CanceledError;
	axios.CancelToken = CancelToken$1;
	axios.isCancel = isCancel;
	axios.VERSION = VERSION;
	axios.toFormData = toFormData;

	// Expose AxiosError class
	axios.AxiosError = AxiosError;

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};

	axios.spread = spread;

	// Expose isAxiosError
	axios.isAxiosError = isAxiosError;

	// Expose mergeConfig
	axios.mergeConfig = mergeConfig;

	axios.AxiosHeaders = AxiosHeaders$1;

	axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

	axios.getAdapter = adapters.getAdapter;

	axios.HttpStatusCode = HttpStatusCode$1;

	axios.default = axios;

	axios_1 = axios;
	
	return axios_1;
}

(function (module, exports) {
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	(function webpackUniversalModuleDefinition(root, factory) {
	    if ((_typeof(exports)) === 'object' && (_typeof(module)) === 'object') module.exports = factory(requireAxios());else if ((_typeof(exports)) === 'object') exports["Rox"] = factory(requireAxios());else root["Rox"] = factory(root["axios"]);
	})(commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE__70__) {
	    return (/******/function () {
	            // webpackBootstrap
	            /******/var __webpack_modules__ = [,
	            /* 0 */
	            /* 1 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _ProxyConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

	                var ApiProvider;
	                (function (ApiProvider) {
	                    ApiProvider["RolloutEu"] = "eu";
	                    ApiProvider["Platform"] = "platform";
	                })(ApiProvider || (ApiProvider = {}));
	                var API_HOST = 'x-api.rollout.io';
	                var _proxyConfig = new _ProxyConfig__WEBPACK_IMPORTED_MODULE_0__["default"]();
	                var DEFAULT_CONFIGURATION = function DEFAULT_CONFIGURATION(hostProvider) {
	                    var apiHost = API_HOST;
	                    if (hostProvider == ApiProvider.RolloutEu) {
	                        apiHost = 'eu-' + API_HOST; // as this goes into the url, not using the roxOptions.hosting value. instead using RoxOptions.hosting === "eu" as indication to use "eu-x-api..."
	                    }
	                    var configuration = {
	                        API_HOST: apiHost,
	                        CD_API_ENDPOINT: 'https://' + apiHost + '/device/get_configuration',
	                        CD_S3_ENDPOINT: 'https://conf.rollout.io/',
	                        SS_API_ENDPOINT: 'https://' + apiHost + '/device/update_state_store/',
	                        SS_S3_ENDPOINT: 'https://statestore.rollout.io/',
	                        CLIENT_DATA_CACHE_KEY: 'client_data',
	                        NOTIFICATIONS_ENDPOINT: 'https://push.rollout.io/sse',
	                        ANALYTICS_ENDPOINT: 'https://analytic.rollout.io',
	                        ERROR_REPORTER: undefined
	                    };
	                    if (hostProvider == ApiProvider.Platform) {
	                        configuration.API_HOST = 'api.cloudbees.io';
	                        configuration.CD_API_ENDPOINT = 'https://api.cloudbees.io/device/get_configuration';
	                        configuration.CD_S3_ENDPOINT = 'https://rox-conf.cloudbees.io/';
	                        configuration.SS_API_ENDPOINT = 'https://api.cloudbees.io/device/update_state_store/';
	                        configuration.SS_S3_ENDPOINT = 'https://rox-state.cloudbees.io/';
	                        configuration.ANALYTICS_ENDPOINT = 'https://fm-analytics.cloudbees.io';
	                        configuration.NOTIFICATIONS_ENDPOINT = 'https://sdk-notification-service.cloudbees.io/sse';
	                    }
	                    return configuration;
	                };
	                var SELFMANAGEDMODE_CONFIGURATION = function SELFMANAGEDMODE_CONFIGURATION(_ref) {
	                    var analyticsURL = _ref.analyticsURL,
	                        serverURL = _ref.serverURL,
	                        pushUpdateURL = _ref.pushUpdateURL,
	                        configurationURL = _ref.configurationURL,
	                        stateURL = _ref.stateURL;
	                    return {
	                        CD_API_ENDPOINT: serverURL + '/device/get_configuration',
	                        SS_API_ENDPOINT: serverURL + '/device/update_state_store/',
	                        CLIENT_DATA_CACHE_KEY: 'client_data',
	                        ANALYTICS_ENDPOINT: analyticsURL,
	                        NOTIFICATIONS_ENDPOINT: pushUpdateURL + '/sse',
	                        CD_S3_ENDPOINT: configurationURL,
	                        SS_S3_ENDPOINT: stateURL,
	                        ERROR_REPORTER: undefined
	                    };
	                };
	                var _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION());
	                /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = {
	                    get: function get(key) {
	                        return _activeConfiguration[key];
	                    },
	                    set: function set(key, value) {
	                        _activeConfiguration[key] = value;
	                    },
	                    setActive: function setActive(newConfiguration) {
	                        _activeConfiguration = Object.assign({}, newConfiguration);
	                    },
	                    setProxy: function setProxy(proxySettings) {
	                        _proxyConfig = new _ProxyConfig__WEBPACK_IMPORTED_MODULE_0__["default"](proxySettings);
	                    },
	                    getProxy: function getProxy() {
	                        return _proxyConfig;
	                    },
	                    setHosting: function setHosting(hosting) {
	                        if (hosting === ApiProvider.RolloutEu) {
	                            _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION('eu-'));
	                        }
	                        if (hosting === ApiProvider.Platform) {
	                            _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION(hosting));
	                        }
	                    },
	                    setSelfManagedMode: function setSelfManagedMode(conf) {
	                        _activeConfiguration = Object.assign({}, DEFAULT_CONFIGURATION(), SELFMANAGEDMODE_CONFIGURATION(conf));
	                    },
	                    setErrorReporter: function setErrorReporter(errorReporter) {
	                        _activeConfiguration.ERROR_REPORTER = errorReporter;
	                    },
	                    /**
	                     * Get the error reporter, or undefined if there is none configured.
	                     * Don't forget to check for undefined before using!
	                     */
	                    getErrorReporter: function getErrorReporter() {
	                        return _activeConfiguration.ERROR_REPORTER;
	                    }
	                };

	                /***/
	            },
	            /* 2 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */ProxyConfig
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var js_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);

	                var TARGET_URL_QUERY_PARAM_NAME = 'roxTargetUrl';
	                var AUTH_QUERY_PARAM_NAME = 'roxAuth';

	                var ProxyConfig = function () {
	                    function ProxyConfig(proxySettings) {
	                        _classCallCheck(this, ProxyConfig);

	                        this._proxyUrl = '';
	                        this._proxyAuthHeader = '';
	                        this._proxySettings = false;
	                        if (proxySettings) {
	                            this._proxySettings = Object.assign({}, proxySettings);
	                            // calculating constants
	                            this._proxyUrl = this._proxySettings.protocol + '://' + this._proxySettings.host + (this._proxySettings.port ? ':' + this._proxySettings.port : '');
	                            if (this._proxySettings.auth && this._proxySettings.auth.username && this._proxySettings.auth.password) {
	                                this._proxyAuthHeader = 'Basic ' + (0, js_base64__WEBPACK_IMPORTED_MODULE_0__.encode)(this._proxySettings.auth.username + ':' + this._proxySettings.auth.password);
	                                this._proxyAuthHeaderEncoded = encodeURIComponent(this._proxyAuthHeader);
	                            }
	                        }
	                    }

	                    _createClass(ProxyConfig, [{
	                        key: 'applyProxyToRequest',
	                        value: function applyProxyToRequest(request) {
	                            if (this._proxySettings) {
	                                request.options = request.options ? Object.assign({}, request.options) : {};
	                                var options = request.options;
	                                options.params = options.params || {};
	                                options.params[TARGET_URL_QUERY_PARAM_NAME] = request.url;
	                                if (this._proxyAuthHeader) {
	                                    options.params[AUTH_QUERY_PARAM_NAME] = this._proxyAuthHeader;
	                                }
	                                request.url = this._proxyUrl;
	                            }
	                        }
	                    }, {
	                        key: 'applyProxyToSseRequest',
	                        value: function applyProxyToSseRequest(request) {
	                            if (this._proxySettings) {
	                                request.url = this._proxyUrl + '?' + TARGET_URL_QUERY_PARAM_NAME + '=' + encodeURIComponent(request.url);
	                                if (this._proxyAuthHeaderEncoded) {
	                                    request.url = request.url + '&' + AUTH_QUERY_PARAM_NAME + '=' + this._proxyAuthHeaderEncoded;
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'proxyUrl',
	                        get: function get() {
	                            return this._proxyUrl;
	                        }
	                    }]);

	                    return ProxyConfig;
	                }();

	                /***/
	            },
	            /* 3 */
	            /***/function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */Base64: function Base64() {
	                        return (/* binding */gBase64
	                        );
	                    },
	                    /* harmony export */VERSION: function VERSION() {
	                        return (/* binding */_VERSION
	                        );
	                    },
	                    /* harmony export */atob: function atob() {
	                        return (/* binding */_atob
	                        );
	                    },
	                    /* harmony export */atobPolyfill: function atobPolyfill() {
	                        return (/* binding */_atobPolyfill
	                        );
	                    },
	                    /* harmony export */btoa: function btoa() {
	                        return (/* binding */_btoa
	                        );
	                    },
	                    /* harmony export */btoaPolyfill: function btoaPolyfill() {
	                        return (/* binding */_btoaPolyfill
	                        );
	                    },
	                    /* harmony export */btou: function btou() {
	                        return (/* binding */_btou
	                        );
	                    },
	                    /* harmony export */decode: function decode() {
	                        return (/* binding */_decode2
	                        );
	                    },
	                    /* harmony export */encode: function encode() {
	                        return (/* binding */_encode2
	                        );
	                    },
	                    /* harmony export */encodeURI: function encodeURI() {
	                        return (/* binding */_encodeURI
	                        );
	                    },
	                    /* harmony export */encodeURL: function encodeURL() {
	                        return (/* binding */_encodeURI
	                        );
	                    },
	                    /* harmony export */extendBuiltins: function extendBuiltins() {
	                        return (/* binding */_extendBuiltins
	                        );
	                    },
	                    /* harmony export */extendString: function extendString() {
	                        return (/* binding */_extendString
	                        );
	                    },
	                    /* harmony export */extendUint8Array: function extendUint8Array() {
	                        return (/* binding */_extendUint8Array
	                        );
	                    },
	                    /* harmony export */fromBase64: function fromBase64() {
	                        return (/* binding */_decode2
	                        );
	                    },
	                    /* harmony export */fromUint8Array: function fromUint8Array() {
	                        return (/* binding */_fromUint8Array2
	                        );
	                    },
	                    /* harmony export */isValid: function isValid() {
	                        return (/* binding */_isValid
	                        );
	                    },
	                    /* harmony export */toBase64: function toBase64() {
	                        return (/* binding */_encode2
	                        );
	                    },
	                    /* harmony export */toUint8Array: function toUint8Array() {
	                        return (/* binding */_toUint8Array2
	                        );
	                    },
	                    /* harmony export */utob: function utob() {
	                        return (/* binding */_utob
	                        );
	                    },
	                    /* harmony export */version: function version() {
	                        return (/* binding */_version
	                        );
	                    }
	                    /* harmony export */ });
	                /**
	                 *  base64.ts
	                 *
	                 *  Licensed under the BSD 3-Clause License.
	                 *    http://opensource.org/licenses/BSD-3-Clause
	                 *
	                 *  References:
	                 *    http://en.wikipedia.org/wiki/Base64
	                 *
	                 * @author Dan Kogai (https://github.com/dankogai)
	                 */
	                var _version = '3.7.2';
	                /**
	                 * @deprecated use lowercase `version`.
	                 */
	                var _VERSION = _version;
	                var _hasatob = typeof atob === 'function';
	                var _hasbtoa = typeof btoa === 'function';
	                var _hasBuffer = typeof Buffer === 'function';
	                var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
	                var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
	                var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	                var b64chs = Array.prototype.slice.call(b64ch);
	                var b64tab = function (a) {
	                    var tab = {};
	                    a.forEach(function (c, i) {
	                        return tab[c] = i;
	                    });
	                    return tab;
	                }(b64chs);
	                var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
	                var _fromCC = String.fromCharCode.bind(String);
	                var _U8Afrom = typeof Uint8Array.from === 'function' ? Uint8Array.from.bind(Uint8Array) : function (it) {
	                    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {
	                        return x;
	                    };
	                    return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
	                };
	                var _mkUriSafe = function _mkUriSafe(src) {
	                    return src.replace(/=/g, '').replace(/[+\/]/g, function (m0) {
	                        return m0 == '+' ? '-' : '_';
	                    });
	                };
	                var _tidyB64 = function _tidyB64(s) {
	                    return s.replace(/[^A-Za-z0-9\+\/]/g, '');
	                };
	                /**
	                 * polyfill version of `btoa`
	                 */
	                var _btoaPolyfill = function _btoaPolyfill(bin) {
	                    // console.log('polyfilled');
	                    var u32 = void 0,
	                        c0 = void 0,
	                        c1 = void 0,
	                        c2 = void 0,
	                        asc = '';
	                    var pad = bin.length % 3;
	                    for (var i = 0; i < bin.length;) {
	                        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255) throw new TypeError('invalid character found');
	                        u32 = c0 << 16 | c1 << 8 | c2;
	                        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
	                    }
	                    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
	                };
	                /**
	                 * does what `window.btoa` of web browsers do.
	                 * @param {String} bin binary string
	                 * @returns {string} Base64-encoded string
	                 */
	                var _btoa = _hasbtoa ? function (bin) {
	                    return btoa(bin);
	                } : _hasBuffer ? function (bin) {
	                    return Buffer.from(bin, 'binary').toString('base64');
	                } : _btoaPolyfill;
	                var _fromUint8Array = _hasBuffer ? function (u8a) {
	                    return Buffer.from(u8a).toString('base64');
	                } : function (u8a) {
	                    // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
	                    var maxargs = 0x1000;
	                    var strs = [];
	                    for (var i = 0, l = u8a.length; i < l; i += maxargs) {
	                        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
	                    }
	                    return _btoa(strs.join(''));
	                };
	                /**
	                 * converts a Uint8Array to a Base64 string.
	                 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
	                 * @returns {string} Base64 string
	                 */
	                var _fromUint8Array2 = function _fromUint8Array2(u8a) {
	                    var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	                    return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
	                };
	                // This trick is found broken https://github.com/dankogai/js-base64/issues/130
	                // const utob = (src: string) => unescape(encodeURIComponent(src));
	                // reverting good old fationed regexp
	                var cb_utob = function cb_utob(c) {
	                    if (c.length < 2) {
	                        var cc = c.charCodeAt(0);
	                        return cc < 0x80 ? c : cc < 0x800 ? _fromCC(0xc0 | cc >>> 6) + _fromCC(0x80 | cc & 0x3f) : _fromCC(0xe0 | cc >>> 12 & 0x0f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
	                    } else {
	                        var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
	                        return _fromCC(0xf0 | cc >>> 18 & 0x07) + _fromCC(0x80 | cc >>> 12 & 0x3f) + _fromCC(0x80 | cc >>> 6 & 0x3f) + _fromCC(0x80 | cc & 0x3f);
	                    }
	                };
	                var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	                /**
	                 * @deprecated should have been internal use only.
	                 * @param {string} src UTF-8 string
	                 * @returns {string} UTF-16 string
	                 */
	                var _utob = function _utob(u) {
	                    return u.replace(re_utob, cb_utob);
	                };
	                //
	                var _encode = _hasBuffer ? function (s) {
	                    return Buffer.from(s, 'utf8').toString('base64');
	                } : _TE ? function (s) {
	                    return _fromUint8Array(_TE.encode(s));
	                } : function (s) {
	                    return _btoa(_utob(s));
	                };
	                /**
	                 * converts a UTF-8-encoded string to a Base64 string.
	                 * @param {boolean} [urlsafe] if `true` make the result URL-safe
	                 * @returns {string} Base64 string
	                 */
	                var _encode2 = function _encode2(src) {
	                    var urlsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	                    return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
	                };
	                /**
	                 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
	                 * @returns {string} Base64 string
	                 */
	                var _encodeURI = function _encodeURI(src) {
	                    return _encode2(src, true);
	                };
	                // This trick is found broken https://github.com/dankogai/js-base64/issues/130
	                // const btou = (src: string) => decodeURIComponent(escape(src));
	                // reverting good old fationed regexp
	                var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
	                var cb_btou = function cb_btou(cccc) {
	                    switch (cccc.length) {
	                        case 4:
	                            var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
	                                offset = cp - 0x10000;
	                            return _fromCC((offset >>> 10) + 0xD800) + _fromCC((offset & 0x3FF) + 0xDC00);
	                        case 3:
	                            return _fromCC((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
	                        default:
	                            return _fromCC((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
	                    }
	                };
	                /**
	                 * @deprecated should have been internal use only.
	                 * @param {string} src UTF-16 string
	                 * @returns {string} UTF-8 string
	                 */
	                var _btou = function _btou(b) {
	                    return b.replace(re_btou, cb_btou);
	                };
	                /**
	                 * polyfill version of `atob`
	                 */
	                var _atobPolyfill = function _atobPolyfill(asc) {
	                    // console.log('polyfilled');
	                    asc = asc.replace(/\s+/g, '');
	                    if (!b64re.test(asc)) throw new TypeError('malformed base64.');
	                    asc += '=='.slice(2 - (asc.length & 3));
	                    var u24 = void 0,
	                        bin = '',
	                        r1 = void 0,
	                        r2 = void 0;
	                    for (var i = 0; i < asc.length;) {
	                        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
	                        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
	                    }
	                    return bin;
	                };
	                /**
	                 * does what `window.atob` of web browsers do.
	                 * @param {String} asc Base64-encoded string
	                 * @returns {string} binary string
	                 */
	                var _atob = _hasatob ? function (asc) {
	                    return atob(_tidyB64(asc));
	                } : _hasBuffer ? function (asc) {
	                    return Buffer.from(asc, 'base64').toString('binary');
	                } : _atobPolyfill;
	                //
	                var _toUint8Array = _hasBuffer ? function (a) {
	                    return _U8Afrom(Buffer.from(a, 'base64'));
	                } : function (a) {
	                    return _U8Afrom(_atob(a), function (c) {
	                        return c.charCodeAt(0);
	                    });
	                };
	                /**
	                 * converts a Base64 string to a Uint8Array.
	                 */
	                var _toUint8Array2 = function _toUint8Array2(a) {
	                    return _toUint8Array(_unURI(a));
	                };
	                //
	                var _decode = _hasBuffer ? function (a) {
	                    return Buffer.from(a, 'base64').toString('utf8');
	                } : _TD ? function (a) {
	                    return _TD.decode(_toUint8Array(a));
	                } : function (a) {
	                    return _btou(_atob(a));
	                };
	                var _unURI = function _unURI(a) {
	                    return _tidyB64(a.replace(/[-_]/g, function (m0) {
	                        return m0 == '-' ? '+' : '/';
	                    }));
	                };
	                /**
	                 * converts a Base64 string to a UTF-8 string.
	                 * @param {String} src Base64 string.  Both normal and URL-safe are supported
	                 * @returns {string} UTF-8 string
	                 */
	                var _decode2 = function _decode2(src) {
	                    return _decode(_unURI(src));
	                };
	                /**
	                 * check if a value is a valid Base64 string
	                 * @param {String} src a value to check
	                  */
	                var _isValid = function _isValid(src) {
	                    if (typeof src !== 'string') return false;
	                    var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
	                    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
	                };
	                //
	                var _noEnum = function _noEnum(v) {
	                    return {
	                        value: v, enumerable: false, writable: true, configurable: true
	                    };
	                };
	                /**
	                 * extend String.prototype with relevant methods
	                 */
	                var _extendString = function _extendString() {
	                    var _add = function _add(name, body) {
	                        return Object.defineProperty(String.prototype, name, _noEnum(body));
	                    };
	                    _add('fromBase64', function () {
	                        return _decode2(this);
	                    });
	                    _add('toBase64', function (urlsafe) {
	                        return _encode2(this, urlsafe);
	                    });
	                    _add('toBase64URI', function () {
	                        return _encode2(this, true);
	                    });
	                    _add('toBase64URL', function () {
	                        return _encode2(this, true);
	                    });
	                    _add('toUint8Array', function () {
	                        return _toUint8Array2(this);
	                    });
	                };
	                /**
	                 * extend Uint8Array.prototype with relevant methods
	                 */
	                var _extendUint8Array = function _extendUint8Array() {
	                    var _add = function _add(name, body) {
	                        return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
	                    };
	                    _add('toBase64', function (urlsafe) {
	                        return _fromUint8Array2(this, urlsafe);
	                    });
	                    _add('toBase64URI', function () {
	                        return _fromUint8Array2(this, true);
	                    });
	                    _add('toBase64URL', function () {
	                        return _fromUint8Array2(this, true);
	                    });
	                };
	                /**
	                 * extend Builtin prototypes with relevant methods
	                 */
	                var _extendBuiltins = function _extendBuiltins() {
	                    _extendString();
	                    _extendUint8Array();
	                };
	                var gBase64 = {
	                    version: _version,
	                    VERSION: _VERSION,
	                    atob: _atob,
	                    atobPolyfill: _atobPolyfill,
	                    btoa: _btoa,
	                    btoaPolyfill: _btoaPolyfill,
	                    fromBase64: _decode2,
	                    toBase64: _encode2,
	                    encode: _encode2,
	                    encodeURI: _encodeURI,
	                    encodeURL: _encodeURI,
	                    utob: _utob,
	                    btou: _btou,
	                    decode: _decode2,
	                    isValid: _isValid,
	                    fromUint8Array: _fromUint8Array2,
	                    toUint8Array: _toUint8Array2,
	                    extendString: _extendString,
	                    extendUint8Array: _extendUint8Array,
	                    extendBuiltins: _extendBuiltins
	                };
	                // makecjs:CUT //


	                // and finally,


	                /***/
	            },
	            /* 4 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */CallContextTypes: function CallContextTypes() {
	                        return (/* reexport safe */_RoxStringBase__WEBPACK_IMPORTED_MODULE_5__.callContextTypes
	                        );
	                    },
	                    /* harmony export */CustomProperty: function CustomProperty() {
	                        return (/* reexport safe */_CustomProperty__WEBPACK_IMPORTED_MODULE_0__["default"]
	                        );
	                    },
	                    /* harmony export */DeploymentConfiguration: function DeploymentConfiguration() {
	                        return (/* reexport safe */_DeploymentConfiguration__WEBPACK_IMPORTED_MODULE_2__["default"]
	                        );
	                    },
	                    /* harmony export */DeviceProperty: function DeviceProperty() {
	                        return (/* reexport safe */_DeviceProperty__WEBPACK_IMPORTED_MODULE_1__["default"]
	                        );
	                    },
	                    /* harmony export */Experiment: function Experiment() {
	                        return (/* reexport safe */_Experiment__WEBPACK_IMPORTED_MODULE_3__["default"]
	                        );
	                    },
	                    /* harmony export */FlagTypes: function FlagTypes() {
	                        return (/* reexport safe */_RoxStringBase__WEBPACK_IMPORTED_MODULE_5__.FlagTypes
	                        );
	                    },
	                    /* harmony export */RoxStringBase: function RoxStringBase() {
	                        return (/* reexport safe */_RoxStringBase__WEBPACK_IMPORTED_MODULE_5__["default"]
	                        );
	                    },
	                    /* harmony export */TargetGroup: function TargetGroup() {
	                        return (/* reexport safe */_TargetGroup__WEBPACK_IMPORTED_MODULE_4__["default"]
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _CustomProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
	                /* harmony import */var _DeviceProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
	                /* harmony import */var _DeploymentConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
	                /* harmony import */var _Experiment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
	                /* harmony import */var _TargetGroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
	                /* harmony import */var _RoxStringBase__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);

	                /***/
	            },
	            /* 5 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */CustomProperty
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _lib_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

	                var SEM_VER_TYPE = 'Semver';
	                var _validateName = function _validateName(name) {
	                    if (typeof name === 'undefined' || name === '') {
	                        throw new Error('Custom property must be initialized with a name.');
	                    }
	                };
	                var _validateExplicitValue = function _validateExplicitValue(type, value) {
	                    if (value && value.constructor !== type && value.constructor !== Function) {
	                        // add here a condition with a return if we want to validate semver (we usually don't, it's just a string)
	                        throw new Error('Custom property initialized with an invalid type / value combination. (Type: ' + type + ', Value: ' + value + ')');
	                    }
	                };
	                var _validateDynamicValue = function _validateDynamicValue(value) {
	                    var argsExpected = value.length;
	                    if (argsExpected > 1) {
	                        throw new Error('Dynamic value of a custom property should be a function with maximum 1 argument');
	                    }
	                };

	                var CustomProperty = function () {
	                    function CustomProperty(name, type, value) {
	                        _classCallCheck(this, CustomProperty);

	                        if (type === SEM_VER_TYPE) {
	                            this._isSemver = true;
	                            type = String;
	                        }
	                        _validateName(name);
	                        this._name = name;
	                        if (typeof value === 'function') {
	                            _validateDynamicValue(value);
	                            value.isDynamic = true;
	                            this._value = value;
	                        } else {
	                            _validateExplicitValue(type, value);
	                            this._value = function () {
	                                return value;
	                            };
	                        }
	                        this._type = type;
	                    }

	                    _createClass(CustomProperty, [{
	                        key: 'getValue',
	                        value: function getValue() {
	                            var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	                            if (this._value && this._value.isDynamic) {
	                                try {
	                                    return this._value(context);
	                                } catch (err) {
	                                    err.isUserError = true;
	                                    err.trigger = _lib_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_0__.ExceptionTrigger.CUSTOM_PROPERTY_GENERATOR;
	                                    throw err;
	                                }
	                            }
	                            return this._value(context);
	                        }
	                    }, {
	                        key: 'type',
	                        get: function get() {
	                            return this.externalType;
	                        }
	                    }, {
	                        key: 'externalType',
	                        get: function get() {
	                            if (this._isSemver) {
	                                return SEM_VER_TYPE;
	                            }
	                            if (this._type.name == Date.name) {
	                                return CustomProperty.dateTypeName;
	                            }
	                            return this._type.name;
	                        }
	                    }, {
	                        key: 'name',
	                        get: function get() {
	                            return this._name;
	                        }
	                    }, {
	                        key: 'value',
	                        get: function get() {
	                            return this._value();
	                        }
	                    }], [{
	                        key: 'dateTypeName',
	                        get: function get() {
	                            return 'DateTime';
	                        }
	                    }, {
	                        key: 'semverTypeName',
	                        get: function get() {
	                            return SEM_VER_TYPE;
	                        }
	                    }]);

	                    return CustomProperty;
	                }();

	                /***/
	            },
	            /* 6 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */ExceptionTrigger: function ExceptionTrigger() {
	                        return (/* binding */_ExceptionTrigger
	                        );
	                    },
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);

	                var _ExceptionTrigger = {
	                    DYNAMIC_PROPERTIES_RULE: 'DYNAMIC_PROPERTIES_RULE',
	                    CONFIGURATION_FETCHED_HANDLER: 'CONFIGURATION_FETCHED_HANDLER',
	                    IMPRESSION_HANDLER: 'IMPRESSION_HANDLER',
	                    CUSTOM_PROPERTY_GENERATOR: 'CUSTOM_PROPERTY_GENERATOR'
	                };

	                var UserspaceUnhandledErrorInvoker = function () {
	                    function UserspaceUnhandledErrorInvoker() {
	                        _classCallCheck(this, UserspaceUnhandledErrorInvoker);
	                    }

	                    _createClass(UserspaceUnhandledErrorInvoker, [{
	                        key: 'invoke',
	                        value: function invoke(exceptionTrigger, error) {
	                            if (!this.userUnhandledErrorHandler) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].error('User Unhandled Error Occured, no fallback handler was set, exception ignored.', error);
	                                return;
	                            }
	                            try {
	                                this.userUnhandledErrorHandler(exceptionTrigger, error);
	                            } catch (err) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].error('User Unhandled Error Handler itself threw an exception. original exception:' + error, err);
	                            }
	                        }
	                    }, {
	                        key: 'setHandler',
	                        value: function setHandler(handler) {
	                            if (!(handler instanceof Function)) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].warn('UserspaceUnhandledErrorHandler must be a function. default will be used.');
	                                return;
	                            }
	                            this.userUnhandledErrorHandler = handler;
	                        }
	                    }]);

	                    return UserspaceUnhandledErrorInvoker;
	                }();
	                // wanted to create with new on client.js and pass it as an object, but 'new RoxParser()' appears in too many places :(
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = new UserspaceUnhandledErrorInvoker();

	                /***/
	            },
	            /* 7 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                var levels = {
	                    debug: 0,
	                    info: 1,
	                    warn: 2,
	                    error: 3
	                };
	                var level = 'error';

	                var Logger = function Logger() {
	                    var _this = this;

	                    _classCallCheck(this, Logger);

	                    this.debug = function (data) {
	                        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                            args[_key - 1] = arguments[_key];
	                        }

	                        if (levels[level] <= levels.debug && console /* console not present on old IEs */) {
	                                var _console;

	                                (_console = console).log.apply(_console, [data].concat(args)); // eslint-disable-line no-console
	                            }
	                    };
	                    this.info = function (data) {
	                        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	                            args[_key2 - 1] = arguments[_key2];
	                        }

	                        if (levels[level] <= levels.info && console /* console not present on old IEs */) {
	                                var _console2;

	                                (_console2 = console).info.apply(_console2, [data].concat(args)); // eslint-disable-line no-console
	                            }
	                    };
	                    this.warn = function (data) {
	                        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	                            args[_key3 - 1] = arguments[_key3];
	                        }

	                        if (levels[level] <= levels.warn && console /* console not present on old IEs */) {
	                                var _console3;

	                                (_console3 = console).warn.apply(_console3, [data].concat(args)); // eslint-disable-line no-console
	                            }
	                    };
	                    this.error = function (data) {
	                        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	                            args[_key4 - 1] = arguments[_key4];
	                        }

	                        if (console /* console not present on old IEs */) {
	                                var _console4;

	                                (_console4 = console).error.apply(_console4, [data].concat(args)); // eslint-disable-line no-console
	                            }
	                    };
	                    this.setVerboseMode = function (debugLevel) {
	                        if (debugLevel === 'verbose') {
	                            level = 'debug';
	                            _this.debug('Active verbose mode');
	                        } else {
	                            level = 'error';
	                        }
	                    };
	                    this.setLogger = function (newLogger) {
	                        logger = newLogger;
	                    };
	                };

	                var logger = new Logger();
	                /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = logger;

	                /***/
	            },
	            /* 8 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */DeviceProperty
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _CustomProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);

	                var DeviceProperty = function (_CustomProperty__WEBP) {
	                    _inherits(DeviceProperty, _CustomProperty__WEBP);

	                    function DeviceProperty() {
	                        _classCallCheck(this, DeviceProperty);

	                        return _possibleConstructorReturn(this, (DeviceProperty.__proto__ || Object.getPrototypeOf(DeviceProperty)).apply(this, arguments));
	                    }

	                    _createClass(DeviceProperty, [{
	                        key: 'name',
	                        get: function get() {
	                            return 'rox.' + _get(DeviceProperty.prototype.__proto__ || Object.getPrototypeOf(DeviceProperty.prototype), 'name', this);
	                        }
	                    }]);

	                    return DeviceProperty;
	                }(_CustomProperty__WEBPACK_IMPORTED_MODULE_0__["default"]);

	                /***/
	            },
	            /* 9 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */DeploymentConfiguration
	                        );
	                    }
	                    /* harmony export */ });

	                var DeploymentConfiguration = function DeploymentConfiguration(condition) {
	                    _classCallCheck(this, DeploymentConfiguration);

	                    this.condition = condition;
	                };

	                /***/
	            },
	            /* 10 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */Experiment
	                        );
	                    }
	                    /* harmony export */ });

	                var Experiment = function Experiment(identifier, name, archived, sticky, deploymentConfiguration, flags, labels, stickinessProperty) {
	                    _classCallCheck(this, Experiment);

	                    this.identifier = identifier;
	                    this.name = name;
	                    this.archived = archived;
	                    this.sticky = sticky;
	                    this.deploymentConfiguration = deploymentConfiguration;
	                    this.flags = flags;
	                    this.labels = labels;
	                    this.stickinessProperty = stickinessProperty;
	                };

	                /***/
	            },
	            /* 11 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */TargetGroup
	                        );
	                    }
	                    /* harmony export */ });

	                var TargetGroup = function TargetGroup(identifier, condition) {
	                    _classCallCheck(this, TargetGroup);

	                    this.identifier = identifier;
	                    this.condition = condition;
	                };

	                /***/
	            },
	            /* 12 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */FlagTypes: function FlagTypes() {
	                        return (/* binding */_FlagTypes
	                        );
	                    },
	                    /* harmony export */callContextTypes: function callContextTypes() {
	                        return (/* binding */_callContextTypes
	                        );
	                    },
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */RoxStringBase
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _lib_ImpressionHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);

	                var _callContextTypes = {
	                    frozenOrCalc: 'frozenValueOrOneTimeEval',
	                    oneTimeCalc: 'oneTimeEval',
	                    default: 'useFrozen'
	                };
	                var _FlagTypes = {
	                    boolean: 'boolean',
	                    number: 'number',
	                    string: 'string'
	                };

	                var RoxStringBase = function () {
	                    function RoxStringBase(defaultValue, variations, type) {
	                        _classCallCheck(this, RoxStringBase);

	                        this._type = type;
	                        var stringDefault = this._validateDefault(defaultValue);
	                        if (Array.isArray(variations)) {
	                            this._validateOptions(variations);
	                            this._options = variations.map(function (v) {
	                                return v.toString();
	                            });
	                        } else if (variations === null || variations === undefined) {
	                            this._options = [];
	                        } else {
	                            throw new Error('RoxStringBase wrong variations type');
	                        }
	                        if (this._options.indexOf(stringDefault) === -1) {
	                            this._options.push(stringDefault);
	                        }
	                        this._value = this._defaultValue = stringDefault;
	                        this._frozen = false;
	                        this._freezable = true;
	                    }

	                    _createClass(RoxStringBase, [{
	                        key: '_validateDefault',
	                        value: function _validateDefault(defaultValue) {
	                            if ((typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue)) !== this._type) {
	                                throw new Error('RoxStringBase default value must be of ' + this._type + ' type. Received \'' + defaultValue + '\'');
	                            }
	                            return defaultValue.toString();
	                        }
	                    }, {
	                        key: '_validateOptions',
	                        value: function _validateOptions(variations) {
	                            var _this3 = this;

	                            var optionsError = new Error('RoxStringBase options must be a non-empty array of ' + this._type + '. Received \'' + variations + '\'');
	                            if (!variations.every(function (option) {
	                                return (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === _this3._type;
	                            })) {
	                                throw optionsError;
	                            }
	                        }
	                    }, {
	                        key: 'getInternalValue',

	                        /* abstract */
	                        // eslint-disable-next-line no-unused-vars
	                        value: function getInternalValue(_, __) {
	                            throw Error('not implemented');
	                        }
	                    }, {
	                        key: '_getNameDetails',
	                        value: function _getNameDetails() {
	                            if (!this.name) return;
	                            var els = this.name.split('.');
	                            return {
	                                name: els.pop(),
	                                namespace: els.join('.') || 'default'
	                            };
	                        }
	                    }, {
	                        key: 'dump',
	                        value: function dump() {
	                            var currentValueCall = { type: _callContextTypes.frozenOrCalc };
	                            this.getInternalValue(currentValueCall);
	                            return {
	                                name: this.name,
	                                type: this._type,
	                                nameDetails: this._getNameDetails(),
	                                options: [].concat(_toConsumableArray(this._options)),
	                                defaultValue: this.defaultValue,
	                                originalValue: this._originalValue(),
	                                overridingValue: this.overridenValue,
	                                value: currentValueCall.result.value
	                            };
	                        }
	                        // eslint-disable-next-line no-unused-vars

	                    }, {
	                        key: 'getActiveValue',
	                        value: function getActiveValue(_, __) {
	                            throw new Error('Not implemented');
	                        }
	                    }, {
	                        key: '_originalValue',
	                        value: function _originalValue() {
	                            var callContext = { type: _callContextTypes.frozenOrCalc };
	                            this.getActiveValue(callContext);
	                            return callContext.result.value;
	                        }
	                    }, {
	                        key: '_flagImpression',
	                        value: function _flagImpression(value, context) {
	                            (0, _lib_ImpressionHandler__WEBPACK_IMPORTED_MODULE_0__.invokeImpression)(value, this, context);
	                        }
	                    }, {
	                        key: 'defaultValue',
	                        get: function get() {
	                            return this._defaultValue;
	                        }
	                    }, {
	                        key: 'overridenValue',
	                        get: function get() {
	                            if (this.overrider.hasOverride(this.name)) {
	                                return this.overrider.getOverride(this.name);
	                            }
	                        }
	                    }, {
	                        key: 'overrider',
	                        get: function get() {
	                            throw new Error('Not implemented');
	                        }
	                    }, {
	                        key: 'externalType',
	                        get: function get() {
	                            switch (this._type) {
	                                case _FlagTypes.boolean:
	                                    return Boolean.name;
	                                case _FlagTypes.number:
	                                    return Number.name;
	                                case _FlagTypes.string:
	                                    return String.name;
	                                default:
	                                    return String.name;
	                            }
	                        }
	                    }, {
	                        key: 'name',
	                        set: function set(name) {
	                            this._name = name;
	                        },
	                        get: function get() {
	                            return this._name;
	                        }
	                    }], [{
	                        key: '_normalizeString',
	                        value: function _normalizeString(stringValue) {
	                            return stringValue;
	                        }
	                    }, {
	                        key: '_normalizeNumber',
	                        value: function _normalizeNumber(stringValue) {
	                            return Number(stringValue);
	                        }
	                    }, {
	                        key: '_normalizeBoolean',
	                        value: function _normalizeBoolean(stringValue) {
	                            if (typeof stringValue === 'boolean') return stringValue;
	                            return stringValue === 'true';
	                        }
	                    }]);

	                    return RoxStringBase;
	                }();

	                /***/
	            },
	            /* 13 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */invokeImpression: function invokeImpression() {
	                        return (/* binding */_invokeImpression
	                        );
	                    },
	                    /* harmony export */setAnalytics: function setAnalytics() {
	                        return (/* binding */_setAnalytics
	                        );
	                    },
	                    /* harmony export */setHandler: function setHandler() {
	                        return (/* binding */_setHandler
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
	                /* harmony import */var _InternalFlags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
	                /* harmony import */var _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
	                /* harmony import */var _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
	                /* harmony import */var _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);

	                var impressionHandler = null;
	                var analytics = null;
	                function _invokeImpression(value, flag, context) {
	                    var originExperiment = _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_0__["default"].experimentForFlag(flag);
	                    try {
	                        if (analytics && (0, _InternalFlags__WEBPACK_IMPORTED_MODULE_1__.isEnabled)('rox.internal.analytics')) {
	                            var originalExperimentStickinessPropName = originExperiment && originExperiment.stickinessProperty;
	                            var distinctIdProp = originalExperimentStickinessPropName && _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_2__["default"].get(originalExperimentStickinessPropName);
	                            distinctIdProp = distinctIdProp || _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_2__["default"].get('rox.distinct_id');
	                            var distinctId = distinctIdProp ? distinctIdProp.getValue(context) : '';
	                            analytics.track({
	                                flag: flag.name,
	                                value: value,
	                                distinctId: distinctId,
	                                type: 'IMPRESSION',
	                                time: new Date().getTime()
	                            });
	                        }
	                    } catch (err) {
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_3__["default"].error('Failed to send analytics', err);
	                    }
	                    if (typeof impressionHandler !== 'function') return;
	                    var targeting = !!originExperiment;
	                    try {
	                        impressionHandler({ name: flag.name, value: value, targeting: targeting }, context);
	                    } catch (error) {
	                        _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_4__["default"].invoke(_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_4__.ExceptionTrigger.IMPRESSION_HANDLER, error);
	                    }
	                }
	                function _setHandler(handler) {
	                    impressionHandler = handler;
	                }
	                function _setAnalytics(a) {
	                    analytics = a;
	                }

	                /***/
	            },
	            /* 14 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });

	                var ExperimentsRepository = function () {
	                    function ExperimentsRepository() {
	                        _classCallCheck(this, ExperimentsRepository);

	                        this.map = {};
	                    }

	                    _createClass(ExperimentsRepository, [{
	                        key: 'setExperiments',
	                        value: function setExperiments(experiments) {
	                            this.map = {};
	                            experiments = experiments || [];
	                            experiments.forEach(function (element) {
	                                this.map[element.identifier] = element;
	                            }, this);
	                        }
	                    }, {
	                        key: 'experimentWithName',
	                        value: function experimentWithName(name) {
	                            return this.map[name];
	                        }
	                    }, {
	                        key: 'experimentForFlagName',
	                        value: function experimentForFlagName(flagName) {
	                            return this.experiments.find(function (e) {
	                                return e.flags && e.flags.some(function (f) {
	                                    return f.name === flagName;
	                                });
	                            });
	                        }
	                    }, {
	                        key: 'experimentForFlag',
	                        value: function experimentForFlag(flag) {
	                            return this.experimentForFlagName(flag.name);
	                        }
	                    }, {
	                        key: 'experiments',
	                        get: function get() {
	                            var _this4 = this;

	                            return Object.keys(this.map).map(function (t) {
	                                return _this4.map[t];
	                            });
	                        }
	                    }]);

	                    return ExperimentsRepository;
	                }();

	                var instance = new ExperimentsRepository();
	                /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = instance;

	                /***/
	            },
	            /* 15 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */getNumber: function getNumber() {
	                        return (/* binding */_getNumber
	                        );
	                    },
	                    /* harmony export */isEnabled: function isEnabled() {
	                        return (/* binding */_isEnabled
	                        );
	                    },
	                    /* harmony export */setDefaultsMode: function setDefaultsMode() {
	                        return (/* binding */_setDefaultsMode
	                        );
	                    },
	                    /* harmony export */value: function value() {
	                        return (/* binding */_value
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _parsers_RoxxParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
	                /* harmony import */var _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

	                var isDefaultsMode = false;
	                var DEFAULTS = {
	                    'rox.internal.pushUpdates': 'true',
	                    'rox.internal.considerThrottleInPush': 'false',
	                    'rox.internal.throttleFetchInSeconds': '0',
	                    'rox.internal.analytics': 'true'
	                };
	                function _isEnabled(flagName) {
	                    var val = _value(flagName);
	                    if (typeof val === 'boolean') return val;
	                    return val === 'true';
	                }
	                function _value(flagName) {
	                    if (isDefaultsMode && Object.prototype.hasOwnProperty.call(DEFAULTS, flagName)) {
	                        return DEFAULTS[flagName];
	                    }
	                    var internalExperiment = _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_0__["default"].experimentForFlagName(flagName);
	                    if (!internalExperiment || !internalExperiment.deploymentConfiguration) return '';
	                    var value = new _parsers_RoxxParser__WEBPACK_IMPORTED_MODULE_1__["default"]().evaluateExpression(internalExperiment.deploymentConfiguration.condition);
	                    return value;
	                }
	                function _getNumber(flagName) {
	                    var val = _value(flagName);
	                    return parseInt(val) || 0;
	                }
	                function _setDefaultsMode(mode) {
	                    isDefaultsMode = mode;
	                }

	                /***/
	            },
	            /* 16 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */RoxxParser
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxxTokenizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
	                /* harmony import */var _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
	                /* harmony import */var _lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
	                /* harmony import */var _lib_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);

	                var RoxxParser = function () {
	                    /**
	                     * A parser for Roxx expressions.
	                     * Roxx expression are polish notation expressions {@link https://en.wikipedia.org/wiki/Polish_notation}
	                     * @class
	                     * @module RoxxParser
	                     * @param {*} cache - Optional token cache object. A default cache object is used if none specified.
	                     */
	                    function RoxxParser(cache) {
	                        _classCallCheck(this, RoxxParser);

	                        this._tokenizer = new _RoxxTokenizer__WEBPACK_IMPORTED_MODULE_0__.RoxxTokenizer();
	                        this._cache = cache || {};
	                    }
	                    /**
	                     * Given an operator function and stack, return an array of arguments for the operator.
	                     * @param {Function} operator
	                     * @param {Array} stack
	                     * @returns {Array} Array of arguments for operator
	                     * @private
	                     */


	                    _createClass(RoxxParser, [{
	                        key: '_argsArrayForOperator',
	                        value: function _argsArrayForOperator(operator, stack) {
	                            var argsArray = [];
	                            var length = operator.length;
	                            for (var i = 0; i < length; i++) {
	                                var arg = stack.pop();
	                                argsArray.push(arg);
	                            }
	                            return argsArray;
	                        }
	                        /**
	                         * Add context to specific operators after operator's args args.
	                         * @param {*} operator, args, context
	                         * @returns {Array} Args array with/without context
	                         */

	                    }, {
	                        key: '_modifyArgsHook',
	                        value: function _modifyArgsHook(_ref2) {
	                            var operator = _ref2.operator,
	                                args = _ref2.args,
	                                context = _ref2.context,
	                                callContext = _ref2.callContext;

	                            var argsWithContext = args;
	                            if (context && _lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_1__.operatorsWithContext.indexOf(operator) !== -1) {
	                                argsWithContext = [].concat(_toConsumableArray(args), [context]); // insert context
	                            }
	                            if (callContext) {
	                                return [].concat(_toConsumableArray(argsWithContext), [callContext]);
	                            }
	                            return argsWithContext;
	                        }
	                        /**
	                         * Tokenizes and caches expr if not available in cache.
	                         * @param {string} expr
	                         * @returns {Array} Tokenized version of expr
	                         */

	                    }, {
	                        key: 'compileExpression',
	                        value: function compileExpression(expr) {
	                            var tokens = this._cache[expr];
	                            if (!tokens) {
	                                tokens = this._tokenizer.tokenize(expr).reverse();
	                                this._cache[expr] = tokens;
	                            }
	                            return tokens;
	                        }
	                        /**
	                         * Evaluates a Roxx expression.
	                         *
	                         * @param {string} expr - Roxx expression string.
	                         * @returns {*} Result of Roxx expression evaluation.
	                         */

	                    }, {
	                        key: 'evaluateExpression',
	                        value: function evaluateExpression(expr) {
	                            var callContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	                            var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	                            var collector = arguments[3];

	                            var _a;
	                            var stack = [];
	                            var tokens = this.compileExpression(expr);
	                            var result = undefined;
	                            var length = tokens.length;
	                            try {
	                                for (var i = 0; i < length; i++) {
	                                    var token = tokens[i];
	                                    if (token.type == _RoxxTokenizer__WEBPACK_IMPORTED_MODULE_0__.RoxxTokenTypeRand) {
	                                        stack.push(token.value);
	                                    } else if (token.type == _RoxxTokenizer__WEBPACK_IMPORTED_MODULE_0__.RoxxTokenTypeRator) {
	                                        var operator = _lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_1__[token.value];
	                                        var args = this._argsArrayForOperator(operator, stack);
	                                        args = this._modifyArgsHook({ operator: operator, args: args, context: context, callContext: callContext });
	                                        var value = operator.apply(this, args);
	                                        stack.push(value);
	                                        var debugSentence = token.value + '(' + JSON.stringify(args) + ') => ' + value;
	                                        if (collector) {
	                                            collector.push(debugSentence);
	                                        }
	                                        _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_2__["default"].debug('Roxx: ' + debugSentence);
	                                    } else {
	                                        stack.push(undefined);
	                                        break;
	                                    }
	                                }
	                                result = stack.pop();
	                            } catch (err) {
	                                var message = 'Uh oh! An error occurred during Roxx evaluation. ' + expr;
	                                if (err.isUserError) {
	                                    _lib_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_3__["default"].invoke(err.trigger, err);
	                                } else {
	                                    (_a = _config__WEBPACK_IMPORTED_MODULE_4__["default"].getErrorReporter()) === null || _a === void 0 ? void 0 : _a.error(message, err);
	                                }
	                                _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_2__["default"].error(message, err);
	                                result = false;
	                            } finally {
	                                return result;
	                            }
	                        }
	                    }]);

	                    return RoxxParser;
	                }();

	                /***/
	            },
	            /* 17 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */RoxxTokenTypeRand: function RoxxTokenTypeRand() {
	                        return (/* binding */_RoxxTokenTypeRand
	                        );
	                    },
	                    /* harmony export */RoxxTokenTypeRator: function RoxxTokenTypeRator() {
	                        return (/* binding */_RoxxTokenTypeRator
	                        );
	                    },
	                    /* harmony export */RoxxTokenizer: function RoxxTokenizer() {
	                        return (/* binding */_RoxxTokenizer
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _StringTokenizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
	                /* harmony import */var _lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);

	                var operatorsList = Object.keys(_lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_0__);
	                var RoxxEscapedQuote = '\\"';
	                var RoxxEscapedQuotePlaceholder = '\\RO_Q';
	                var RoxxStringDelimiter = '"';
	                var RoxxArrayStartDelimiter = '[';
	                var RoxxArrayEndDelimiter = ']';
	                var RoxxDictStartDelimiter = '{';
	                var RoxxDictEndDelimiter = '}';
	                var RoxxTokenDelimiters = '{}[]():, \t\r\n"';
	                /**
	                 * Type identifier for ope*rator* tokens
	                 */
	                var _RoxxTokenTypeRator = 'operator';
	                /**
	                 * Type identifier for ope*rand* tokens
	                 */
	                var _RoxxTokenTypeRand = 'operand';
	                /**
	                 *
	                 */

	                var _RoxxTokenizer = function () {
	                    function _RoxxTokenizer() {
	                        _classCallCheck(this, _RoxxTokenizer);

	                        this.tokenArray = [];
	                        this.arrayAccumulator = undefined;
	                        this.dictionaryAccumulator = undefined;
	                        this.dictKey = undefined;
	                    }
	                    /**
	                     * Converts a string token into a Roxx type object.
	                     * @param {string} token - The token to convert into a Roxx type.
	                     * @returns {object}
	                     */


	                    _createClass(_RoxxTokenizer, [{
	                        key: '_stringToRoxx',
	                        value: function _stringToRoxx(token) {
	                            if (operatorsList.indexOf(token) !== -1) return { type: _RoxxTokenTypeRator, value: token };
	                            if (token == 'true') return { type: _RoxxTokenTypeRand, value: true };
	                            if (token == 'false') return { type: _RoxxTokenTypeRand, value: false };
	                            if (token == 'undefined') return { type: _RoxxTokenTypeRand, value: undefined };
	                            if (token.charAt(0) == '"' && token.charAt(token.length - 1) == '"') return { type: _RoxxTokenTypeRand, value: token.substr(1, token.length - 2) };
	                            if (!isNaN(token)) return { type: _RoxxTokenTypeRand, value: +token };
	                            // we will never write literal date, it will only come from a custom property (but if we want to, this suppose to work)
	                            // const tokenAsDate = Date.parse(token)
	                            // if (!isNaN(tokenAsDate)) return {type: RoxxTokenTypeRand, value: new Date(tokenAsDate)}
	                            return { type: 'UNKNOWN' };
	                        }
	                        /**
	                         * Pushes a token into either the arrayAccumulator or the tokenArray
	                         * according to context.
	                         * @param {*} token - the token to push
	                         */

	                    }, {
	                        key: 'push',
	                        value: function push(token) {
	                            if (this.dictionaryAccumulator && !this.dictKey) {
	                                this.dictKey = token.value;
	                            } else if (this.dictionaryAccumulator && this.dictKey) {
	                                this.dictionaryAccumulator[this.dictKey] = token.value;
	                                this.dictKey = undefined;
	                            } else if (this.arrayAccumulator) {
	                                this.arrayAccumulator.push(token.value);
	                            } else {
	                                this.tokenArray.push(token);
	                            }
	                        }
	                        /**
	                         * Produces a token array from an expression string. This array is later consumed by RoxxParser
	                         * @see RoxxParser
	                         * @param {string} expr - Roxx expression to tokenize
	                         * @returns {Array}
	                         */

	                    }, {
	                        key: 'tokenize',
	                        value: function tokenize(expr) {
	                            this.tokenArray = [];
	                            this.arrayAccumulator = undefined;
	                            this.dictionaryAccumulator = undefined;
	                            var delimitersToUse = RoxxTokenDelimiters;
	                            var expression = expr.replace(RoxxEscapedQuote, RoxxEscapedQuotePlaceholder);
	                            var tokenizer = new _StringTokenizer__WEBPACK_IMPORTED_MODULE_1__["default"](expression, delimitersToUse, true);
	                            var token = void 0,
	                                prevToken = void 0;
	                            while (tokenizer.hasMoreTokens()) {
	                                prevToken = token;
	                                token = tokenizer.nextTokenWithDelimiters(delimitersToUse);
	                                switch (token) {
	                                    case RoxxDictStartDelimiter:
	                                        this.dictionaryAccumulator = {};
	                                        break;
	                                    case RoxxDictEndDelimiter:
	                                        this.tokenArray.push({
	                                            type: _RoxxTokenTypeRand,
	                                            value: this.dictionaryAccumulator
	                                        });
	                                        this.dictionaryAccumulator = undefined;
	                                        break;
	                                    case RoxxArrayStartDelimiter:
	                                        this.arrayAccumulator = [];
	                                        break;
	                                    case RoxxArrayEndDelimiter:
	                                        this.tokenArray.push({ type: _RoxxTokenTypeRand, value: this.arrayAccumulator });
	                                        this.arrayAccumulator = undefined;
	                                        break;
	                                    case RoxxStringDelimiter:
	                                        if (prevToken == RoxxStringDelimiter) {
	                                            // if previous token was also a string delimiter it means we encounterd an emptry string.
	                                            this.push({ type: _RoxxTokenTypeRand, value: '' });
	                                        }
	                                        // Swap delimiters to use if needed. we do this so we can have strings with chars that are normally used as delimiters.
	                                        delimitersToUse = delimitersToUse == RoxxStringDelimiter ? RoxxTokenDelimiters : RoxxStringDelimiter;
	                                        break;
	                                    default:
	                                        if (delimitersToUse == RoxxStringDelimiter) {
	                                            // If get a token that's not RoxxStringDelimiter while using RoxxStringDelimiter as delimiters It's the string value!
	                                            this.push({
	                                                type: _RoxxTokenTypeRand,
	                                                value: token.replace(RoxxEscapedQuotePlaceholder, RoxxEscapedQuote)
	                                            });
	                                        } else if (RoxxTokenDelimiters.indexOf(token) == -1) {
	                                            // Is this token a delimiter or something else? if it's something else convert it to a roxx type and push.
	                                            this.push(this._stringToRoxx(token));
	                                        }
	                                        break;
	                                }
	                            }
	                            return this.tokenArray;
	                        }
	                    }]);

	                    return _RoxxTokenizer;
	                }();

	                /***/
	            },
	            /* 18 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */and: function and() {
	                        return (/* binding */_and
	                        );
	                    },
	                    /* harmony export */b64d: function b64d() {
	                        return (/* binding */_b64d
	                        );
	                    },
	                    /* harmony export */concat: function concat() {
	                        return (/* binding */_concat
	                        );
	                    },
	                    /* harmony export */eq: function eq() {
	                        return (/* binding */_eq
	                        );
	                    },
	                    /* harmony export */flagValue: function flagValue() {
	                        return (/* binding */_flagValue
	                        );
	                    },
	                    /* harmony export */gt: function gt() {
	                        return (/* binding */_gt
	                        );
	                    },
	                    /* harmony export */gte: function gte() {
	                        return (/* binding */_gte
	                        );
	                    },
	                    /* harmony export */ifThen: function ifThen() {
	                        return (/* binding */_ifThen
	                        );
	                    },
	                    /* harmony export */inArray: function inArray() {
	                        return (/* binding */_inArray
	                        );
	                    },
	                    /* harmony export */isInPercentage: function isInPercentage() {
	                        return (/* binding */_isInPercentage
	                        );
	                    },
	                    /* harmony export */isInPercentageRange: function isInPercentageRange() {
	                        return (/* binding */_isInPercentageRange
	                        );
	                    },
	                    /* harmony export */isInTargetGroup: function isInTargetGroup() {
	                        return (/* binding */_isInTargetGroup
	                        );
	                    },
	                    /* harmony export */isTargetGroupPaired: function isTargetGroupPaired() {
	                        return (/* binding */_isTargetGroupPaired
	                        );
	                    },
	                    /* harmony export */isUndefined: function isUndefined() {
	                        return (/* binding */_isUndefined
	                        );
	                    },
	                    /* harmony export */lt: function lt() {
	                        return (/* binding */_lt
	                        );
	                    },
	                    /* harmony export */lte: function lte() {
	                        return (/* binding */_lte
	                        );
	                    },
	                    /* harmony export */match: function match() {
	                        return (/* binding */_match
	                        );
	                    },
	                    /* harmony export */md5: function md5() {
	                        return (/* binding */_md
	                        );
	                    },
	                    /* harmony export */mergeSeed: function mergeSeed() {
	                        return (/* binding */_mergeSeed
	                        );
	                    },
	                    /* harmony export */ne: function ne() {
	                        return (/* binding */_ne
	                        );
	                    },
	                    /* harmony export */not: function not() {
	                        return (/* binding */_not
	                        );
	                    },
	                    /* harmony export */now: function now() {
	                        return (/* binding */_now
	                        );
	                    },
	                    /* harmony export */numeq: function numeq() {
	                        return (/* binding */_numeq
	                        );
	                    },
	                    /* harmony export */numne: function numne() {
	                        return (/* binding */_numne
	                        );
	                    },
	                    /* harmony export */operatorsWithContext: function operatorsWithContext() {
	                        return (/* binding */_operatorsWithContext
	                        );
	                    },
	                    /* harmony export */or: function or() {
	                        return (/* binding */_or
	                        );
	                    },
	                    /* harmony export */property: function property() {
	                        return (/* binding */_property
	                        );
	                    },
	                    /* harmony export */semverEq: function semverEq() {
	                        return (/* binding */_semverEq
	                        );
	                    },
	                    /* harmony export */semverGt: function semverGt() {
	                        return (/* binding */_semverGt
	                        );
	                    },
	                    /* harmony export */semverGte: function semverGte() {
	                        return (/* binding */_semverGte
	                        );
	                    },
	                    /* harmony export */semverLt: function semverLt() {
	                        return (/* binding */_semverLt
	                        );
	                    },
	                    /* harmony export */semverLte: function semverLte() {
	                        return (/* binding */_semverLte
	                        );
	                    },
	                    /* harmony export */semverNe: function semverNe() {
	                        return (/* binding */_semverNe
	                        );
	                    },
	                    /* harmony export */tsToNum: function tsToNum() {
	                        return (/* binding */_tsToNum
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _repositories_TargetGroupRepository__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(25);
	                /* harmony import */var _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
	                /* harmony import */var _repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
	                /* harmony import */var _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
	                /* harmony import */var _parsers_RoxxParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
	                /* harmony import */var md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
	                /* harmony import */var md5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_0__);
	                /* harmony import */var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
	                /* harmony import */var _DynamicProperties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27);
	                /* harmony import */var _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);

	                function _versionCompare(v1, v2) {
	                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { zeroExtend: true, lexicographical: true };

	                    var lexicographical = options && options.lexicographical;
	                    var zeroExtend = options && options.zeroExtend;
	                    var v1parts = v1.split('.');
	                    var v2parts = v2.split('.');
	                    function isValidPart(x) {
	                        return (lexicographical ? /[0-9A-Za-z_-]+$/ : /^\d+$/).test(x);
	                    }
	                    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {
	                        return NaN;
	                    }
	                    if (zeroExtend) {
	                        while (v1parts.length < v2parts.length) {
	                            v1parts.push('0');
	                        }while (v2parts.length < v1parts.length) {
	                            v2parts.push('0');
	                        }
	                    }
	                    if (!lexicographical) {
	                        v1parts = v1parts.map(Number);
	                        v2parts = v2parts.map(Number);
	                    }
	                    for (var i = 0; i < v1parts.length; ++i) {
	                        if (v2parts.length == i) {
	                            return 1;
	                        }
	                        if (v1parts[i] == v2parts[i]) {
	                            continue;
	                        } else if (v1parts[i] > v2parts[i]) {
	                            return 1;
	                        } else {
	                            return -1;
	                        }
	                    }
	                    if (v1parts.length != v2parts.length) {
	                        return -1;
	                    }
	                    return 0;
	                }
	                var getBucket = function getBucket(seed) {
	                    var hash = md5__WEBPACK_IMPORTED_MODULE_0___default()(seed, { asBytes: true });
	                    hash = (hash[0] & 0xff | (hash[1] & 0xff) << 8 | (hash[2] & 0xff) << 16 | (hash[3] & 0xff) << 24) >>> 0;
	                    var bucket = hash / (Math.pow(2, 32) - 1);
	                    return bucket;
	                };
	                var _isUndefined = function _isUndefined(op) {
	                    return op === undefined;
	                };
	                var _now = function _now() {
	                    return Date.now();
	                };
	                var _and = function _and(op1, op2) {
	                    return op1 && op2;
	                };
	                var _or = function _or(op1, op2) {
	                    return op1 || op2;
	                };
	                var _ne = function _ne(op1, op2) {
	                    return (_isUndefined(op1) ? false : op1) !== (_isUndefined(op2) ? false : op2);
	                };
	                var _eq = function _eq(op1, op2) {
	                    return (_isUndefined(op1) ? false : op1) === (_isUndefined(op2) ? false : op2);
	                };
	                var _not = function _not(op) {
	                    return !op;
	                };
	                var _ifThen = function _ifThen(conditionExpression, trueExpression, falseExpression) {
	                    return conditionExpression ? trueExpression : falseExpression;
	                };
	                var _lt = function _lt(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 < op2;
	                };
	                var _lte = function _lte(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 <= op2;
	                };
	                var _tsToNum = function _tsToNum(op1) {
	                    if (_isUndefined(op1)) return undefined;
	                    if (op1 instanceof Date) {
	                        return op1.getTime() / 1000; // epoc is in seconds, getTime in miliseconds
	                    }
	                    return undefined;
	                };
	                var _gt = function _gt(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 > op2;
	                };
	                var _numne = function _numne(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 !== op2;
	                };
	                var _numeq = function _numeq(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 === op2;
	                };
	                var _gte = function _gte(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'number') {
	                        op1 = Number(op1);
	                        if (isNaN(op1)) {
	                            return false;
	                        }
	                    }
	                    if (typeof op2 !== 'number') {
	                        op2 = Number(op2);
	                        if (isNaN(op2)) {
	                            return false;
	                        }
	                    }
	                    return op1 >= op2;
	                };
	                var _match = function _match(op1, op2, op3) {
	                    var text = op1;
	                    var regex = new RegExp(op2, op3);
	                    var match = regex.exec(text);
	                    if (match) {
	                        return true;
	                    }
	                    return false;
	                };
	                var _semverLt = function _semverLt(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2, { zeroExtend: true }) < 0;
	                };
	                var _semverLte = function _semverLte(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2, { zeroExtend: true }) <= 0;
	                };
	                var _semverGt = function _semverGt(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2, { zeroExtend: true }) > 0;
	                };
	                var _semverGte = function _semverGte(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2, { zeroExtend: true }) >= 0;
	                };
	                var _semverEq = function _semverEq(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2) == 0;
	                };
	                var _semverNe = function _semverNe(op1, op2) {
	                    if (_isUndefined(op1) || _isUndefined(op2)) return false;
	                    if (typeof op1 !== 'string' || typeof op2 !== 'string') return false;
	                    return _versionCompare(op1, op2) != 0;
	                };
	                var _mergeSeed = function _mergeSeed(seed1, seed2) {
	                    return seed1 + '.' + seed2;
	                };
	                var _isInPercentage = function _isInPercentage(percentage, seed) {
	                    var bucket = getBucket(seed);
	                    var isInPercentage = bucket <= percentage;
	                    return isInPercentage;
	                };
	                var _isInPercentageRange = function _isInPercentageRange(percentageLow, percentageHigh, seed) {
	                    var bucket = getBucket(seed);
	                    var isInPercentage = bucket >= percentageLow && bucket <= percentageHigh;
	                    return isInPercentage;
	                };
	                var _flagValue = function _flagValue(flagName) {
	                    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	                    var internalContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	                    var flag = _repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__["default"].flagWithName(flagName);
	                    if (flag) {
	                        var contextClone = Object.assign({}, internalContext);
	                        flag.getInternalValue(contextClone, context);
	                        if (!contextClone.isPeek && !contextClone.result.isOverride && !contextClone.result.isFreezed) {
	                            flag._flagImpression(contextClone.result.value, contextClone.result.usedContext);
	                        }
	                        return contextClone.result.value;
	                    }
	                    var exp = _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_3__["default"].experimentForFlagName(flagName);
	                    if (exp && exp.deploymentConfiguration) {
	                        var expressionValue = new _parsers_RoxxParser__WEBPACK_IMPORTED_MODULE_4__["default"]().evaluateExpression(exp.deploymentConfiguration.condition, internalContext, context);
	                        return expressionValue || 'false';
	                    }
	                    return 'false';
	                };
	                var _isInTargetGroup = function _isInTargetGroup(targetGroup) {
	                    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	                    var callContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	                    var tg = _repositories_TargetGroupRepository__WEBPACK_IMPORTED_MODULE_5__["default"].targetGroupWithName(targetGroup);
	                    if (tg) {
	                        return new _parsers_RoxxParser__WEBPACK_IMPORTED_MODULE_4__["default"]().evaluateExpression(tg.condition, callContext, context);
	                    } else {
	                        return false;
	                    }
	                };
	                var _isTargetGroupPaired = function _isTargetGroupPaired() {
	                    return false;
	                };
	                var _property = function _property(propName) {
	                    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	                    var prop = _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_6__["default"].get(propName);
	                    if (!prop) {
	                        var handler = _DynamicProperties__WEBPACK_IMPORTED_MODULE_7__.DynamicPropertiesHandler && (0, _DynamicProperties__WEBPACK_IMPORTED_MODULE_7__.DynamicPropertiesHandler)();
	                        var handlerResult = void 0;
	                        if (handler) {
	                            if (!handler._isUserDefined) {
	                                handlerResult = handler(propName, context);
	                            } else {
	                                try {
	                                    handlerResult = handler(propName, context);
	                                } catch (err) {
	                                    err.isUserError = true;
	                                    err.trigger = _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_8__.ExceptionTrigger.DYNAMIC_PROPERTIES_RULE;
	                                    throw err;
	                                }
	                            }
	                        }
	                        return handlerResult;
	                    } else {
	                        return prop.getValue(context);
	                    }
	                };
	                var _inArray = function _inArray(target, list) {
	                    return list ? list.indexOf(target) !== -1 : false;
	                };
	                var _md = function _md(str) {
	                    if (typeof str !== 'string') {
	                        return undefined;
	                    }
	                    return md5__WEBPACK_IMPORTED_MODULE_0___default()(str);
	                };
	                var _concat = function _concat(str1, str2) {
	                    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
	                        return undefined;
	                    }
	                    return '' + str1 + str2;
	                };
	                var _b64d = function _b64d(value) {
	                    if (typeof value !== 'string') {
	                        return undefined;
	                    }
	                    return decodeURIComponent((0, js_base64__WEBPACK_IMPORTED_MODULE_1__.decode)(value));
	                };
	                var _operatorsWithContext = [_isInTargetGroup, _flagValue, _property];

	                /***/
	            },
	            /* 19 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                (function () {
	                    var crypt = __webpack_require__(20),
	                        utf8 = __webpack_require__(21).utf8,
	                        isBuffer = __webpack_require__(22),
	                        bin = __webpack_require__(21).bin,


	                    // The core
	                    md5 = function md5(message, options) {
	                        // Convert to byte array
	                        if (message.constructor == String) {
	                            if (options && options.encoding === 'binary') message = bin.stringToBytes(message);else message = utf8.stringToBytes(message);
	                        } else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();
	                        // else, assume byte array already

	                        var m = crypt.bytesToWords(message),
	                            l = message.length * 8,
	                            a = 1732584193,
	                            b = -271733879,
	                            c = -1732584194,
	                            d = 271733878;

	                        // Swap endian
	                        for (var i = 0; i < m.length; i++) {
	                            m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;
	                        }

	                        // Padding
	                        m[l >>> 5] |= 0x80 << l % 32;
	                        m[(l + 64 >>> 9 << 4) + 14] = l;

	                        // Method shortcuts
	                        var FF = md5._ff,
	                            GG = md5._gg,
	                            HH = md5._hh,
	                            II = md5._ii;

	                        for (var i = 0; i < m.length; i += 16) {

	                            var aa = a,
	                                bb = b,
	                                cc = c,
	                                dd = d;

	                            a = FF(a, b, c, d, m[i + 0], 7, -680876936);
	                            d = FF(d, a, b, c, m[i + 1], 12, -389564586);
	                            c = FF(c, d, a, b, m[i + 2], 17, 606105819);
	                            b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
	                            a = FF(a, b, c, d, m[i + 4], 7, -176418897);
	                            d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
	                            c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
	                            b = FF(b, c, d, a, m[i + 7], 22, -45705983);
	                            a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
	                            d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
	                            c = FF(c, d, a, b, m[i + 10], 17, -42063);
	                            b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
	                            a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
	                            d = FF(d, a, b, c, m[i + 13], 12, -40341101);
	                            c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
	                            b = FF(b, c, d, a, m[i + 15], 22, 1236535329);

	                            a = GG(a, b, c, d, m[i + 1], 5, -165796510);
	                            d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
	                            c = GG(c, d, a, b, m[i + 11], 14, 643717713);
	                            b = GG(b, c, d, a, m[i + 0], 20, -373897302);
	                            a = GG(a, b, c, d, m[i + 5], 5, -701558691);
	                            d = GG(d, a, b, c, m[i + 10], 9, 38016083);
	                            c = GG(c, d, a, b, m[i + 15], 14, -660478335);
	                            b = GG(b, c, d, a, m[i + 4], 20, -405537848);
	                            a = GG(a, b, c, d, m[i + 9], 5, 568446438);
	                            d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
	                            c = GG(c, d, a, b, m[i + 3], 14, -187363961);
	                            b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
	                            a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
	                            d = GG(d, a, b, c, m[i + 2], 9, -51403784);
	                            c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
	                            b = GG(b, c, d, a, m[i + 12], 20, -1926607734);

	                            a = HH(a, b, c, d, m[i + 5], 4, -378558);
	                            d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
	                            c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
	                            b = HH(b, c, d, a, m[i + 14], 23, -35309556);
	                            a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
	                            d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
	                            c = HH(c, d, a, b, m[i + 7], 16, -155497632);
	                            b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
	                            a = HH(a, b, c, d, m[i + 13], 4, 681279174);
	                            d = HH(d, a, b, c, m[i + 0], 11, -358537222);
	                            c = HH(c, d, a, b, m[i + 3], 16, -722521979);
	                            b = HH(b, c, d, a, m[i + 6], 23, 76029189);
	                            a = HH(a, b, c, d, m[i + 9], 4, -640364487);
	                            d = HH(d, a, b, c, m[i + 12], 11, -421815835);
	                            c = HH(c, d, a, b, m[i + 15], 16, 530742520);
	                            b = HH(b, c, d, a, m[i + 2], 23, -995338651);

	                            a = II(a, b, c, d, m[i + 0], 6, -198630844);
	                            d = II(d, a, b, c, m[i + 7], 10, 1126891415);
	                            c = II(c, d, a, b, m[i + 14], 15, -1416354905);
	                            b = II(b, c, d, a, m[i + 5], 21, -57434055);
	                            a = II(a, b, c, d, m[i + 12], 6, 1700485571);
	                            d = II(d, a, b, c, m[i + 3], 10, -1894986606);
	                            c = II(c, d, a, b, m[i + 10], 15, -1051523);
	                            b = II(b, c, d, a, m[i + 1], 21, -2054922799);
	                            a = II(a, b, c, d, m[i + 8], 6, 1873313359);
	                            d = II(d, a, b, c, m[i + 15], 10, -30611744);
	                            c = II(c, d, a, b, m[i + 6], 15, -1560198380);
	                            b = II(b, c, d, a, m[i + 13], 21, 1309151649);
	                            a = II(a, b, c, d, m[i + 4], 6, -145523070);
	                            d = II(d, a, b, c, m[i + 11], 10, -1120210379);
	                            c = II(c, d, a, b, m[i + 2], 15, 718787259);
	                            b = II(b, c, d, a, m[i + 9], 21, -343485551);

	                            a = a + aa >>> 0;
	                            b = b + bb >>> 0;
	                            c = c + cc >>> 0;
	                            d = d + dd >>> 0;
	                        }

	                        return crypt.endian([a, b, c, d]);
	                    };

	                    // Auxiliary functions
	                    md5._ff = function (a, b, c, d, x, s, t) {
	                        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	                        return (n << s | n >>> 32 - s) + b;
	                    };
	                    md5._gg = function (a, b, c, d, x, s, t) {
	                        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	                        return (n << s | n >>> 32 - s) + b;
	                    };
	                    md5._hh = function (a, b, c, d, x, s, t) {
	                        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	                        return (n << s | n >>> 32 - s) + b;
	                    };
	                    md5._ii = function (a, b, c, d, x, s, t) {
	                        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	                        return (n << s | n >>> 32 - s) + b;
	                    };

	                    // Package private blocksize
	                    md5._blocksize = 16;
	                    md5._digestsize = 16;

	                    module.exports = function (message, options) {
	                        if (message === undefined || message === null) throw new Error('Illegal argument ' + message);

	                        var digestbytes = crypt.wordsToBytes(md5(message, options));
	                        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
	                    };
	                })();

	                /***/
	            },
	            /* 20 */
	            /***/function (module) {

	                (function () {
	                    var base64map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
	                        crypt = {
	                        // Bit-wise rotation left
	                        rotl: function rotl(n, b) {
	                            return n << b | n >>> 32 - b;
	                        },

	                        // Bit-wise rotation right
	                        rotr: function rotr(n, b) {
	                            return n << 32 - b | n >>> b;
	                        },

	                        // Swap big-endian to little-endian and vice versa
	                        endian: function endian(n) {
	                            // If number given, swap endian
	                            if (n.constructor == Number) {
	                                return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	                            }

	                            // Else, assume array and swap all items
	                            for (var i = 0; i < n.length; i++) {
	                                n[i] = crypt.endian(n[i]);
	                            }return n;
	                        },

	                        // Generate an array of any length of random bytes
	                        randomBytes: function randomBytes(n) {
	                            for (var bytes = []; n > 0; n--) {
	                                bytes.push(Math.floor(Math.random() * 256));
	                            }return bytes;
	                        },

	                        // Convert a byte array to big-endian 32-bit words
	                        bytesToWords: function bytesToWords(bytes) {
	                            for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) {
	                                words[b >>> 5] |= bytes[i] << 24 - b % 32;
	                            }return words;
	                        },

	                        // Convert big-endian 32-bit words to a byte array
	                        wordsToBytes: function wordsToBytes(words) {
	                            for (var bytes = [], b = 0; b < words.length * 32; b += 8) {
	                                bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
	                            }return bytes;
	                        },

	                        // Convert a byte array to a hex string
	                        bytesToHex: function bytesToHex(bytes) {
	                            for (var hex = [], i = 0; i < bytes.length; i++) {
	                                hex.push((bytes[i] >>> 4).toString(16));
	                                hex.push((bytes[i] & 0xF).toString(16));
	                            }
	                            return hex.join('');
	                        },

	                        // Convert a hex string to a byte array
	                        hexToBytes: function hexToBytes(hex) {
	                            for (var bytes = [], c = 0; c < hex.length; c += 2) {
	                                bytes.push(parseInt(hex.substr(c, 2), 16));
	                            }return bytes;
	                        },

	                        // Convert a byte array to a base-64 string
	                        bytesToBase64: function bytesToBase64(bytes) {
	                            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	                                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
	                                for (var j = 0; j < 4; j++) {
	                                    if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));else base64.push('=');
	                                }
	                            }
	                            return base64.join('');
	                        },

	                        // Convert a base-64 string to a byte array
	                        base64ToBytes: function base64ToBytes(base64) {
	                            // Remove non-base-64 characters
	                            base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	                            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
	                                if (imod4 == 0) continue;
	                                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
	                            }
	                            return bytes;
	                        }
	                    };

	                    module.exports = crypt;
	                })();

	                /***/
	            },
	            /* 21 */
	            /***/function (module) {

	                var charenc = {
	                    // UTF-8 encoding
	                    utf8: {
	                        // Convert a string to a byte array
	                        stringToBytes: function stringToBytes(str) {
	                            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	                        },

	                        // Convert a byte array to a string
	                        bytesToString: function bytesToString(bytes) {
	                            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	                        }
	                    },

	                    // Binary encoding
	                    bin: {
	                        // Convert a string to a byte array
	                        stringToBytes: function stringToBytes(str) {
	                            for (var bytes = [], i = 0; i < str.length; i++) {
	                                bytes.push(str.charCodeAt(i) & 0xFF);
	                            }return bytes;
	                        },

	                        // Convert a byte array to a string
	                        bytesToString: function bytesToString(bytes) {
	                            for (var str = [], i = 0; i < bytes.length; i++) {
	                                str.push(String.fromCharCode(bytes[i]));
	                            }return str.join('');
	                        }
	                    }
	                };

	                module.exports = charenc;

	                /***/
	            },
	            /* 22 */
	            /***/function (module) {

	                /*!
	                 * Determine if an object is a Buffer
	                 *
	                 * @author   Feross Aboukhadijeh <https://feross.org>
	                 * @license  MIT
	                 */

	                // The _isBuffer check is for Safari 5-7 support, because it's missing
	                // Object.prototype.constructor. Remove this eventually
	                module.exports = function (obj) {
	                    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
	                };

	                function isBuffer(obj) {
	                    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
	                }

	                // For Node v0.10 support. Remove this eventually.
	                function isSlowBuffer(obj) {
	                    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
	                }

	                /***/
	            },
	            /* 23 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */RoxFlagRepository: function RoxFlagRepository() {
	                        return (/* binding */_RoxFlagRepository
	                        );
	                    },
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _setters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
	                /* harmony import */var _ExperimentsRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);

	                var _RoxFlagRepository = function () {
	                    function _RoxFlagRepository() {
	                        _classCallCheck(this, _RoxFlagRepository);

	                        this.map = {};
	                    }

	                    _createClass(_RoxFlagRepository, [{
	                        key: 'addFlag',
	                        value: function addFlag(name, flag) {
	                            flag.name = name;
	                            this.map[name] = flag;
	                            new _setters__WEBPACK_IMPORTED_MODULE_0__["default"](this, _ExperimentsRepository__WEBPACK_IMPORTED_MODULE_1__["default"]).setAddedFlag(flag);
	                        }
	                    }, {
	                        key: 'flagWithName',
	                        value: function flagWithName(name) {
	                            return this.map[name];
	                        }
	                    }, {
	                        key: 'flags',
	                        get: function get() {
	                            var _this5 = this;

	                            return Object.keys(this.map).map(function (t) {
	                                return _this5.map[t];
	                            });
	                        }
	                    }, {
	                        key: 'items',
	                        get: function get() {
	                            return this.flags;
	                        }
	                    }]);

	                    return _RoxFlagRepository;
	                }();
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = new _RoxFlagRepository();

	                /***/
	            },
	            /* 24 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */FlagsSetter
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);

	                var FlagsSetter = function () {
	                    function FlagsSetter(flagRepo, experimentsRepo) {
	                        _classCallCheck(this, FlagsSetter);

	                        this.flagRepo = flagRepo;
	                        this.experimentsRepo = experimentsRepo;
	                    }

	                    _createClass(FlagsSetter, [{
	                        key: 'prepareFlagsWithExperiments',
	                        value: function prepareFlagsWithExperiments() {
	                            var _this6 = this;

	                            var experiments = this.experimentsRepo.experiments || [];
	                            _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].debug('Set experiments ' + JSON.stringify(experiments));
	                            var flagsWithCondition = [];
	                            experiments.forEach(function (experiment) {
	                                if (!experiment) {
	                                    return;
	                                }
	                                experiment.flags.forEach(function (flag) {
	                                    if (!flag) {
	                                        return;
	                                    }
	                                    var flagObject = _this6.flagRepo.flagWithName(flag.name);
	                                    if (flagObject) {
	                                        flagsWithCondition.push(flagObject);
	                                        _this6.connectExperimentToFlag(flagObject, experiment.deploymentConfiguration.condition);
	                                    }
	                                });
	                            });
	                            this.flagRepo.flags.forEach(function (flagToSet) {
	                                if (!flagsWithCondition.some(function (f) {
	                                    return f === flagToSet;
	                                })) {
	                                    _this6.connectExperimentToFlag(flagToSet, undefined);
	                                }
	                            });
	                        }
	                    }, {
	                        key: 'setAddedFlag',
	                        value: function setAddedFlag(addedFlag) {
	                            var experiment = this.experimentsRepo.experimentForFlag(addedFlag);
	                            if (experiment) {
	                                this.connectExperimentToFlag(addedFlag, experiment.deploymentConfiguration.condition);
	                            }
	                        }
	                    }, {
	                        key: 'connectExperimentToFlag',
	                        value: function connectExperimentToFlag(flag, condition) {
	                            flag.condition = condition;
	                        }
	                    }]);

	                    return FlagsSetter;
	                }();

	                /***/
	            },
	            /* 25 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });

	                var TargetGroupRepository = function () {
	                    function TargetGroupRepository() {
	                        _classCallCheck(this, TargetGroupRepository);

	                        this.map = {};
	                    }

	                    _createClass(TargetGroupRepository, [{
	                        key: 'addTargetGroup',
	                        value: function addTargetGroup(targetGroup) {
	                            this.map[targetGroup.identifier] = targetGroup;
	                        }
	                    }, {
	                        key: 'setTargetGroups',
	                        value: function setTargetGroups(targetGroups) {
	                            this.map = {};
	                            targetGroups = targetGroups || [];
	                            targetGroups.forEach(function (element) {
	                                this.map[element.identifier] = element;
	                            }, this);
	                        }
	                    }, {
	                        key: 'targetGroupWithName',
	                        value: function targetGroupWithName(name) {
	                            return this.map[name];
	                        }
	                    }, {
	                        key: 'targetGroups',
	                        get: function get() {
	                            var _this7 = this;

	                            return Object.keys(this.map).map(function (t) {
	                                return _this7.map[t];
	                            });
	                        }
	                    }]);

	                    return TargetGroupRepository;
	                }();

	                var instance = new TargetGroupRepository();
	                /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = instance;

	                /***/
	            },
	            /* 26 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });

	                var CustomPropertyRepository = function () {
	                    function CustomPropertyRepository() {
	                        _classCallCheck(this, CustomPropertyRepository);

	                        this.store = new Map();
	                    }

	                    _createClass(CustomPropertyRepository, [{
	                        key: 'has',
	                        value: function has(property) {
	                            return this.store.has(property.name);
	                        }
	                    }, {
	                        key: 'get',
	                        value: function get(name) {
	                            return this.store.get(name);
	                        }
	                    }, {
	                        key: 'set',
	                        value: function set(property) {
	                            this.store.set(property.name, property);
	                        }
	                    }, {
	                        key: 'setIfNotExists',
	                        value: function setIfNotExists(property) {
	                            if (this.has(property)) {
	                                return;
	                            }
	                            this.set(property);
	                        }
	                    }, {
	                        key: 'clear',
	                        value: function clear() {
	                            this.store.clear();
	                        }
	                    }, {
	                        key: 'items',
	                        get: function get() {
	                            return Array.from(this.store.values());
	                        }
	                    }]);

	                    return CustomPropertyRepository;
	                }();
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = new CustomPropertyRepository();

	                /***/
	            },
	            /* 27 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */DynamicPropertiesHandler: function DynamicPropertiesHandler() {
	                        return (/* binding */_DynamicPropertiesHandler
	                        );
	                    },
	                    /* harmony export */defaultDynamicPropertyHandler: function defaultDynamicPropertyHandler() {
	                        return (/* binding */_defaultDynamicPropertyHandler
	                        );
	                    },
	                    /* harmony export */setDynamicPropertyHandler: function setDynamicPropertyHandler() {
	                        return (/* binding */_setDynamicPropertyHandler
	                        );
	                    }
	                    /* harmony export */ });
	                var _defaultHandler = function _defaultHandler(propName, context) {
	                    return context ? context[propName] : undefined;
	                };
	                var _handler = _defaultHandler;
	                function _defaultDynamicPropertyHandler() {
	                    return _defaultHandler;
	                }
	                function _setDynamicPropertyHandler(handler) {
	                    _handler = handler;
	                    if (handler) {
	                        _handler._isUserDefined = true;
	                    }
	                }
	                function _DynamicPropertiesHandler() {
	                    return _handler;
	                }

	                /***/
	            },
	            /* 28 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */StringTokenizer
	                        );
	                    }
	                    /* harmony export */ });

	                var StringTokenizer = function () {
	                    function StringTokenizer(string, delimiters, returnDelim) {
	                        _classCallCheck(this, StringTokenizer);

	                        this._string = string;
	                        this._delimiters = delimiters;
	                        this._returnDelim = returnDelim;
	                        this._position = 0;
	                    }

	                    _createClass(StringTokenizer, [{
	                        key: 'countTokens',
	                        value: function countTokens() {
	                            var count = 0;
	                            var inToken = false;
	                            for (var i = this._position, length = this._string.length; i < length; i++) {
	                                if (this._delimiters.indexOf(this._string.charAt(i)) != -1) {
	                                    if (this._returnDelim) count++;
	                                    if (inToken) {
	                                        count++;
	                                        inToken = false;
	                                    }
	                                } else {
	                                    inToken = true;
	                                }
	                            }
	                            if (inToken) count++;
	                            return count;
	                        }
	                    }, {
	                        key: 'hasMoreElements',
	                        value: function hasMoreElements() {
	                            return this.hasMoreTokens();
	                        }
	                    }, {
	                        key: 'hasMoreTokens',
	                        value: function hasMoreTokens() {
	                            if (!this._delimiters) {
	                                return false;
	                            }
	                            var length = this._string.length;
	                            if (this._position < length) {
	                                if (this._returnDelim) return true;
	                                for (var i = this._position; i < length; i++) {
	                                    if (this._delimiters.indexOf(this._string.charAt(i)) == -1) {
	                                        return true;
	                                    }
	                                }
	                            }
	                            return false;
	                        }
	                    }, {
	                        key: 'nextElement',
	                        value: function nextElement() {
	                            return this.nextToken();
	                        }
	                    }, {
	                        key: 'nextToken',
	                        value: function nextToken() {
	                            if (!this._delimiters) {
	                                return undefined;
	                            }
	                            var i = this._position;
	                            var length = this._string.length;
	                            if (i < length) {
	                                if (this._returnDelim) {
	                                    if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.charAt(this._position++);
	                                    for (this._position++; this._position < length; this._position++) {
	                                        if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.substr(i, this._position - i);
	                                    }return this._string.substr(i);
	                                }
	                                while (i < length && this._delimiters.indexOf(this._string.charAt(this._position)) != -1) {
	                                    i++;
	                                }this._position = i;
	                                if (i < length) {
	                                    for (this._position++; this._position < length; this._position++) {
	                                        if (this._delimiters.indexOf(this._string.charAt(this._position)) != -1) return this._string.substr(i, this._position - i);
	                                    }return this._string.substr(i);
	                                }
	                            }
	                            return undefined;
	                        }
	                    }, {
	                        key: 'nextTokenWithDelimiters',
	                        value: function nextTokenWithDelimiters(delimiters) {
	                            this._delimiters = delimiters;
	                            return this.nextToken();
	                        }
	                    }]);

	                    return StringTokenizer;
	                }();

	                /***/
	            },
	            /* 29 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */ConfigurationParser: function ConfigurationParser() {
	                        return (/* reexport safe */_ConfigurationParser__WEBPACK_IMPORTED_MODULE_1__["default"]
	                        );
	                    },
	                    /* harmony export */RoxxParser: function RoxxParser() {
	                        return (/* reexport safe */_RoxxParser__WEBPACK_IMPORTED_MODULE_0__["default"]
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxxParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
	                /* harmony import */var _ConfigurationParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);

	                /***/
	            },
	            /* 30 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */ConfigurationParser
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _ExperimentsParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
	                /* harmony import */var _TargetGroupsParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);

	                var terms = {
	                    DATA_CONTAINER: 'data',
	                    APP_KEY: 'application',
	                    EXPERIMENTS: 'experiments',
	                    TARGET_GROUPS: 'targetGroups',
	                    SIGNED_DATE: 'signed_date'
	                };

	                var ConfigurationParser = function () {
	                    function ConfigurationParser(json, appKey) {
	                        var validateAppKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	                        _classCallCheck(this, ConfigurationParser);

	                        if (!json || (typeof json === 'undefined' ? 'undefined' : _typeof(json)) !== 'object') {
	                            throw new Error('ConfigurationParser should be constructed with JSON object. Received ' + json);
	                        }
	                        if (!appKey || typeof appKey !== 'string') {
	                            throw new Error('ConfigurationParser should be constructed with app key string. Received ' + appKey);
	                        }
	                        this._json = json;
	                        this._appKey = appKey;
	                        this._validateAppKey = validateAppKey;
	                    }

	                    _createClass(ConfigurationParser, [{
	                        key: 'parse',
	                        value: function parse() {
	                            var data = this._extractInnerJson(this._json);
	                            if (this._validateAppKey && data[terms.APP_KEY] !== this._appKey) {
	                                return null;
	                            }
	                            this._parseExperiments(data[terms.EXPERIMENTS]);
	                            this._parseTargetGroups(data[terms.TARGET_GROUPS]);
	                            this._signedDate = new Date(this._json[terms.SIGNED_DATE]);
	                            return this;
	                        }
	                    }, {
	                        key: 'experiments',
	                        value: function experiments() {
	                            return this._experiments || [];
	                        }
	                    }, {
	                        key: 'targetGroups',
	                        value: function targetGroups() {
	                            return this._targetGroups || [];
	                        }
	                    }, {
	                        key: 'signedDate',
	                        value: function signedDate() {
	                            return this._signedDate;
	                        }
	                    }, {
	                        key: '_extractInnerJson',
	                        value: function _extractInnerJson(json) {
	                            return JSON.parse(json[terms.DATA_CONTAINER]);
	                        }
	                    }, {
	                        key: '_parseExperiments',
	                        value: function _parseExperiments(experiments) {
	                            this._experiments = new _ExperimentsParser__WEBPACK_IMPORTED_MODULE_0__["default"](experiments).parse();
	                        }
	                    }, {
	                        key: '_parseTargetGroups',
	                        value: function _parseTargetGroups(targetGroups) {
	                            this._targetGroups = new _TargetGroupsParser__WEBPACK_IMPORTED_MODULE_1__["default"](targetGroups).parse();
	                        }
	                    }]);

	                    return ConfigurationParser;
	                }();

	                /***/
	            },
	            /* 31 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */ExperimentsParser
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
	                /* harmony import */var _entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);

	                var terms = {
	                    DEPLOYMENT_CONFIGURATION: 'deploymentConfiguration',
	                    DEPLOYMENT_CONDITION: 'condition',
	                    EXPERIMENT_ARCHIVED: 'archived',
	                    EXPERIMENT_STICKY: 'sticky',
	                    EXPERIMENT_ID: '_id',
	                    EXPERIMENT_NAME: 'name',
	                    EXPERIMENT_FLAGS: 'featureFlags',
	                    EXPERIMENT_LABELS: 'labels',
	                    EXPERIMENT_STICKINESS_PROPERTY: 'stickinessProperty'
	                };

	                var ExperimentsParser = function () {
	                    function ExperimentsParser(json) {
	                        _classCallCheck(this, ExperimentsParser);

	                        this._json = json;
	                    }

	                    _createClass(ExperimentsParser, [{
	                        key: 'parse',
	                        value: function parse() {
	                            if (!this._json || !this._json.length) {
	                                return [];
	                            }
	                            var experiments = [];
	                            this._json.forEach(function (experimentJson) {
	                                if (!experimentJson || !experimentJson[terms.DEPLOYMENT_CONFIGURATION] || !experimentJson[terms.EXPERIMENT_ID] || !experimentJson[terms.EXPERIMENT_NAME] || !experimentJson[terms.EXPERIMENT_FLAGS]) {
	                                    return;
	                                }
	                                var deploymentConfigurationJson = experimentJson[terms.DEPLOYMENT_CONFIGURATION];
	                                if (!deploymentConfigurationJson[terms.DEPLOYMENT_CONDITION]) {
	                                    return;
	                                }
	                                var labels = experimentJson[terms.EXPERIMENT_LABELS] || [];
	                                var deploymentConfiguration = new _entities__WEBPACK_IMPORTED_MODULE_0__["default"](deploymentConfigurationJson[terms.DEPLOYMENT_CONDITION]);
	                                experiments.push(new _entities__WEBPACK_IMPORTED_MODULE_1__["default"](experimentJson[terms.EXPERIMENT_ID], experimentJson[terms.EXPERIMENT_NAME], !!experimentJson[terms.EXPERIMENT_ARCHIVED], !!experimentJson[terms.EXPERIMENT_STICKY], deploymentConfiguration, experimentJson[terms.EXPERIMENT_FLAGS], labels, experimentJson[terms.EXPERIMENT_STICKINESS_PROPERTY]));
	                            });
	                            return experiments;
	                        }
	                    }]);

	                    return ExperimentsParser;
	                }();

	                /***/
	            },
	            /* 32 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */TargetGroupsParser
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _entities_TargetGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

	                var terms = {
	                    TARGET_GROUP_ID: '_id',
	                    TARGET_GROUP_CONDITION: 'condition'
	                };

	                var TargetGroupsParser = function () {
	                    function TargetGroupsParser(json) {
	                        _classCallCheck(this, TargetGroupsParser);

	                        this._json = json;
	                    }

	                    _createClass(TargetGroupsParser, [{
	                        key: 'parse',
	                        value: function parse() {
	                            if (!this._json || !this._json.length) {
	                                return [];
	                            }
	                            var targetGroups = [];
	                            this._json.forEach(function (json) {
	                                if (!json || !json[terms.TARGET_GROUP_ID] || !json[terms.TARGET_GROUP_CONDITION]) {
	                                    return;
	                                }
	                                targetGroups.push(new _entities_TargetGroup__WEBPACK_IMPORTED_MODULE_0__["default"](json[terms.TARGET_GROUP_ID], json[terms.TARGET_GROUP_CONDITION]));
	                            });
	                            return targetGroups;
	                        }
	                    }]);

	                    return TargetGroupsParser;
	                }();

	                /***/
	            },
	            /* 33 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */FlagsSetter: function FlagsSetter() {
	                        return (/* reexport safe */_FlagsSetter__WEBPACK_IMPORTED_MODULE_0__["default"]
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _FlagsSetter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);

	                /***/
	            },
	            /* 34 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */CustomProperties: function CustomProperties() {
	                        return (/* reexport safe */_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_0__["default"]
	                        );
	                    },
	                    /* harmony export */Experiments: function Experiments() {
	                        return (/* reexport safe */_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_1__["default"]
	                        );
	                    },
	                    /* harmony export */Flags: function Flags() {
	                        return (/* reexport safe */_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__["default"]
	                        );
	                    },
	                    /* harmony export */TargetGroups: function TargetGroups() {
	                        return (/* reexport safe */_TargetGroupRepository__WEBPACK_IMPORTED_MODULE_3__["default"]
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
	                /* harmony import */var _ExperimentsRepository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
	                /* harmony import */var _RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
	                /* harmony import */var _TargetGroupRepository__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);

	                /***/
	            },
	            /* 35 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */Actions: function Actions() {
	                        return (/* reexport module object */_Actions__WEBPACK_IMPORTED_MODULE_0__
	                        );
	                    },
	                    /* harmony export */Manager: function Manager() {
	                        return (/* reexport module object */_Manager__WEBPACK_IMPORTED_MODULE_1__
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _Actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
	                /* harmony import */var _Manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);

	                /***/
	            },
	            /* 36 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */getMergedContext: function getMergedContext() {
	                        return (/* binding */_getMergedContext
	                        );
	                    },
	                    /* harmony export */getMergedContextWithGlobal: function getMergedContextWithGlobal() {
	                        return (/* binding */_getMergedContextWithGlobal
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _Manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);

	                function _getMergedContext(context, contextToBeMerged) {
	                    if (!context) {
	                        return Object.assign({}, contextToBeMerged);
	                    }
	                    return Object.assign({}, context, contextToBeMerged);
	                }
	                function _getMergedContextWithGlobal(contextToBeMerged) {
	                    var globalContext = _Manager__WEBPACK_IMPORTED_MODULE_0__.getContext();
	                    if (!contextToBeMerged) {
	                        return Object.assign({}, globalContext);
	                    }
	                    return Object.assign({}, globalContext, contextToBeMerged);
	                }

	                /***/
	            },
	            /* 37 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */getContext: function getContext() {
	                        return (/* binding */_getContext
	                        );
	                    },
	                    /* harmony export */setContext: function setContext() {
	                        return (/* binding */_setContext
	                        );
	                    }
	                    /* harmony export */ });
	                var _context = {};
	                function _getContext() {
	                    return _context;
	                }
	                function _setContext(context) {
	                    _context = context;
	                }

	                /***/
	            },
	            /* 38 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */DeviceProperties
	                        );
	                    }
	                    /* harmony export */ });

	                var DeviceProperties = function () {
	                    function DeviceProperties(cache, uuid) {
	                        _classCallCheck(this, DeviceProperties);

	                        this.cache = cache;
	                        this._uuid = uuid;
	                        this.distinct_id = this.generateDistinctId();
	                        this.app_release = '0.0';
	                        this.distinctIdSetExplicitly = false;
	                    }

	                    _createClass(DeviceProperties, [{
	                        key: 'setPlatform',
	                        value: function setPlatform(platform) {
	                            this.platform = platform;
	                        }
	                    }, {
	                        key: 'setRealPlatform',
	                        value: function setRealPlatform(realPlatform) {
	                            this.realPlatform = realPlatform;
	                        }
	                    }, {
	                        key: 'setDistinctId',
	                        value: function setDistinctId(id) {
	                            this.distinctIdSetExplicitly = true;
	                            this.distinct_id = id;
	                        }
	                    }, {
	                        key: 'setAppRelease',
	                        value: function setAppRelease(appRelease) {
	                            this.app_release = appRelease;
	                        }
	                    }, {
	                        key: 'uuid',
	                        value: function uuid() {
	                            return this._uuid();
	                        }
	                    }, {
	                        key: 'generateDistinctId',
	                        value: function generateDistinctId() {
	                            var distinct_id = this.cache.get('distinctId');
	                            if (!distinct_id) {
	                                distinct_id = this.uuid();
	                                this.cache.set('distinctId', distinct_id);
	                            }
	                            return distinct_id;
	                        }
	                    }]);

	                    return DeviceProperties;
	                }();

	                /***/
	            },
	            /* 39 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */Client: function Client() {
	                        return (/* binding */_Client
	                        );
	                    },
	                    /* harmony export */createRoxClient: function createRoxClient() {
	                        return (/* binding */_createRoxClient
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _BugsnagReporter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
	                /* harmony import */var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);
	                /* harmony import */var ___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(56);
	                /* harmony import */var ___WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(23);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(25);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(14);
	                /* harmony import */var _DynamicApi__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(72);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
	                /* harmony import */var _entities__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(5);
	                /* harmony import */var _parsers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(16);
	                /* harmony import */var _ImpressionHandler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13);
	                /* harmony import */var _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(6);
	                /* harmony import */var _Analytics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(67);
	                /* harmony import */var _notifications_notification_listener__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(71);
	                /* harmony import */var _InternalFlags__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(15);
	                /* harmony import */var _DynamicProperties__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(27);
	                /* harmony import */var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
	                /* harmony import */var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
	                /* harmony import */var _FetcherResults__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(57);
	                /* harmony import */var _StateSender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
	                /* harmony import */var _NetworkSender__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68);
	                /* harmony import */var _AxiosWrapper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(69);

	                var MINIMUM_INTERVAL_SEC = 30;
	                var DISABLED_INTERVAL_THRESOLD = 0;
	                var SEND_STATE_DEBOUNCE_TIMEOUT_MS = 5000;
	                var _deps = {
	                    ClassRegister: ___WEBPACK_IMPORTED_MODULE_1__["default"]
	                };

	                var _Client = function () {
	                    function _Client() {
	                        var _this8 = this;

	                        var sendStateDebounceTimeoutMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SEND_STATE_DEBOUNCE_TIMEOUT_MS;

	                        _classCallCheck(this, _Client);

	                        this.classRegisterer = new _deps.ClassRegister();
	                        this.sendStateDebounceNoCheck = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function () {
	                            _this8._sendState();
	                        }, sendStateDebounceTimeoutMs, {
	                            maxWait: sendStateDebounceTimeoutMs,
	                            leading: false,
	                            trailing: true
	                        });
	                        this.sendStateDebounced = function () {
	                            if (_this8.appKey) {
	                                _this8.sendStateDebounceNoCheck();
	                            }
	                        };
	                        this.onConfigurationFetched = this.onConfigurationFetched.bind(this);
	                    }

	                    _createClass(_Client, [{
	                        key: 'setKey',
	                        value: function setKey(apiKey, options) {
	                            var mongoRegex = /^[a-f\d]{24}$/i;
	                            var uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
	                            var isRolloutValidKey = mongoRegex.test(apiKey);
	                            var isPlatformValidKey = uuidRegex.test(apiKey);
	                            if (!isRolloutValidKey && !isPlatformValidKey) {
	                                throw Error('invalid rollout apikey');
	                            } else {
	                                this.app_key = apiKey;
	                                if (isPlatformValidKey) {
	                                    _config__WEBPACK_IMPORTED_MODULE_2__["default"].setHosting('platform');
	                                    options.disableSignatureVerification = true;
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'setup',
	                        value: function setup(options) {
	                            var _a;
	                            try {
	                                // Bootstrap Options
	                                this.handleOptions(options);
	                                // Bootstrap Device Properties
	                                _deps.DeviceProperties = _deps.DeviceProperties.create ? _deps.DeviceProperties.create(_deps) : _deps.DeviceProperties;
	                                this.app_release && _deps.DeviceProperties.setAppRelease(this.app_release);
	                                this.distinct_id && _deps.DeviceProperties.setDistinctId(this.distinct_id);
	                                this.platform && _deps.DeviceProperties.setPlatform(this.platform);
	                                this.deviceProperties = _deps.DeviceProperties;
	                                this.deviceProperties.setRealPlatform(this.realPlatform);
	                                // Bootstrap Error Reporter
	                                this.selfManagedMode && _config__WEBPACK_IMPORTED_MODULE_2__["default"].setErrorReporter(new _BugsnagReporter__WEBPACK_IMPORTED_MODULE_3__.BugsnagReporter(this.appKey, _deps.DeviceProperties, this.networkOptions, this.networkApi));
	                                // Bootstap Configuration Fetcher
	                                this.configurationFetcher = new ___WEBPACK_IMPORTED_MODULE_4__["default"](this.appKey, this.deviceProperties, this.devModeSecret, _deps, this.embeddedConfiguration, {
	                                    roxyUrl: this.roxyUrl,
	                                    selfManagedMode: this.selfManagedMode,
	                                    disableSignatureVerification: this.disableSignatureVerification
	                                }, this.networkOptions, this.networkApi);
	                                if (!this.roxyUrl) {
	                                    this.stateSender = new _StateSender__WEBPACK_IMPORTED_MODULE_5__["default"](this.appKey, this.deviceProperties, this.devModeSecret, this.networkOptions, { selfManagedMode: this.selfManagedMode }, this.disableSignatureVerification, this.networkApi);
	                                    if (!this.disableNetwork) {
	                                        (0, _ImpressionHandler__WEBPACK_IMPORTED_MODULE_6__.setAnalytics)(new _Analytics__WEBPACK_IMPORTED_MODULE_7__["default"](this.appKey, Object.assign({}, this.analyticsOptions), _deps.DeviceProperties, this.networkOptions, this.networkApi));
	                                    }
	                                }
	                                // Bootstrap Custom Properties
	                                _deps.getDefaultCustomProperties(this.deviceProperties, this.appKey).map(_repositories__WEBPACK_IMPORTED_MODULE_8__["default"].setIfNotExists.bind(_repositories__WEBPACK_IMPORTED_MODULE_8__["default"]));
	                            } catch (e) {
	                                var message = 'Uh oh! An error occurred during setup.';
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].error(message, e);
	                                (_a = _config__WEBPACK_IMPORTED_MODULE_2__["default"].getErrorReporter()) === null || _a === void 0 ? void 0 : _a.error(message, e);
	                            }
	                            return Promise.resolve(this);
	                        }
	                    }, {
	                        key: 'handleOptions',
	                        value: function handleOptions(options) {
	                            var realPlatform = _deps.DefaultSetupOptions.platform;
	                            var _options = Object.assign({}, _deps.DefaultSetupOptions, options);
	                            if (_options.selfManaged && _typeof(_options.selfManaged) === 'object') {
	                                if (!_options.selfManaged.analyticsURL) {
	                                    throw new Error('analyticsURL is required on self managed mode');
	                                } else if (!_options.selfManaged.serverURL) {
	                                    throw new Error('serverURL is required on self managed mode');
	                                }
	                                if (options.selfManaged.configurationURL) {
	                                    _options.selfManaged.configurationURL = options.selfManaged.configurationURL.endsWith('/') ? options.selfManaged.configurationURL : options.selfManaged.configurationURL + '/';
	                                }
	                                if (options.selfManaged.stateURL) {
	                                    _options.selfManaged.stateURL = options.selfManaged.stateURL.endsWith('/') ? options.selfManaged.stateURL : options.selfManaged.stateURL + '/';
	                                }
	                                _config__WEBPACK_IMPORTED_MODULE_2__["default"].setSelfManagedMode(_options.selfManaged);
	                                (0, _InternalFlags__WEBPACK_IMPORTED_MODULE_10__.setDefaultsMode)(true);
	                                this.selfManagedMode = true;
	                            }
	                            if (_options.configuration && _options.configuration.disableNetwork) {
	                                this.disableNetwork = true;
	                            }
	                            this.embeddedConfiguration = _options.embedded;
	                            this.fetchIntervalInSec = _options.fetchIntervalInSec;
	                            this.disablePushUpdateListener = this.disableNetwork || this.selfManagedMode && !_options.selfManaged.pushUpdateURL ? true : _options.disablePushUpdateListener;
	                            this.configurationFetchedHandler = _options.configurationFetchedHandler;
	                            this.impressionHandler = _options.impressionHandler;
	                            this.dynamicPropertyRuleHandler = _options.dynamicPropertyRuleHandler;
	                            this.app_release = _options.version;
	                            this.distinct_id = _options.distinctId;
	                            this.devModeSecret = _options.devModeSecret;
	                            this.platform = _options.platform;
	                            this.fetchFunction = _options.fetchFunction;
	                            this.networkApi = _options.networkApi;
	                            if (this.networkApi) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('network: using custom');
	                            } else {
	                                if (this.fetchFunction) {
	                                    ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('network: using fetch');
	                                    this.networkApi = new _NetworkSender__WEBPACK_IMPORTED_MODULE_11__.FetchNetwork(this.fetchFunction);
	                                } else {
	                                    ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('network: using axios');
	                                    this.networkApi = new _AxiosWrapper__WEBPACK_IMPORTED_MODULE_12__.AxiosNetwork();
	                                }
	                            }
	                            this.realPlatform = realPlatform;
	                            this.roxyUrl = _options.roxy;
	                            this.networkOptions = {
	                                httpAgent: _options.httpAgent,
	                                httpsAgent: _options.httpsAgent
	                            };
	                            this.disableSignatureVerification = _options.disableSignatureVerification || false;
	                            this.analyticsOptions = _options.analytics;
	                            this.eventSourceImpl = _options.eventSourceImpl;
	                            (0, _ImpressionHandler__WEBPACK_IMPORTED_MODULE_6__.setHandler)(this.impressionHandler);
	                            if (options.logger) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].setLogger(options.logger);
	                            }
	                            if (this.dynamicPropertyRuleHandler) {
	                                (0, _DynamicProperties__WEBPACK_IMPORTED_MODULE_13__.setDynamicPropertyHandler)(this.dynamicPropertyRuleHandler);
	                            }
	                        }
	                    }, {
	                        key: 'fetchPeriodically',
	                        value: function fetchPeriodically() {
	                            if (!this.app_key) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].warn('no app key');
	                                return Promise.reject();
	                            }
	                            if (this.fetchIntervalInSec <= DISABLED_INTERVAL_THRESOLD) return Promise.resolve();
	                            if (this.fetchIntervalInSec < MINIMUM_INTERVAL_SEC) this.fetchIntervalInSec = MINIMUM_INTERVAL_SEC;
	                            var fetchPromise = this._fetch({ useCache: false });
	                            this.configurationFetcher.dispatchPeriodically({
	                                handler: this.onConfigurationFetched,
	                                periodTimeInSec: this.fetchIntervalInSec
	                            });
	                            return fetchPromise;
	                        }
	                    }, {
	                        key: 'fetchCacheOnly',
	                        value: function fetchCacheOnly() {
	                            return this._fetch({ useCache: true, skipNetwork: true });
	                        }
	                    }, {
	                        key: 'fetchWithCacheAndProceed',
	                        value: function fetchWithCacheAndProceed() {
	                            return this._fetch({ useCache: true });
	                        }
	                    }, {
	                        key: 'fetch',
	                        value: function fetch() {
	                            return this._fetch({ useCache: false });
	                        }
	                    }, {
	                        key: '_fetchFromPush',
	                        value: function _fetchFromPush() {
	                            return this._fetch({ useCache: false, source: 'push' });
	                        }
	                    }, {
	                        key: 'sendState',
	                        value: function sendState() {
	                            this._sendState();
	                        }
	                    }, {
	                        key: '_sendState',
	                        value: function _sendState() {
	                            this.sendStateDebounceNoCheck.cancel();
	                            if (!this.app_key) {
	                                return;
	                            }
	                            if (this.disableNetwork) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('send state - disabled network');
	                                return;
	                            }
	                            if (this.stateSender) {
	                                this.stateSender.send();
	                            }
	                        }
	                    }, {
	                        key: '_fetch',
	                        value: function _fetch() {
	                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	                            if (!this.app_key) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].warn('no app key');
	                                return;
	                            }
	                            if (!this.configurationFetcher) {
	                                return;
	                            }
	                            if (this.disableNetwork) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('fetch - disabling network');
	                                options.skipNetwork = true;
	                            }
	                            return this.configurationFetcher.dispatch({
	                                handler: this.onConfigurationFetched,
	                                options: options
	                            });
	                        }
	                    }, {
	                        key: 'register',
	                        value: function register(name, container) {
	                            if (container === undefined && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name !== null) {
	                                container = name;
	                                name = '';
	                            }
	                            ___WEBPACK_IMPORTED_MODULE_9__["default"].debug('Registering container \'' + name + '\' = ' + JSON.stringify(container));
	                            this.classRegisterer.handleContainer(name, container);
	                            this.sendStateDebounced();
	                        }
	                    }, {
	                        key: 'setSemverCustomProperty',
	                        value: function setSemverCustomProperty(name, value) {
	                            this.setCustomProperty(name, _entities__WEBPACK_IMPORTED_MODULE_14__["default"].semverTypeName, value);
	                        }
	                    }, {
	                        key: 'setCustomProperty',
	                        value: function setCustomProperty(name, type, value) {
	                            var property = new _entities__WEBPACK_IMPORTED_MODULE_14__["default"](name, type, value);
	                            var isNew = !_repositories__WEBPACK_IMPORTED_MODULE_8__["default"].has(property);
	                            _repositories__WEBPACK_IMPORTED_MODULE_8__["default"].set(property);
	                            isNew && this.sendStateDebounced();
	                        }
	                    }, {
	                        key: 'unfreeze',
	                        value: function unfreeze(namespace, freezeLevel) {
	                            var namespaceFilter = function namespaceFilter(flag) {
	                                if (!flag.name || typeof namespace !== 'string') return true;
	                                var flagNameParts = flag.name.split('.');
	                                if (flagNameParts.length === 1 && namespace === '') {
	                                    return true;
	                                } else if (flagNameParts.slice(0, flagNameParts.length - 1).join('.') === namespace) {
	                                    return true;
	                                }
	                                return false;
	                            };
	                            _repositories__WEBPACK_IMPORTED_MODULE_15__["default"].flags.filter(namespaceFilter).forEach(function (flag) {
	                                flag.unfreeze(freezeLevel);
	                            });
	                        }
	                    }, {
	                        key: 'onConfigurationFetched',
	                        value: function onConfigurationFetched(data) {
	                            try {
	                                if (data.fetcherStatus !== _FetcherResults__WEBPACK_IMPORTED_MODULE_19__.FetcherStatus.ERROR_FETCH_FAILED) {
	                                    this.startOrStopPushUpdatesListener();
	                                }
	                            } catch (ex) {
	                                ___WEBPACK_IMPORTED_MODULE_9__["default"].warn('Cound not start or stop push notification listener. exception: ' + ex);
	                            }
	                            if (this.configurationFetchedHandler instanceof Function) {
	                                try {
	                                    return this.configurationFetchedHandler(data);
	                                } catch (e) {
	                                    _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_20__["default"].invoke(_UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_20__.ExceptionTrigger.CONFIGURATION_FETCHED_HANDLER, e);
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'startOrStopPushUpdatesListener',
	                        value: function startOrStopPushUpdatesListener() {
	                            var _this9 = this;

	                            if (!this.disablePushUpdateListener && (0, _InternalFlags__WEBPACK_IMPORTED_MODULE_10__.isEnabled)('rox.internal.pushUpdates')) {
	                                if (this.app_key) {
	                                    if (!this.pushUpdatesListener) {
	                                        this.pushUpdatesListener = new _notifications_notification_listener__WEBPACK_IMPORTED_MODULE_21__["default"](_config__WEBPACK_IMPORTED_MODULE_2__["default"].get('NOTIFICATIONS_ENDPOINT'), this.app_key, this.eventSourceImpl, this.networkOptions);
	                                        this.pushUpdatesListener.on('changed', function () {
	                                            _this9._fetchFromPush();
	                                        });
	                                    }
	                                }
	                            } else {
	                                if (this.pushUpdatesListener) {
	                                    this.pushUpdatesListener.stop();
	                                    this.pushUpdatesListener = null;
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'setUserspaceUnhandledErrorHandler',
	                        value: function setUserspaceUnhandledErrorHandler(handler) {
	                            _UserspaceUnhandledErrorInvoker__WEBPACK_IMPORTED_MODULE_20__["default"].setHandler(handler);
	                        }
	                    }, {
	                        key: 'dynamicApi',
	                        get: function get() {
	                            return this._dynamicApi;
	                        }
	                    }, {
	                        key: 'appKey',
	                        get: function get() {
	                            return this.app_key;
	                        }
	                    }, {
	                        key: 'metadata',
	                        get: function get() {
	                            var _roxxTrueToBoolean = function _roxxTrueToBoolean(val) {
	                                return val === 'true' ? true : false;
	                            };
	                            var parser = new _parsers__WEBPACK_IMPORTED_MODULE_16__["default"]();
	                            var targetGroups = _repositories__WEBPACK_IMPORTED_MODULE_17__["default"].targetGroups.map(function (tg) {
	                                return {
	                                    name: tg.name,
	                                    isEnabled: parser.evaluateExpression(tg.condition)
	                                };
	                            });
	                            var experiments = _repositories__WEBPACK_IMPORTED_MODULE_18__["default"].experiments.map(function (e) {
	                                return {
	                                    name: e.name,
	                                    isEnabled: _roxxTrueToBoolean(parser.evaluateExpression(e.deploymentConfiguration.condition))
	                                };
	                            });
	                            var flags = _repositories__WEBPACK_IMPORTED_MODULE_15__["default"].flags.map(function (f) {
	                                return {
	                                    name: f.name,
	                                    value: f._peek()
	                                };
	                            });
	                            return { targetGroups: targetGroups, experiments: experiments, flags: flags };
	                        }
	                    }, {
	                        key: 'cacheURL',
	                        get: function get() {
	                            if (!this.configurationFetcher || !this.configurationFetcher.cacheURL) {
	                                throw new Error('Rox was not initialized. Please call setup() before calling cacheURL()');
	                            }
	                            return this.configurationFetcher.cacheURL;
	                        }
	                    }]);

	                    return _Client;
	                }();

	                var instance = new _Client();
	                function _createRoxClient() {
	                    var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	                    _deps = Object.assign({}, _deps, deps);
	                    instance._dynamicApi = new _DynamicApi__WEBPACK_IMPORTED_MODULE_22__["default"](deps.EntitiesProvider, _repositories__WEBPACK_IMPORTED_MODULE_15__["default"], instance);
	                    return instance;
	                }

	                /***/
	            },
	            /* 40 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var isObject = __webpack_require__(41),
	                    now = __webpack_require__(42),
	                    toNumber = __webpack_require__(45);

	                /** Error message constants. */
	                var FUNC_ERROR_TEXT = 'Expected a function';

	                /* Built-in method references for those with the same name as other `lodash` methods. */
	                var nativeMax = Math.max,
	                    nativeMin = Math.min;

	                /**
	                 * Creates a debounced function that delays invoking `func` until after `wait`
	                 * milliseconds have elapsed since the last time the debounced function was
	                 * invoked. The debounced function comes with a `cancel` method to cancel
	                 * delayed `func` invocations and a `flush` method to immediately invoke them.
	                 * Provide `options` to indicate whether `func` should be invoked on the
	                 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	                 * with the last arguments provided to the debounced function. Subsequent
	                 * calls to the debounced function return the result of the last `func`
	                 * invocation.
	                 *
	                 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	                 * invoked on the trailing edge of the timeout only if the debounced function
	                 * is invoked more than once during the `wait` timeout.
	                 *
	                 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	                 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	                 *
	                 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	                 * for details over the differences between `_.debounce` and `_.throttle`.
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 0.1.0
	                 * @category Function
	                 * @param {Function} func The function to debounce.
	                 * @param {number} [wait=0] The number of milliseconds to delay.
	                 * @param {Object} [options={}] The options object.
	                 * @param {boolean} [options.leading=false]
	                 *  Specify invoking on the leading edge of the timeout.
	                 * @param {number} [options.maxWait]
	                 *  The maximum time `func` is allowed to be delayed before it's invoked.
	                 * @param {boolean} [options.trailing=true]
	                 *  Specify invoking on the trailing edge of the timeout.
	                 * @returns {Function} Returns the new debounced function.
	                 * @example
	                 *
	                 * // Avoid costly calculations while the window size is in flux.
	                 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	                 *
	                 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	                 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	                 *   'leading': true,
	                 *   'trailing': false
	                 * }));
	                 *
	                 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	                 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	                 * var source = new EventSource('/stream');
	                 * jQuery(source).on('message', debounced);
	                 *
	                 * // Cancel the trailing debounced invocation.
	                 * jQuery(window).on('popstate', debounced.cancel);
	                 */
	                function debounce(func, wait, options) {
	                    var lastArgs,
	                        lastThis,
	                        maxWait,
	                        result,
	                        timerId,
	                        lastCallTime,
	                        lastInvokeTime = 0,
	                        leading = false,
	                        maxing = false,
	                        trailing = true;

	                    if (typeof func != 'function') {
	                        throw new TypeError(FUNC_ERROR_TEXT);
	                    }
	                    wait = toNumber(wait) || 0;
	                    if (isObject(options)) {
	                        leading = !!options.leading;
	                        maxing = 'maxWait' in options;
	                        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	                        trailing = 'trailing' in options ? !!options.trailing : trailing;
	                    }

	                    function invokeFunc(time) {
	                        var args = lastArgs,
	                            thisArg = lastThis;

	                        lastArgs = lastThis = undefined;
	                        lastInvokeTime = time;
	                        result = func.apply(thisArg, args);
	                        return result;
	                    }

	                    function leadingEdge(time) {
	                        // Reset any `maxWait` timer.
	                        lastInvokeTime = time;
	                        // Start the timer for the trailing edge.
	                        timerId = setTimeout(timerExpired, wait);
	                        // Invoke the leading edge.
	                        return leading ? invokeFunc(time) : result;
	                    }

	                    function remainingWait(time) {
	                        var timeSinceLastCall = time - lastCallTime,
	                            timeSinceLastInvoke = time - lastInvokeTime,
	                            timeWaiting = wait - timeSinceLastCall;

	                        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	                    }

	                    function shouldInvoke(time) {
	                        var timeSinceLastCall = time - lastCallTime,
	                            timeSinceLastInvoke = time - lastInvokeTime;

	                        // Either this is the first call, activity has stopped and we're at the
	                        // trailing edge, the system time has gone backwards and we're treating
	                        // it as the trailing edge, or we've hit the `maxWait` limit.
	                        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	                    }

	                    function timerExpired() {
	                        var time = now();
	                        if (shouldInvoke(time)) {
	                            return trailingEdge(time);
	                        }
	                        // Restart the timer.
	                        timerId = setTimeout(timerExpired, remainingWait(time));
	                    }

	                    function trailingEdge(time) {
	                        timerId = undefined;

	                        // Only invoke if we have `lastArgs` which means `func` has been
	                        // debounced at least once.
	                        if (trailing && lastArgs) {
	                            return invokeFunc(time);
	                        }
	                        lastArgs = lastThis = undefined;
	                        return result;
	                    }

	                    function cancel() {
	                        if (timerId !== undefined) {
	                            clearTimeout(timerId);
	                        }
	                        lastInvokeTime = 0;
	                        lastArgs = lastCallTime = lastThis = timerId = undefined;
	                    }

	                    function flush() {
	                        return timerId === undefined ? result : trailingEdge(now());
	                    }

	                    function debounced() {
	                        var time = now(),
	                            isInvoking = shouldInvoke(time);

	                        lastArgs = arguments;
	                        lastThis = this;
	                        lastCallTime = time;

	                        if (isInvoking) {
	                            if (timerId === undefined) {
	                                return leadingEdge(lastCallTime);
	                            }
	                            if (maxing) {
	                                // Handle invocations in a tight loop.
	                                clearTimeout(timerId);
	                                timerId = setTimeout(timerExpired, wait);
	                                return invokeFunc(lastCallTime);
	                            }
	                        }
	                        if (timerId === undefined) {
	                            timerId = setTimeout(timerExpired, wait);
	                        }
	                        return result;
	                    }
	                    debounced.cancel = cancel;
	                    debounced.flush = flush;
	                    return debounced;
	                }

	                module.exports = debounce;

	                /***/
	            },
	            /* 41 */
	            /***/function (module) {

	                /**
	                 * Checks if `value` is the
	                 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	                 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 0.1.0
	                 * @category Lang
	                 * @param {*} value The value to check.
	                 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	                 * @example
	                 *
	                 * _.isObject({});
	                 * // => true
	                 *
	                 * _.isObject([1, 2, 3]);
	                 * // => true
	                 *
	                 * _.isObject(_.noop);
	                 * // => true
	                 *
	                 * _.isObject(null);
	                 * // => false
	                 */
	                function isObject(value) {
	                    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
	                    return value != null && (type == 'object' || type == 'function');
	                }

	                module.exports = isObject;

	                /***/
	            },
	            /* 42 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var root = __webpack_require__(43);

	                /**
	                 * Gets the timestamp of the number of milliseconds that have elapsed since
	                 * the Unix epoch (1 January 1970 00:00:00 UTC).
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 2.4.0
	                 * @category Date
	                 * @returns {number} Returns the timestamp.
	                 * @example
	                 *
	                 * _.defer(function(stamp) {
	                 *   console.log(_.now() - stamp);
	                 * }, _.now());
	                 * // => Logs the number of milliseconds it took for the deferred invocation.
	                 */
	                var now = function now() {
	                    return root.Date.now();
	                };

	                module.exports = now;

	                /***/
	            },
	            /* 43 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var freeGlobal = __webpack_require__(44);

	                /** Detect free variable `self`. */
	                var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

	                /** Used as a reference to the global object. */
	                var root = freeGlobal || freeSelf || Function('return this')();

	                module.exports = root;

	                /***/
	            },
	            /* 44 */
	            /***/function (module) {

	                /** Detect free variable `global` from Node.js. */
	                var freeGlobal = (typeof commonjsGlobal === 'undefined' ? 'undefined' : _typeof(commonjsGlobal)) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	                module.exports = freeGlobal;

	                /***/
	            },
	            /* 45 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var baseTrim = __webpack_require__(46),
	                    isObject = __webpack_require__(41),
	                    isSymbol = __webpack_require__(48);

	                /** Used as references for various `Number` constants. */
	                var NAN = 0 / 0;

	                /** Used to detect bad signed hexadecimal string values. */
	                var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	                /** Used to detect binary string values. */
	                var reIsBinary = /^0b[01]+$/i;

	                /** Used to detect octal string values. */
	                var reIsOctal = /^0o[0-7]+$/i;

	                /** Built-in method references without a dependency on `root`. */
	                var freeParseInt = parseInt;

	                /**
	                 * Converts `value` to a number.
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 4.0.0
	                 * @category Lang
	                 * @param {*} value The value to process.
	                 * @returns {number} Returns the number.
	                 * @example
	                 *
	                 * _.toNumber(3.2);
	                 * // => 3.2
	                 *
	                 * _.toNumber(Number.MIN_VALUE);
	                 * // => 5e-324
	                 *
	                 * _.toNumber(Infinity);
	                 * // => Infinity
	                 *
	                 * _.toNumber('3.2');
	                 * // => 3.2
	                 */
	                function toNumber(value) {
	                    if (typeof value == 'number') {
	                        return value;
	                    }
	                    if (isSymbol(value)) {
	                        return NAN;
	                    }
	                    if (isObject(value)) {
	                        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	                        value = isObject(other) ? other + '' : other;
	                    }
	                    if (typeof value != 'string') {
	                        return value === 0 ? value : +value;
	                    }
	                    value = baseTrim(value);
	                    var isBinary = reIsBinary.test(value);
	                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	                }

	                module.exports = toNumber;

	                /***/
	            },
	            /* 46 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var trimmedEndIndex = __webpack_require__(47);

	                /** Used to match leading whitespace. */
	                var reTrimStart = /^\s+/;

	                /**
	                 * The base implementation of `_.trim`.
	                 *
	                 * @private
	                 * @param {string} string The string to trim.
	                 * @returns {string} Returns the trimmed string.
	                 */
	                function baseTrim(string) {
	                    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
	                }

	                module.exports = baseTrim;

	                /***/
	            },
	            /* 47 */
	            /***/function (module) {

	                /** Used to match a single whitespace character. */
	                var reWhitespace = /\s/;

	                /**
	                 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	                 * character of `string`.
	                 *
	                 * @private
	                 * @param {string} string The string to inspect.
	                 * @returns {number} Returns the index of the last non-whitespace character.
	                 */
	                function trimmedEndIndex(string) {
	                    var index = string.length;

	                    while (index-- && reWhitespace.test(string.charAt(index))) {}
	                    return index;
	                }

	                module.exports = trimmedEndIndex;

	                /***/
	            },
	            /* 48 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var baseGetTag = __webpack_require__(49),
	                    isObjectLike = __webpack_require__(53);

	                /** `Object#toString` result references. */
	                var symbolTag = '[object Symbol]';

	                /**
	                 * Checks if `value` is classified as a `Symbol` primitive or object.
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 4.0.0
	                 * @category Lang
	                 * @param {*} value The value to check.
	                 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	                 * @example
	                 *
	                 * _.isSymbol(Symbol.iterator);
	                 * // => true
	                 *
	                 * _.isSymbol('abc');
	                 * // => false
	                 */
	                function isSymbol(value) {
	                    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
	                }

	                module.exports = isSymbol;

	                /***/
	            },
	            /* 49 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var _Symbol = __webpack_require__(50),
	                    getRawTag = __webpack_require__(51),
	                    objectToString = __webpack_require__(52);

	                /** `Object#toString` result references. */
	                var nullTag = '[object Null]',
	                    undefinedTag = '[object Undefined]';

	                /** Built-in value references. */
	                var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	                /**
	                 * The base implementation of `getTag` without fallbacks for buggy environments.
	                 *
	                 * @private
	                 * @param {*} value The value to query.
	                 * @returns {string} Returns the `toStringTag`.
	                 */
	                function baseGetTag(value) {
	                    if (value == null) {
	                        return value === undefined ? undefinedTag : nullTag;
	                    }
	                    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	                }

	                module.exports = baseGetTag;

	                /***/
	            },
	            /* 50 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var root = __webpack_require__(43);

	                /** Built-in value references. */
	                var _Symbol2 = root.Symbol;

	                module.exports = _Symbol2;

	                /***/
	            },
	            /* 51 */
	            /***/function (module, __unused_webpack_exports, __webpack_require__) {

	                var _Symbol3 = __webpack_require__(50);

	                /** Used for built-in method references. */
	                var objectProto = Object.prototype;

	                /** Used to check objects for own properties. */
	                var hasOwnProperty = objectProto.hasOwnProperty;

	                /**
	                 * Used to resolve the
	                 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	                 * of values.
	                 */
	                var nativeObjectToString = objectProto.toString;

	                /** Built-in value references. */
	                var symToStringTag = _Symbol3 ? _Symbol3.toStringTag : undefined;

	                /**
	                 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	                 *
	                 * @private
	                 * @param {*} value The value to query.
	                 * @returns {string} Returns the raw `toStringTag`.
	                 */
	                function getRawTag(value) {
	                    var isOwn = hasOwnProperty.call(value, symToStringTag),
	                        tag = value[symToStringTag];

	                    try {
	                        value[symToStringTag] = undefined;
	                        var unmasked = true;
	                    } catch (e) {}

	                    var result = nativeObjectToString.call(value);
	                    if (unmasked) {
	                        if (isOwn) {
	                            value[symToStringTag] = tag;
	                        } else {
	                            delete value[symToStringTag];
	                        }
	                    }
	                    return result;
	                }

	                module.exports = getRawTag;

	                /***/
	            },
	            /* 52 */
	            /***/function (module) {

	                /** Used for built-in method references. */
	                var objectProto = Object.prototype;

	                /**
	                 * Used to resolve the
	                 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	                 * of values.
	                 */
	                var nativeObjectToString = objectProto.toString;

	                /**
	                 * Converts `value` to a string using `Object.prototype.toString`.
	                 *
	                 * @private
	                 * @param {*} value The value to convert.
	                 * @returns {string} Returns the converted string.
	                 */
	                function objectToString(value) {
	                    return nativeObjectToString.call(value);
	                }

	                module.exports = objectToString;

	                /***/
	            },
	            /* 53 */
	            /***/function (module) {

	                /**
	                 * Checks if `value` is object-like. A value is object-like if it's not `null`
	                 * and has a `typeof` result of "object".
	                 *
	                 * @static
	                 * @memberOf _
	                 * @since 4.0.0
	                 * @category Lang
	                 * @param {*} value The value to check.
	                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	                 * @example
	                 *
	                 * _.isObjectLike({});
	                 * // => true
	                 *
	                 * _.isObjectLike([1, 2, 3]);
	                 * // => true
	                 *
	                 * _.isObjectLike(_.noop);
	                 * // => false
	                 *
	                 * _.isObjectLike(null);
	                 * // => false
	                 */
	                function isObjectLike(value) {
	                    return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	                }

	                module.exports = isObjectLike;

	                /***/
	            },
	            /* 54 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */RoxClassRegister
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
	                /* harmony import */var _entities_RoxStringBase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);

	                var defaultOptions = { flagsRepository: _repositories__WEBPACK_IMPORTED_MODULE_0__["default"] };

	                var RoxClassRegister = function () {
	                    function RoxClassRegister() {
	                        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	                        _classCallCheck(this, RoxClassRegister);

	                        this.options = Object.assign({}, defaultOptions, options);
	                        this._flagsRepository = this.options.flagsRepository;
	                        this._namespaceStore = new Set();
	                    }

	                    _createClass(RoxClassRegister, [{
	                        key: 'handleContainer',
	                        value: function handleContainer(namespace, container) {
	                            if (Object.prototype.toString.call(namespace) !== '[object String]') {
	                                throw new Error('InvalidNamespace: Namespace must be a string (non-nullable).');
	                            }
	                            if (this._namespaceStore.has(namespace)) {
	                                var err = 'InvalidNamespace: A namespace must be unique. A container with the given namespace (\'' + namespace + '\') has already been registered.';
	                                throw new Error(err);
	                            } else {
	                                this._namespaceStore.add(namespace);
	                            }
	                            for (var prop in container) {
	                                if (Object.prototype.hasOwnProperty.call(container, prop)) {
	                                    var label = namespace ? namespace + '.' + prop : prop;
	                                    var entity = container[prop];
	                                    if (entity instanceof _entities_RoxStringBase__WEBPACK_IMPORTED_MODULE_1__["default"]) {
	                                        this._flagsRepository.addFlag(label, entity);
	                                    }
	                                }
	                            }
	                        }
	                    }]);

	                    return RoxClassRegister;
	                }();

	                /***/
	            },
	            /* 55 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */BugsnagReporter: function BugsnagReporter() {
	                        return (/* binding */_BugsnagReporter
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
	                var __rest = function (s, e) {
	                    var t = {};
	                    for (var p in s) {
	                        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	                    }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	                    }
	                    return t;
	                };

	                var BS_API_KEY = 'abbf3bd9c6e80eb1e8c0566c35b08748';
	                var BS_NOTIFY_ENDPOINT = 'https://notify.bugsnag.com';

	                var _BugsnagReporter = function () {
	                    function _BugsnagReporter(app_key, deviceProperties, networkOptions, networkSender) {
	                        _classCallCheck(this, _BugsnagReporter);

	                        var _a = deviceProperties.getProperties(),
	                            distinct_id = _a.distinct_id,
	                            app_release = _a.app_release,
	                            platform = _a.platform,
	                            api_version = _a.api_version,
	                            lib_version = _a.lib_version,
	                            device = __rest(_a, ["distinct_id", "app_release", "platform", "api_version", "lib_version"]);
	                        this.device = device;
	                        this.header = {
	                            apiKey: BS_API_KEY,
	                            notifier: {
	                                name: 'Rollout JavaScript SDK',
	                                version: lib_version,
	                                url: typeof window !== 'undefined' && window.location && window.location.href || undefined
	                            }
	                        };
	                        this.networkOptions = networkOptions;
	                        this.networkSender = networkSender;
	                        this.user = { distinct_id: distinct_id, app_release: app_release, app_key: app_key, platform: platform };
	                        this.app = { api_version: api_version, lib_version: lib_version };
	                    }

	                    _createClass(_BugsnagReporter, [{
	                        key: 'error',
	                        value: function error(message, exception) {
	                            return this._notify('error', message, exception);
	                        }
	                    }, {
	                        key: '_notify',
	                        value: function _notify(severity, message, exception) {
	                            var event = {
	                                payloadVersion: 4,
	                                exceptions: [],
	                                app: this.app,
	                                user: this.user,
	                                device: this.device,
	                                metaData: {
	                                    data: {
	                                        message: message,
	                                        exception: exception.toString()
	                                    }
	                                },
	                                severity: severity
	                            };
	                            if (exception instanceof Error) {
	                                event.exceptions.push({
	                                    errorClass: exception.name,
	                                    message: message + '\n' + exception.message,
	                                    stacktrace: exception.stack || ''
	                                });
	                                event.groupingHash = exception.fileName;
	                            } else {
	                                event.exceptions.push({
	                                    errorClass: 'Error',
	                                    message: message,
	                                    stacktrace: []
	                                });
	                            }
	                            return this._send([event]);
	                        }
	                    }, {
	                        key: '_send',
	                        value: function _send(events) {
	                            var data = Object.assign({ events: events }, this.header);
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].debug('Sending bugsnag error report.');
	                            var request = { url: BS_NOTIFY_ENDPOINT, data: data, options: this.networkOptions };
	                            _config__WEBPACK_IMPORTED_MODULE_1__["default"].getProxy().applyProxyToRequest(request);
	                            try {
	                                this.networkSender.post(request.url, request.data, request.options).then(function () {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].debug('Successfully sent error report.');
	                                }).catch(function (err) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].debug('Failed to send error report', err);
	                                });
	                            } catch (e) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].debug('Failed to send error report.', e);
	                            }
	                        }
	                    }]);

	                    return _BugsnagReporter;
	                }();

	                /***/
	            },
	            /* 56 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RequestConfiguration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60);
	                /* harmony import */var _RequestConfigurationBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58);
	                /* harmony import */var _parsers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30);
	                /* harmony import */var _setters__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(24);
	                /* harmony import */var _InternalFlags__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
	                /* harmony import */var _repositories_TargetGroupRepository__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25);
	                /* harmony import */var _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14);
	                /* harmony import */var _repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
	                /* harmony import */var _FetcherResults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
	                /* harmony import */var _EmbeddedConfiguration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(63);

	                var CACHE_KEY = _config__WEBPACK_IMPORTED_MODULE_0__["default"].get('CLIENT_DATA_CACHE_KEY');
	                var isDispatchPeriodicallyRunning = false;

	                var ConfigurationFetcher = function () {
	                    function ConfigurationFetcher(appKey, deviceProperties, devModeSecret, dependencies, embeddedPayload, options, networkOptions, networkSender) {
	                        _classCallCheck(this, ConfigurationFetcher);

	                        this.cache = dependencies.RoxCache;
	                        this.crypto = dependencies.RoxCrypto;
	                        this.embdeddedJSON = this.fetchFromEmbedded(embeddedPayload);
	                        this.appKey = appKey;
	                        this.deviceProperties = deviceProperties;
	                        this.devModeSecret = devModeSecret;
	                        this.options = options || {};
	                        this.networkOptions = networkOptions;
	                        this.networkSender = networkSender;
	                        this.lastResponse = null;
	                    }

	                    _createClass(ConfigurationFetcher, [{
	                        key: 'runHandler',
	                        value: function runHandler(handler, data) {
	                            var _a;
	                            if (data.errorDetails) {
	                                (_a = _config__WEBPACK_IMPORTED_MODULE_0__["default"].getErrorReporter()) === null || _a === void 0 ? void 0 : _a.error('Configuration fetcher returned with ' + data.fetcherStatus, data.errorDetails);
	                            }
	                            if (handler instanceof Function) {
	                                try {
	                                    handler(data);
	                                } catch (e) {
	                                    //
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'dispatch',
	                        value: function dispatch(_ref3) {
	                            var handler = _ref3.handler,
	                                options = _ref3.options;

	                            try {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('dispatch();');
	                                var sources = [];
	                                if (options.useCache) {
	                                    if (this.embdeddedJSON) {
	                                        var verified = this.verifyPayload(this.embdeddedJSON);
	                                        if (!verified) {
	                                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].error('The embdeddedJSON was corrupted or its authenticity cannot be securely verified. skipping embedded');
	                                        } else {
	                                            var embdeddedParser = this.parsePayload(this.embdeddedJSON);
	                                            if (embdeddedParser) {
	                                                sources.push({
	                                                    payload: this.embdeddedJSON,
	                                                    parser: embdeddedParser,
	                                                    status: _FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherStatus.APPLIED_FROM_EMBEDDED
	                                                });
	                                            }
	                                        }
	                                    }
	                                    var cachedPayload = this.fetchFromCache();
	                                    if (cachedPayload) {
	                                        var _verified = this.verifyPayload(cachedPayload);
	                                        if (!_verified) {
	                                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].error('The cachedPayload was corrupted or its authenticity cannot be securely verified. skipping cache');
	                                        } else {
	                                            var cachedParser = this.parsePayload(cachedPayload);
	                                            if (cachedParser) {
	                                                sources.push({
	                                                    payload: cachedPayload,
	                                                    parser: cachedParser,
	                                                    status: _FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherStatus.APPLIED_FROM_CACHE
	                                                });
	                                            }
	                                        }
	                                    }
	                                }
	                                if (sources.length > 0) {
	                                    var latest = sources.reduce(function (latest, current) {
	                                        return latest && latest.parser.signedDate() > current.parser.signedDate() ? latest : current;
	                                    }, null);
	                                    if (!this.lastApplied || this.lastApplied.signedDate() < latest.parser.signedDate()) {
	                                        this.lastResponse = latest.payload;
	                                        this.apply(latest.parser, latest.status, false, handler, latest.payload);
	                                    }
	                                }
	                                if (options.skipNetwork) {
	                                    return;
	                                }
	                                if (this.shouldSkipFetch(options.source)) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Skipping fetch - kill switch');
	                                    return;
	                                }
	                                return this._dispatch({ handler: handler, storeInCache: true });
	                            } catch (e) {
	                                // hopefully all code here is promisless, or promise returning functions already handles the catch inside
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].error('Unexpected error in dispatch', e);
	                            }
	                        }
	                    }, {
	                        key: 'shouldSkipFetch',
	                        value: function shouldSkipFetch(source) {
	                            var isFromPush = source === 'push';
	                            var timeBetweebFetches = (0, _InternalFlags__WEBPACK_IMPORTED_MODULE_3__.getNumber)('rox.internal.throttleFetchInSeconds');
	                            if (timeBetweebFetches > 0 && (!isFromPush || (0, _InternalFlags__WEBPACK_IMPORTED_MODULE_3__.isEnabled)('rox.internal.considerThrottleInPush'))) {
	                                var nowInMili = +Date.now();
	                                if (this.lastFetchTryTime && nowInMili < this.lastFetchTryTime + timeBetweebFetches * 1000) {
	                                    return true;
	                                }
	                                this.lastFetchTryTime = nowInMili;
	                            }
	                            return false;
	                        }
	                    }, {
	                        key: 'dispatchPeriodically',
	                        value: function dispatchPeriodically(_ref4) {
	                            var _this10 = this;

	                            var handler = _ref4.handler,
	                                periodTimeInSec = _ref4.periodTimeInSec;

	                            if (isDispatchPeriodicallyRunning) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Dispatch Periodically already running');
	                                return Promise.resolve();
	                            }
	                            isDispatchPeriodicallyRunning = true;
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Dispatch Periodically');
	                            setInterval(function () {
	                                _this10._dispatch({ handler: handler });
	                            }, periodTimeInSec * 1000);
	                        }
	                    }, {
	                        key: '_dispatch',
	                        value: function _dispatch(_ref5) {
	                            var _this11 = this;

	                            var handler = _ref5.handler,
	                                storeInCache = _ref5.storeInCache;

	                            return this.fetchFromNetwork().then(function (response) {
	                                var hasChanges = _this11.isNewResponse(response);
	                                var result = _this11.process(response, _FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherStatus.APPLIED_FROM_NETWORK, hasChanges, handler);
	                                return result.then(function () {
	                                    storeInCache && _this11.storeInCache(response);
	                                    _this11.lastResponse = response;
	                                });
	                            }).catch(function (err) {
	                                _this11.runHandler(handler, new _FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherResults(_FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherStatus.ERROR_FETCH_FAILED, null, false, err));
	                            });
	                        }
	                    }, {
	                        key: 'fetchFromNetwork',
	                        value: function fetchFromNetwork() {
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('fetch from network for appKey ' + this.appKey);
	                            var rc = (0, _RequestConfigurationBuilder__WEBPACK_IMPORTED_MODULE_4__.buildRequestConfiguration)({
	                                appKey: this.appKey,
	                                deviceProperties: this.deviceProperties,
	                                devModeSecret: this.devModeSecret
	                            });
	                            this.rc = rc;
	                            if (this.options.roxyUrl) {
	                                return (0, _RequestConfiguration__WEBPACK_IMPORTED_MODULE_5__.fetchRemoteConfigurationWithRoxy)(this.networkSender, rc, this.options.roxyUrl, this.networkOptions);
	                            }
	                            return (0, _RequestConfiguration__WEBPACK_IMPORTED_MODULE_5__.fetchRemoteConfiguration)(this.networkSender, rc, this.networkOptions, this.options);
	                        }
	                    }, {
	                        key: 'fetchFromCache',
	                        value: function fetchFromCache() {
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('fetch From Cache');
	                            var cached = this.cache.get(this.cacheKey());
	                            // handle legacy cacheKey (see ROL-556)
	                            if (!cached) {
	                                cached = this.cache.get(CACHE_KEY);
	                            }
	                            var parsed = void 0;
	                            if (cached) {
	                                try {
	                                    parsed = JSON.parse(cached);
	                                } catch (e) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].warn('Configuration retrieved from cache, but is corrupted. Aborting. (Error: ' + e + ')');
	                                }
	                                if (parsed && parsed.constructor === Object) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Parsed cached = ' + JSON.stringify(parsed));
	                                    return parsed;
	                                }
	                            }
	                        }
	                    }, {
	                        key: 'cacheKey',
	                        value: function cacheKey() {
	                            return CACHE_KEY + '-' + this.appKey;
	                        }
	                    }, {
	                        key: 'fetchFromEmbedded',
	                        value: function fetchFromEmbedded(embedded) {
	                            var parsed = void 0;
	                            if (embedded) {
	                                try {
	                                    parsed = JSON.parse(embedded);
	                                } catch (e) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].warn('Received embdedded configuration, but it is corrupted. Aborting. Error: ', e);
	                                }
	                                if (parsed && parsed.constructor === Object) {
	                                    _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Parsed embedded = ' + JSON.stringify(parsed));
	                                    return parsed;
	                                }
	                            }
	                            if (_EmbeddedConfiguration__WEBPACK_IMPORTED_MODULE_6__["default"] && _typeof(_EmbeddedConfiguration__WEBPACK_IMPORTED_MODULE_6__["default"]) === 'object') {
	                                return _EmbeddedConfiguration__WEBPACK_IMPORTED_MODULE_6__["default"];
	                            }
	                        }
	                    }, {
	                        key: 'storeInCache',
	                        value: function storeInCache(response) {
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Store in cache response = ' + JSON.stringify(response));
	                            this.cache.set(this.cacheKey(), JSON.stringify(response));
	                        }
	                    }, {
	                        key: 'process',
	                        value: function process(payload, source, hasChanges, handler) {
	                            if (!payload) {
	                                return Promise.reject('Empty configuration');
	                            }
	                            var verified = this.verifyPayload(payload);
	                            if (!verified) {
	                                return Promise.reject('The payload has corrupted or its authenticity cannot be securely verified.');
	                            }
	                            var parser = this.parsePayload(payload);
	                            if (!parser) {
	                                return Promise.reject('Failed to parse configuration');
	                            }
	                            return this.apply(parser, source, hasChanges, handler, payload);
	                        }
	                    }, {
	                        key: 'apply',
	                        value: function apply(parser, source, hasChanges, handler, clientData) {
	                            var _this12 = this;

	                            if (parser) {
	                                this.calculatePayload(parser);
	                                this.lastApplied = parser;
	                                return new Promise(function (resolve) {
	                                    var fetcherResults = new _FetcherResults__WEBPACK_IMPORTED_MODULE_2__.FetcherResults(source, parser.signedDate(), hasChanges, undefined, clientData);
	                                    _this12.runHandler(handler, fetcherResults);
	                                    resolve();
	                                });
	                            }
	                        }
	                    }, {
	                        key: 'parsePayload',
	                        value: function parsePayload(response) {
	                            var validateAppKey = !this.options.roxyUrl;
	                            var parser = new _parsers__WEBPACK_IMPORTED_MODULE_7__["default"](response, this.appKey, validateAppKey);
	                            if (!parser.parse()) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('failed to parse payload. response = ' + JSON.stringify(response) + ' deviceProps = ' + this.deviceProperties + ' app_key = ' + this.appKey);
	                                return null;
	                            }
	                            return parser;
	                        }
	                    }, {
	                        key: 'verifyPayload',
	                        value: function verifyPayload(response) {
	                            var signature_v0 = response.signature_v0,
	                                data = response.data;

	                            if (this.options.roxyUrl || this.options.selfManagedMode || this.options.disableSignatureVerification) {
	                                return true;
	                            }
	                            return this.crypto.verify(data, signature_v0);
	                        }
	                    }, {
	                        key: 'calculatePayload',
	                        value: function calculatePayload(parser) {
	                            if (!parser) {
	                                return;
	                            }
	                            _repositories_TargetGroupRepository__WEBPACK_IMPORTED_MODULE_8__["default"].setTargetGroups(parser.targetGroups());
	                            _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_9__["default"].setExperiments(parser.experiments());
	                            new _setters__WEBPACK_IMPORTED_MODULE_10__["default"](_repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_11__["default"], _repositories_ExperimentsRepository__WEBPACK_IMPORTED_MODULE_9__["default"]).prepareFlagsWithExperiments();
	                            return parser;
	                        }
	                    }, {
	                        key: 'isNewResponse',
	                        value: function isNewResponse(response) {
	                            return JSON.stringify(this.lastResponse) !== JSON.stringify(response);
	                        }
	                    }, {
	                        key: 'cacheURL',
	                        get: function get() {
	                            return this.rc && this.rc.cache_url;
	                        }
	                    }]);

	                    return ConfigurationFetcher;
	                }();
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = ConfigurationFetcher;

	                /***/
	            },
	            /* 57 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */FetcherResults: function FetcherResults() {
	                        return (/* binding */_FetcherResults
	                        );
	                    },
	                    /* harmony export */FetcherStatus: function FetcherStatus() {
	                        return (/* binding */_FetcherStatus
	                        );
	                    }
	                    /* harmony export */ });
	                var _FetcherStatus = {
	                    APPLIED_FROM_EMBEDDED: 'APPLIED_FROM_EMBEDDED',
	                    APPLIED_FROM_CACHE: 'APPLIED_FROM_CACHE',
	                    APPLIED_FROM_NETWORK: 'APPLIED_FROM_NETWORK',
	                    ERROR_FETCH_FAILED: 'ERROR_FETCH_FAILED'
	                };

	                var _FetcherResults = function _FetcherResults(fetcherStatus, creationDate, hasChanges, errorDetails, clientData) {
	                    _classCallCheck(this, _FetcherResults);

	                    this.fetcherStatus = fetcherStatus;
	                    this.creationDate = creationDate;
	                    this.hasChanges = hasChanges;
	                    this.errorDetails = errorDetails;
	                    this.clientData = clientData;
	                };

	                /***/
	            },
	            /* 58 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */buildRequestConfiguration: function buildRequestConfiguration() {
	                        return (/* binding */_buildRequestConfiguration
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
	                /* harmony import */var _Md5Generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);

	                var _buildRequestConfiguration = function _buildRequestConfiguration(_ref6) {
	                    var appKey = _ref6.appKey,
	                        deviceProperties = _ref6.deviceProperties,
	                        devModeSecret = _ref6.devModeSecret;

	                    var properties = deviceProperties.getProperties();
	                    properties.app_key = appKey;
	                    properties.buid = _Md5Generator__WEBPACK_IMPORTED_MODULE_0__.generateBuid(properties);
	                    properties.buid_generators_list = _Md5Generator__WEBPACK_IMPORTED_MODULE_0__.BUID_GENERATOR_LIST.join(',');
	                    properties.relative_url = appKey + '/' + properties.buid;
	                    properties.cache_url = '' + _config__WEBPACK_IMPORTED_MODULE_1__["default"].get('CD_S3_ENDPOINT') + properties.relative_url;
	                    properties.devModeSecret = devModeSecret;
	                    return properties;
	                };

	                /***/
	            },
	            /* 59 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */BUID_GENERATOR_LIST: function BUID_GENERATOR_LIST() {
	                        return (/* binding */_BUID_GENERATOR_LIST
	                        );
	                    },
	                    /* harmony export */STATE_GENERATOR_LIST: function STATE_GENERATOR_LIST() {
	                        return (/* binding */_STATE_GENERATOR_LIST
	                        );
	                    },
	                    /* harmony export */generateBuid: function generateBuid() {
	                        return (/* binding */_generateBuid
	                        );
	                    },
	                    /* harmony export */generateStateMd5: function generateStateMd5() {
	                        return (/* binding */_generateStateMd
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
	                /* harmony import */var md5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_0__);

	                var _BUID_GENERATOR_LIST = ['lib_version', 'api_version', 'platform', 'app_key', 'customSigningCertificate'];
	                var _STATE_GENERATOR_LIST = ['platform', 'app_key', 'feature_flags', 'custom_properties', 'devModeSecret'];
	                function generate() {
	                    var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	                    var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	                    var payload = generator_list.map(function (key) {
	                        var value = all_properties[key];
	                        if (!value) {
	                            return key;
	                        }
	                        if (value.constructor === Object || value.constructor === Array) {
	                            return JSON.stringify(value);
	                        }
	                        return value;
	                    });
	                    return md5__WEBPACK_IMPORTED_MODULE_0___default()(payload.join('|'));
	                }
	                function _generateStateMd() {
	                    var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	                    var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _STATE_GENERATOR_LIST;

	                    return generate(all_properties, generator_list);
	                }
	                function _generateBuid() {
	                    var all_properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	                    var generator_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _BUID_GENERATOR_LIST;

	                    return generate(all_properties, generator_list);
	                }

	                /***/
	            },
	            /* 60 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */fetchRemoteConfiguration: function fetchRemoteConfiguration() {
	                        return (/* binding */_fetchRemoteConfiguration
	                        );
	                    },
	                    /* harmony export */fetchRemoteConfigurationWithRoxy: function fetchRemoteConfigurationWithRoxy() {
	                        return (/* binding */_fetchRemoteConfigurationWithRoxy
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxAPI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
	                /* harmony import */var _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);

	                function catchRejection(request) {
	                    return request.catch(function (err) {
	                        err.message = 'Unable to fetch rox configuration!\n' + err.message;
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_0__["default"].error(err);
	                        throw err;
	                    });
	                }
	                function _fetchRemoteConfigurationWithRoxy(networkSender, properties, endpoint, networkOptions) {
	                    var apiRequestData = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_1__.buildAPIURL)(properties, endpoint);
	                    var request = (0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.fetchFromRoxyAPI)(networkSender, apiRequestData.url, networkOptions);
	                    return catchRejection(request);
	                }
	                function _fetchRemoteConfiguration(networkSender, properties, networkOptions) {
	                    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	                    var cache_url = properties.cache_url + '?distinct_id=' + properties.distinct_id + '&platform=' + properties.realPlatform + '&lib_version=' + properties.lib_version;
	                    if (options.selfManagedMode && !_config__WEBPACK_IMPORTED_MODULE_3__["default"].get('CD_S3_ENDPOINT')) {
	                        var apiRequestData = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_1__.buildAPIURL)(properties);
	                        return catchRejection((0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.fetchFromAPI)(networkSender, apiRequestData.url, apiRequestData.body, networkOptions));
	                    }
	                    var request = (0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.fetchFromCDN)(networkSender, cache_url, networkOptions).catch(function () {
	                        var apiRequestData = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_1__.buildAPIURL)(properties);
	                        return (0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.fetchFromAPI)(networkSender, apiRequestData.url, apiRequestData.body, networkOptions);
	                    });
	                    return catchRejection(request);
	                }

	                /***/
	            },
	            /* 61 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */buildAPIURL: function buildAPIURL() {
	                        return (/* binding */_buildAPIURL
	                        );
	                    },
	                    /* harmony export */buildSetStateAPIURL: function buildSetStateAPIURL() {
	                        return (/* binding */_buildSetStateAPIURL
	                        );
	                    },
	                    /* harmony export */buildSetStateS3URL: function buildSetStateS3URL() {
	                        return (/* binding */_buildSetStateS3URL
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
	                var __rest = function (s, e) {
	                    var t = {};
	                    for (var p in s) {
	                        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	                    }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	                    }
	                    return t;
	                };

	                var _buildAPIURL = function _buildAPIURL(properties) {
	                    var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	                    // Workaround for suspected Babel bug: there is no reason for these not to be declared as const (and they were in the
	                    // past). They are only declared as 'let' here to avoid an apparent Babel bug that in some circumstances inserts
	                    // a call to `_readOnlyError()` and a runtime TypeError "'n' is read-only". See SECO-2928.
	                    var app_key = properties.app_key,
	                        buid = properties.buid,
	                        relative_url = properties.relative_url,
	                        queryProps = __rest(properties, ["app_key", "buid", "relative_url"]);

	                    queryProps.cache_miss_relative_url = relative_url;
	                    var url = _config__WEBPACK_IMPORTED_MODULE_0__["default"].get('CD_API_ENDPOINT') + '/' + app_key + '/' + buid;
	                    return {
	                        url: endpoint || url,
	                        body: queryProps
	                    };
	                };
	                var _buildSetStateS3URL = function _buildSetStateS3URL(properties) {
	                    return '' + _config__WEBPACK_IMPORTED_MODULE_0__["default"].get('SS_S3_ENDPOINT') + properties.app_key + '/' + properties.md5;
	                };
	                var _buildSetStateAPIURL = function _buildSetStateAPIURL(properties) {
	                    var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	                    return {
	                        url: endpoint || '' + _config__WEBPACK_IMPORTED_MODULE_0__["default"].get('SS_API_ENDPOINT') + properties.app_key + '/' + properties.md5,
	                        body: {
	                            platform: properties.platform,
	                            feature_flags: properties.feature_flags,
	                            custom_properties: properties.custom_properties,
	                            devModeSecret: properties.devModeSecret
	                        }
	                    };
	                };

	                /***/
	            },
	            /* 62 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */fetchFromAPI: function fetchFromAPI() {
	                        return (/* binding */_fetchFromAPI
	                        );
	                    },
	                    /* harmony export */fetchFromCDN: function fetchFromCDN() {
	                        return (/* binding */_fetchFromCDN
	                        );
	                    },
	                    /* harmony export */fetchFromRoxyAPI: function fetchFromRoxyAPI() {
	                        return (/* binding */_fetchFromRoxyAPI
	                        );
	                    },
	                    /* harmony export */setStateToAPI: function setStateToAPI() {
	                        return (/* binding */_setStateToAPI
	                        );
	                    },
	                    /* harmony export */stateFromCDN: function stateFromCDN() {
	                        return (/* binding */_stateFromCDN
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _RoxLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

	                function _fetchFromCDN(network, url, req_opts) {
	                    var request = { url: url, options: req_opts };
	                    _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(request);
	                    return network.get(request.url, request.options).then(function (_ref7) {
	                        var data = _ref7.data,
	                            status = _ref7.status;

	                        if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
	                            if (data.result === 404) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed fetch from CDN, but it was missing');
	                                var error = new Error('missing from CDN');
	                                error.missing = true;
	                                return Promise.reject(error);
	                            }
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed fetch from CDN');
	                            return data;
	                        }
	                    }).catch(function (err) {
	                        if (err.missing || err.response && (err.response.status == 404 || err.response.status == 403)) {
	                            return Promise.reject();
	                        }
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Unexpected error calling get configuration, status code returned different from 403 or 404. error: ' + err);
	                        return;
	                    });
	                }
	                function processApiResponse(res) {
	                    var data = res.data,
	                        status = res.status;

	                    if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed fetch from API');
	                        return data;
	                    }
	                    return Promise.reject(new Error('Unexpected response from ROX API'));
	                }
	                function _fetchFromAPI(network, url, data, req_opts) {
	                    var request = { url: url, data: data, options: req_opts };
	                    _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(request);
	                    return network.post(request.url, request.data, request.options).then(processApiResponse);
	                }
	                function _fetchFromRoxyAPI(network, url, req_opts) {
	                    var request = { url: url, options: req_opts };
	                    _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(request);
	                    return network.get(request.url, request.options).then(processApiResponse);
	                }
	                function _stateFromCDN(network, url, req_opts) {
	                    var request = { url: url, options: req_opts };
	                    _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(request);
	                    return network.get(request.url, request.options).then(function (_ref8) {
	                        var data = _ref8.data,
	                            status = _ref8.status;

	                        if (status === 200 && data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
	                            if (data.result === 404) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed setState from CDN, but it was missing');
	                                var error = new Error('missing from CDN');
	                                error.missing = true;
	                                return Promise.reject(error);
	                            }
	                            if (data.result === 200) {
	                                _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed setState from CDN');
	                                return;
	                            }
	                        }
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed setState, but with unexpected response');
	                        return;
	                    }).catch(function (err) {
	                        if (err.missing || err.response && (err.response.status == 404 || err.response.status == 403)) {
	                            return Promise.reject();
	                        }
	                        _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('Unexpected error calling setState, status code returned different from 403 or 404. error: ' + err);
	                        return;
	                    });
	                }
	                function _setStateToAPI(network, url, data, req_opts) {
	                    var request = { url: url, data: data, options: req_opts };
	                    _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(request);
	                    return network.post(request.url, request.data, request.options).then(function (_ref9) {
	                        var status = _ref9.status;

	                        if (status === 200) {
	                            _RoxLogger__WEBPACK_IMPORTED_MODULE_1__["default"].debug('succeed setState from API');
	                            return;
	                        }
	                        return Promise.reject(new Error('Unexpected response from ROX API'));
	                    });
	                }

	                /***/
	            },
	            /* 63 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                var _data = void 0,
	                    _tmp = void 0;
	                try {
	                    /** @ts-ignore */
	                    _tmp = (void 0, $__ROX_EMBEDDED_CONTENT);
	                } catch (e) {
	                    //
	                }
	                if (_tmp && typeof _tmp === 'string') {
	                    try {
	                        _tmp = JSON.parse(_tmp);
	                    } catch (e) {
	                        _tmp = undefined;
	                    }
	                }
	                if (_tmp && _tmp.constructor === Object && _tmp.signed_date) {
	                    _data = _tmp;
	                }
	                /* harmony default export */var __WEBPACK_DEFAULT_EXPORT__ = _data;

	                /***/
	            },
	            /* 64 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _SetState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
	                /* harmony import */var _Md5Generator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59);
	                /* harmony import */var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
	                /* harmony import */var _RuntimeRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);

	                var StateSender = function () {
	                    function StateSender(appKey, deviceProperties, devModeSecret, networkOptions, options, disableSignatureVerification, networkSender) {
	                        _classCallCheck(this, StateSender);

	                        this.appKey = appKey;
	                        this.deviceProperties = deviceProperties;
	                        this.devModeSecret = devModeSecret;
	                        this.networkOptions = networkOptions;
	                        this.options = options;
	                        this.registry = new _RuntimeRegistry__WEBPACK_IMPORTED_MODULE_0__["default"](disableSignatureVerification);
	                        this.networkSender = networkSender;
	                    }

	                    _createClass(StateSender, [{
	                        key: 'send',
	                        value: function send() {
	                            ___WEBPACK_IMPORTED_MODULE_1__["default"].debug('check for cached state for appKey ' + this.appKey);
	                            var ssData = this.buildSetState();
	                            try {
	                                (0, _SetState__WEBPACK_IMPORTED_MODULE_2__.sendStateNetwork)(this.networkSender, ssData, this.networkOptions, this.options).catch(function (error) {
	                                    ___WEBPACK_IMPORTED_MODULE_1__["default"].error('failed to send state (promise)', error);
	                                });
	                            } catch (err) {
	                                ___WEBPACK_IMPORTED_MODULE_1__["default"].error('failed to send state', err);
	                            }
	                        }
	                    }, {
	                        key: 'sortItemsByName',
	                        value: function sortItemsByName(arr) {
	                            return arr.sort(function (item1, item2) {
	                                return item1.name > item2.name ? -1 : 1;
	                            });
	                        }
	                    }, {
	                        key: 'buildSetState',
	                        value: function buildSetState() {
	                            var properties = this.deviceProperties.getProperties();
	                            properties.app_key = this.appKey;
	                            properties.feature_flags = this.sortItemsByName(this.registry.featureFlags);
	                            properties.custom_properties = this.sortItemsByName(this.registry.customProperties);
	                            properties.devModeSecret = this.devModeSecret;
	                            properties.md5 = _Md5Generator__WEBPACK_IMPORTED_MODULE_3__.generateStateMd5(properties);
	                            return properties;
	                        }
	                    }]);

	                    return StateSender;
	                }();
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = StateSender;

	                /***/
	            },
	            /* 65 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */RoxRuntimeRegistry
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
	                /* harmony import */var _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
	                /* harmony import */var _entities_CustomProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);

	                var RoxRuntimeRegistry = function () {
	                    function RoxRuntimeRegistry() {
	                        var disableSignatureVerification = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

	                        _classCallCheck(this, RoxRuntimeRegistry);

	                        // this is a hack, as an indication to new platform
	                        // should be removed when this SDK should not support old CB FM
	                        this.includePlatformChanges = disableSignatureVerification;
	                    }

	                    _createClass(RoxRuntimeRegistry, [{
	                        key: 'customProperties',
	                        get: function get() {
	                            var _this13 = this;

	                            var cp = [];
	                            _repositories_CustomPropertyRepository__WEBPACK_IMPORTED_MODULE_0__["default"].items.forEach(function (customProperties) {
	                                if (customProperties.externalType !== _entities_CustomProperty__WEBPACK_IMPORTED_MODULE_1__["default"].dateTypeName || _this13.includePlatformChanges) {
	                                    var currentCustomProperty = {
	                                        name: customProperties.name,
	                                        externalType: customProperties.externalType
	                                    };
	                                    // can enable the if after https://cloudbees.atlassian.net/browse/SDP-6273
	                                    // can be completely removed when we stop support old CB FM
	                                    //if (!this.includePlatformChanges) {
	                                    currentCustomProperty.type = customProperties.type;
	                                    //}
	                                    cp.push(currentCustomProperty);
	                                }
	                            });
	                            return cp;
	                        }
	                    }, {
	                        key: 'featureFlags',
	                        get: function get() {
	                            var _this14 = this;

	                            var featureFlags = [];
	                            _repositories_RoxFlagRepository__WEBPACK_IMPORTED_MODULE_2__["default"].items.forEach(function (flag) {
	                                var currentFlag = {
	                                    name: flag.name,
	                                    defaultValue: flag.defaultValue,
	                                    options: flag._options
	                                };
	                                if (_this14.includePlatformChanges) {
	                                    currentFlag.externalType = flag.externalType;
	                                }
	                                featureFlags.push(currentFlag);
	                            });
	                            return featureFlags;
	                        }
	                    }]);

	                    return RoxRuntimeRegistry;
	                }();

	                /***/
	            },
	            /* 66 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */sendStateNetwork: function sendStateNetwork() {
	                        return (/* binding */_sendStateNetwork
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
	                /* harmony import */var _RoxAPI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);

	                function catchRejection(request) {
	                    return request.catch(function (err) {
	                        err.message = 'Unable to send state!\n' + err.message;
	                        throw err;
	                    });
	                }
	                function _sendStateNetwork(networkSender, properties, networkOptions) {
	                    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	                    var state_url = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_0__.buildSetStateS3URL)(properties);
	                    if (options.selfManagedMode && !_config__WEBPACK_IMPORTED_MODULE_1__["default"].get('SS_S3_ENDPOINT')) {
	                        var apiRequestData = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_0__.buildSetStateAPIURL)(properties);
	                        return catchRejection((0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.setStateToAPI)(networkSender, apiRequestData.url, apiRequestData.body, networkOptions));
	                    }
	                    var request = (0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.stateFromCDN)(networkSender, state_url, networkOptions).catch(function () {
	                        var apiRequestData = (0, _RoxAPI__WEBPACK_IMPORTED_MODULE_0__.buildSetStateAPIURL)(properties);
	                        return (0, _NetworkDispatcher__WEBPACK_IMPORTED_MODULE_2__.setStateToAPI)(networkSender, apiRequestData.url, apiRequestData.body, networkOptions);
	                    });
	                    return catchRejection(request);
	                }

	                /***/
	            },
	            /* 67 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return __WEBPACK_DEFAULT_EXPORT__;
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
	                /*
	                MIT License
	                Copyright  2017 Segment Inc. <friends@segment.com>
	                Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	                The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	                THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	                */

	                var setImmediate = function setImmediate(callback) {
	                    setTimeout(callback, 5);
	                };
	                var noop = function noop() {};

	                var Analytics = function () {
	                    /**
	                     * Initialize a new `Analytics` with your Segment project's `writeKey` and an
	                     * optional dictionary of `options`.
	                     *
	                     * @param {String} writeKey
	                     * @param {Object} [options] (optional)
	                     *   @property {Number} flushAt (default: 20)
	                     *   @property {Number} flushInterval (default: 10000)
	                     *   @property {String} host (default: 'https://api.segment.io')
	                     *   @property {Boolean} enable (default: true)
	                     * @param deviceProperties
	                     * @param networkOptions (axios options, see https://github.com/axios/axios#request-config)
	                     */
	                    function Analytics(writeKey, options, deviceProperties, networkOptions, networkSender) {
	                        _classCallCheck(this, Analytics);

	                        options = options || {};
	                        this.queue = [];
	                        this.writeKey = writeKey;
	                        this.host = options.host || _config__WEBPACK_IMPORTED_MODULE_0__["default"].get('ANALYTICS_ENDPOINT');
	                        this.timeout = options.timeout || false;
	                        this.flushAt = Math.max(options.flushAt || 20, 1);
	                        this.flushInterval = options.flushInterval || 10000;
	                        this.flushed = false;
	                        this.version = deviceProperties.getProperties().lib_version || '0.0';
	                        if (typeof deviceProperties.getProperties().platform === 'undefined') {
	                            throw new Error('Platform must be provided');
	                        }
	                        this.platform = deviceProperties.getProperties().platform || '';
	                        this.networkOptions = networkOptions;
	                        this.networkSender = networkSender;
	                        Object.defineProperty(this, 'enable', {
	                            configurable: false,
	                            writable: false,
	                            enumerable: true,
	                            value: typeof options.enable === 'boolean' ? options.enable : true
	                        });
	                    }
	                    /**
	                     * Send an identify `message`.
	                     *
	                     * @param {Object} message
	                     * @param {Function} [callback] (optional)
	                     * @return {Analytics}
	                     */


	                    _createClass(Analytics, [{
	                        key: 'identify',
	                        value: function identify(message, callback) {
	                            this.enqueue('identify', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Send a group `message`.
	                         *
	                         * @param {Object} message
	                         * @param {Function} [callback] (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'group',
	                        value: function group(message, callback) {
	                            this.enqueue('group', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Send a track `message`.
	                         *
	                         * @param {Object} message
	                         * @param {Function} [callback] (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'track',
	                        value: function track(message, callback) {
	                            this.enqueue('track', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Send a page `message`.
	                         *
	                         * @param {Object} message
	                         * @param {Function} [callback] (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'page',
	                        value: function page(message, callback) {
	                            this.enqueue('page', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Send a screen `message`.
	                         *
	                         * @param {Object} message
	                         * @param {Function} fn (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'screen',
	                        value: function screen(message, callback) {
	                            this.enqueue('screen', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Send an alias `message`.
	                         *
	                         * @param {Object} message
	                         * @param {Function} [callback] (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'alias',
	                        value: function alias(message, callback) {
	                            this.enqueue('alias', message, callback);
	                            return this;
	                        }
	                        /**
	                         * Add a `message` of type `type` to the queue and
	                         * check whether it should be flushed.
	                         *
	                         * @param {String} type
	                         * @param {Object} message
	                         * @param {Function} [callback] (optional)
	                         * @api private
	                         */

	                    }, {
	                        key: 'enqueue',
	                        value: function enqueue(type, message, callback) {
	                            callback = callback || noop;
	                            if (!this.enable) {
	                                return setImmediate(callback);
	                            }
	                            message = Object.assign({}, message);
	                            this.queue.push({ message: message, callback: callback });
	                            if (!this.flushed) {
	                                this.flushed = true;
	                                this.flush();
	                                return;
	                            }
	                            if (this.queue.length >= this.flushAt) {
	                                this.flush();
	                            }
	                            if (this.flushInterval && !this.timer) {
	                                this.timer = setTimeout(this.flush.bind(this), this.flushInterval);
	                            }
	                        }
	                        /**
	                         * Flush the current queue
	                         *
	                         * @param {Function} [callback] (optional)
	                         * @return {Analytics}
	                         */

	                    }, {
	                        key: 'flush',
	                        value: function flush(callback) {
	                            callback = callback || noop;
	                            if (!this.enable) {
	                                return setImmediate(callback);
	                            }
	                            if (this.timer) {
	                                clearTimeout(this.timer);
	                                this.timer = null;
	                            }
	                            if (!this.queue.length) {
	                                return setImmediate(callback);
	                            }
	                            var items = this.queue.splice(0, this.flushAt);
	                            var callbacks = items.map(function (item) {
	                                return item.callback;
	                            });
	                            var messages = items.map(function (item) {
	                                return item.message;
	                            });
	                            var data = {
	                                analyticsVersion: '1.0.0',
	                                sdkVersion: this.version,
	                                time: new Date().getTime(),
	                                platform: this.platform,
	                                rolloutKey: this.writeKey,
	                                events: messages
	                            };
	                            var done = function done(err) {
	                                callbacks.forEach(function (callback) {
	                                    return callback(err);
	                                });
	                                callback(err, data);
	                            };
	                            var url = this.host + '/impression/' + this.writeKey;
	                            var reqOptions = {
	                                // might use ...networkOptions if need more options
	                                httpsAgent: this.networkOptions.httpsAgent,
	                                httpAgent: this.networkOptions.httpAgent
	                            };
	                            if (this.timeout) {
	                                reqOptions.timeout = this.timeout;
	                            }
	                            var req = { url: url, data: data, options: reqOptions };
	                            _config__WEBPACK_IMPORTED_MODULE_0__["default"].getProxy().applyProxyToRequest(req);
	                            this.networkSender.post(req.url, req.data, req.options).then(function () {
	                                return done();
	                            }).catch(function (err) {
	                                if (err.response) {
	                                    var error = new Error(err.response.statusText);
	                                    return done(error);
	                                }
	                                done(err);
	                            });
	                        }
	                    }]);

	                    return Analytics;
	                }();
	                /* harmony default export */

	                var __WEBPACK_DEFAULT_EXPORT__ = Analytics;

	                /***/
	            },
	            /* 68 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */FetchNetwork: function FetchNetwork() {
	                        return (/* binding */_FetchNetwork
	                        );
	                    },
	                    /* harmony export */HttpResponse: function HttpResponse() {
	                        return (/* binding */_HttpResponse
	                        );
	                    }
	                    /* harmony export */ });
	                var __rest = function (s, e) {
	                    var t = {};
	                    for (var p in s) {
	                        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	                    }if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	                    }
	                    return t;
	                };
	                // on node Fetch api is only stable since v21
	                // for browser some old browsers might not support it (window.fetch)
	                // Response and Request are part of the Fetch api
	                // we can use those as base when we stop supporting old stuff

	                var _HttpResponse = function _HttpResponse(status, data, headers) {
	                    _classCallCheck(this, _HttpResponse);

	                    this.status = status;
	                    this.data = data;
	                    this.headers = headers;
	                };
	                // currently the Fetch implemetation accept the window.fetch function
	                // assume the request options is in the AxiosRequest.options structure
	                // and uses only what it need
	                // then return the custom response we created, that should match AxiosResponse


	                var _FetchNetwork = function () {
	                    function _FetchNetwork(fetch) {
	                        _classCallCheck(this, _FetchNetwork);

	                        this.fetch = fetch;
	                    }

	                    _createClass(_FetchNetwork, [{
	                        key: 'get',
	                        value: function get(url, options) {
	                            var requestOptions = Object.assign({ method: 'GET' }, options);
	                            // TODO: handle options.params if need proxy
	                            return this.fetch(url, requestOptions).then(this.handleFetch);
	                        }
	                        // currently always sending json (the Content-Type forces a preflight request)

	                    }, {
	                        key: 'post',
	                        value: function post(url, data, options) {
	                            var headers = options.headers,
	                                headerlessOptions = __rest(options, ["headers"]);
	                            var requestOptions = Object.assign({ method: 'POST', body: JSON.stringify(data), headers: Object.assign({ 'Content-Type': 'application/json' }, headers) }, headerlessOptions);
	                            // TODO: handle options.params if need proxy
	                            return this.fetch(url, requestOptions).then(this.handleFetch);
	                        }
	                    }, {
	                        key: 'handleFetch',
	                        value: function handleFetch(res) {
	                            // axios throw on non-ok status, fetch does not
	                            // for now we force fetch to behave like Axios, to prevent doing changes in the calling code
	                            if (!res.ok) {
	                                var error = new Error('network returned non 2xx response');
	                                error.response = res;
	                                return Promise.reject(error);
	                            }
	                            var contentType = res.headers.get('content-type');
	                            if (contentType && contentType.indexOf('application/json') !== -1) {
	                                // return json response
	                                return res.json().then(function (jsonRes) {
	                                    return new _HttpResponse(res.status, jsonRes, res.headers);
	                                });
	                            } else {
	                                // return plan text response
	                                return res.text().then(function (textRes) {
	                                    return new _HttpResponse(res.status, textRes, res.headers);
	                                });
	                            }
	                        }
	                    }]);

	                    return _FetchNetwork;
	                }();

	                /***/
	            },
	            /* 69 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */AxiosNetwork: function AxiosNetwork() {
	                        return (/* binding */_AxiosNetwork
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
	                /* harmony import */var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
	                /* harmony import */var _NetworkSender__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
	                // from what i understand, old browsers does not support dynamic import
	                // so no point in making axios an optionalDependency (might be wrong)


	                var _AxiosNetwork = function () {
	                    function _AxiosNetwork() {
	                        _classCallCheck(this, _AxiosNetwork);
	                    }

	                    _createClass(_AxiosNetwork, [{
	                        key: 'get',
	                        value: function get(url, options) {
	                            return axios__WEBPACK_IMPORTED_MODULE_0___default().get(url, options).then(function (res) {
	                                return new _NetworkSender__WEBPACK_IMPORTED_MODULE_1__.HttpResponse(res.status, res.data, res.headers);
	                            });
	                        }
	                    }, {
	                        key: 'post',
	                        value: function post(url, data, options) {
	                            return axios__WEBPACK_IMPORTED_MODULE_0___default().post(url, data, options).then(function (res) {
	                                return new _NetworkSender__WEBPACK_IMPORTED_MODULE_1__.HttpResponse(res.status, res.data, res.headers);
	                            });
	                        }
	                    }]);

	                    return _AxiosNetwork;
	                }();

	                /***/
	            },
	            /* 70 */
	            /***/function (module) {

	                module.exports = __WEBPACK_EXTERNAL_MODULE__70__;

	                /***/
	            },
	            /* 71 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */NotificationListener
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _lib___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
	                var EventSource = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.EventSource;

	                var NotificationListener = function () {
	                    function NotificationListener(listenUrl, app_key, eventSourceImpl, networkOptions) {
	                        _classCallCheck(this, NotificationListener);

	                        var sseUrl = '' + listenUrl + (listenUrl.endsWith('/') ? '' : '/') + app_key;
	                        _lib___WEBPACK_IMPORTED_MODULE_0__["default"].info('Starting push notification listener to ' + sseUrl);
	                        var request = { url: sseUrl, options: networkOptions };
	                        _config__WEBPACK_IMPORTED_MODULE_1__["default"].getProxy().applyProxyToSseRequest(request);
	                        if (eventSourceImpl) {
	                            this.eventSource = new eventSourceImpl(request.url, request.options);
	                        } else if (EventSource) {
	                            this.eventSource = new EventSource(request.url);
	                        }
	                    }

	                    _createClass(NotificationListener, [{
	                        key: 'on',
	                        value: function on(eventName, handler) {
	                            if (this.eventSource) {
	                                this.eventSource.addEventListener(eventName, function (event) {
	                                    try {
	                                        handler(event);
	                                    } catch (e) {
	                                        //
	                                    }
	                                });
	                            }
	                        }
	                    }, {
	                        key: 'stop',
	                        value: function stop() {
	                            if (this.eventSource) {
	                                this.eventSource.close();
	                            }
	                        }
	                    }]);

	                    return NotificationListener;
	                }();

	                /***/
	            },
	            /* 72 */
	            /***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */"default": function _default() {
	                        return (/* binding */DynamicApi
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);

	                var DynamicApi = function () {
	                    // the flag repository is kind of a statis/singleton, but that's bad for testing
	                    // please follow the move-as-parameter design
	                    // AKA (https://en.wikipedia.org/wiki/Dependency_injection)
	                    function DynamicApi(entityProvider, flagRepository, client) {
	                        _classCallCheck(this, DynamicApi);

	                        this.entityProvider = entityProvider;
	                        this.flagRepository = flagRepository;
	                        this.client = client;
	                    }

	                    _createClass(DynamicApi, [{
	                        key: 'genericValue',
	                        value: function genericValue(name, defaultValue, variations, context) {
	                            var callFlagType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _entities__WEBPACK_IMPORTED_MODULE_0__.FlagTypes.string;
	                            var createFunction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.entityProvider.createString;
	                            var normalizeFunction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : _entities__WEBPACK_IMPORTED_MODULE_0__["default"]._normalizeString;

	                            if (typeof name !== 'string') {
	                                throw new Error('DynamicApi error - name must be a string');
	                            }
	                            if ((typeof defaultValue === 'undefined' ? 'undefined' : _typeof(defaultValue)) !== callFlagType) {
	                                throw new Error('DynamicApi default value must be of ' + callFlagType + ' type. Received \'' + defaultValue + '\'');
	                            }
	                            var variant = this.flagRepository.flagWithName(name);
	                            if (!variant) {
	                                variant = createFunction(defaultValue, variations);
	                                this.flagRepository.addFlag(name, variant);
	                                this.client.sendStateDebounced();
	                            }
	                            // a string request is always fine, otherwise, validating the request type matches the flag type
	                            //if (callFlagType !== FlagTypes.string && variant._type !== callFlagType) {
	                            //  return defaultValue;
	                            //}
	                            var callContext = { alternativeDefaultValue: defaultValue.toString() };
	                            variant.getInternalValue(callContext, context);
	                            var finalValue = normalizeFunction(callContext.result.value);
	                            if (!callContext.result.isFreezed && !callContext.result.isOverride) {
	                                variant._flagImpression(finalValue.toString(), callContext.result.usedContext);
	                            }
	                            return finalValue;
	                        }
	                    }, {
	                        key: 'isEnabled',
	                        value: function isEnabled(name, defaultValue, context) {
	                            return this.genericValue(name, defaultValue, null, context, _entities__WEBPACK_IMPORTED_MODULE_0__.FlagTypes.boolean, this.entityProvider.createFlag, _entities__WEBPACK_IMPORTED_MODULE_0__["default"]._normalizeBoolean);
	                        }
	                    }, {
	                        key: 'value',
	                        value: function value(name, defaultValue, variations, context) {
	                            // overload handling
	                            if (!Array.isArray(variations)) {
	                                context = variations;
	                                variations = null;
	                            }
	                            return this.genericValue(name, defaultValue, variations, context);
	                        }
	                    }, {
	                        key: 'getNumber',
	                        value: function getNumber(name, defaultValue, variations, context) {
	                            // overload handling
	                            if (!Array.isArray(variations)) {
	                                context = variations;
	                                variations = null;
	                            }
	                            return this.genericValue(name, defaultValue, variations, context, _entities__WEBPACK_IMPORTED_MODULE_0__.FlagTypes.number, this.entityProvider.createNumber, _entities__WEBPACK_IMPORTED_MODULE_0__["default"]._normalizeNumber);
	                        }
	                    }]);

	                    return DynamicApi;
	                }();

	                /***/
	            }];
	            /************************************************************************/
	            /******/ // The module cache
	            /******/var __webpack_module_cache__ = {};
	            /******/
	            /******/ // The require function
	            /******/function __webpack_require__(moduleId) {
	                /******/ // Check if module is in cache
	                /******/var cachedModule = __webpack_module_cache__[moduleId];
	                /******/if (cachedModule !== undefined) {
	                    /******/return cachedModule.exports;
	                    /******/
	                }
	                /******/ // Create a new module (and put it into the cache)
	                /******/var module = __webpack_module_cache__[moduleId] = {
	                    /******/ // no module.id needed
	                    /******/ // no module.loaded needed
	                    /******/exports: {}
	                    /******/ };
	                /******/
	                /******/ // Execute the module function
	                /******/__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
	                /******/
	                /******/ // Return the exports of the module
	                /******/return module.exports;
	                /******/
	            }
	            /******/
	            /************************************************************************/
	            /******/ /* webpack/runtime/compat get default export */
	            /******/(function () {
	                /******/ // getDefaultExport function for compatibility with non-harmony modules
	                /******/__webpack_require__.n = function (module) {
	                    /******/var getter = module && module.__esModule ?
	                    /******/function () {
	                        return module['default'];
	                    } :
	                    /******/function () {
	                        return module;
	                    };
	                    /******/__webpack_require__.d(getter, { a: getter });
	                    /******/return getter;
	                    /******/
	                };
	                /******/
	            })();
	            /******/
	            /******/ /* webpack/runtime/define property getters */
	            /******/(function () {
	                /******/ // define getter functions for harmony exports
	                /******/__webpack_require__.d = function (exports, definition) {
	                    /******/for (var key in definition) {
	                        /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
	                            /******/Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
	                            /******/
	                        }
	                        /******/
	                    }
	                    /******/
	                };
	                /******/
	            })();
	            /******/
	            /******/ /* webpack/runtime/hasOwnProperty shorthand */
	            /******/(function () {
	                /******/__webpack_require__.o = function (obj, prop) {
	                    return Object.prototype.hasOwnProperty.call(obj, prop);
	                };
	                /******/
	            })();
	            /******/
	            /******/ /* webpack/runtime/make namespace object */
	            /******/(function () {
	                /******/ // define __esModule on exports
	                /******/__webpack_require__.r = function (exports) {
	                    /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	                        /******/Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	                        /******/
	                    }
	                    /******/Object.defineProperty(exports, '__esModule', { value: true });
	                    /******/
	                };
	                /******/
	            })();
	            /******/
	            /************************************************************************/
	            var __webpack_exports__ = {};
	            // This entry need to be wrapped in an IIFE because it need to be in strict mode.
	            (function () {

	                __webpack_require__.r(__webpack_exports__);
	                /* harmony export */__webpack_require__.d(__webpack_exports__, {
	                    /* harmony export */Client: function Client() {
	                        return (/* reexport safe */_lib_Client__WEBPACK_IMPORTED_MODULE_8__.Client
	                        );
	                    },
	                    /* harmony export */Config: function Config() {
	                        return (/* reexport safe */_config__WEBPACK_IMPORTED_MODULE_0__["default"]
	                        );
	                    },
	                    /* harmony export */ConfigurationParser: function ConfigurationParser() {
	                        return (/* reexport safe */_lib__WEBPACK_IMPORTED_MODULE_13__["default"]
	                        );
	                    },
	                    /* harmony export */Context: function Context() {
	                        return (/* reexport module object */_context__WEBPACK_IMPORTED_MODULE_5__
	                        );
	                    },
	                    /* harmony export */DeviceProperties: function DeviceProperties() {
	                        return (/* reexport safe */_lib_DeviceProperties__WEBPACK_IMPORTED_MODULE_6__["default"]
	                        );
	                    },
	                    /* harmony export */DynamicApi: function DynamicApi() {
	                        return (/* reexport safe */_lib__WEBPACK_IMPORTED_MODULE_12__["default"]
	                        );
	                    },
	                    /* harmony export */Entities: function Entities() {
	                        return (/* reexport module object */_entities__WEBPACK_IMPORTED_MODULE_1__
	                        );
	                    },
	                    /* harmony export */Experiments: function Experiments() {
	                        return (/* reexport safe */_lib__WEBPACK_IMPORTED_MODULE_10__["default"]
	                        );
	                    },
	                    /* harmony export */Flags: function Flags() {
	                        return (/* reexport safe */_lib__WEBPACK_IMPORTED_MODULE_9__["default"]
	                        );
	                    },
	                    /* harmony export */FlagsSetter: function FlagsSetter() {
	                        return (/* reexport safe */_lib__WEBPACK_IMPORTED_MODULE_14__["default"]
	                        );
	                    },
	                    /* harmony export */Parsers: function Parsers() {
	                        return (/* reexport module object */_parsers__WEBPACK_IMPORTED_MODULE_2__
	                        );
	                    },
	                    /* harmony export */Repositories: function Repositories() {
	                        return (/* reexport module object */_repositories__WEBPACK_IMPORTED_MODULE_4__
	                        );
	                    },
	                    /* harmony export */RoxLogger: function RoxLogger() {
	                        return (/* reexport safe */_lib_RoxLogger__WEBPACK_IMPORTED_MODULE_7__["default"]
	                        );
	                    },
	                    /* harmony export */Setters: function Setters() {
	                        return (/* reexport module object */_setters__WEBPACK_IMPORTED_MODULE_3__
	                        );
	                    },
	                    /* harmony export */TargetGroups: function TargetGroups() {
	                        return (/* reexport safe */_repositories__WEBPACK_IMPORTED_MODULE_11__["default"]
	                        );
	                    },
	                    /* harmony export */createRoxClient: function createRoxClient() {
	                        return (/* reexport safe */_lib_Client__WEBPACK_IMPORTED_MODULE_8__.createRoxClient
	                        );
	                    },
	                    /* harmony export */flagValue: function flagValue() {
	                        return (/* reexport safe */_lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_15__.flagValue
	                        );
	                    }
	                    /* harmony export */ });
	                /* harmony import */var _setters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);
	                /* harmony import */var _parsers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
	                /* harmony import */var _entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
	                /* harmony import */var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);
	                /* harmony import */var _lib_DeviceProperties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(38);
	                /* harmony import */var _lib_RoxLogger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);
	                /* harmony import */var _lib_Client__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39);
	                /* harmony import */var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
	                /* harmony import */var _lib_RoxxOperators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(18);
	                /* harmony import */var _lib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(23);
	                /* harmony import */var _lib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14);
	                /* harmony import */var _lib__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(72);
	                /* harmony import */var _lib__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(30);
	                /* harmony import */var _lib__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(24);
	                /* harmony import */var _repositories__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(25);
	            })();

	            /******/return __webpack_exports__;
	            /******/
	        }()
	    );
	});
	
} (roxBase, roxBase.exports));

var dist = {};

var v1$1 = {};

var rng$1 = {};

Object.defineProperty(rng$1, "__esModule", {
  value: true
});
rng$1.default = rng;

var _crypto$2 = _interopRequireDefault$7(require$$0__default$3["default"]);

function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rng() {
  return _crypto$2.default.randomBytes(16);
}

var bytesToUuid$1 = {};

Object.defineProperty(bytesToUuid$1, "__esModule", {
  value: true
});
bytesToUuid$1.default = void 0;

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

var _default$7 = bytesToUuid;
bytesToUuid$1.default = _default$7;

Object.defineProperty(v1$1, "__esModule", {
  value: true
});
v1$1.default = void 0;

var _rng$1 = _interopRequireDefault$6(rng$1);

var _bytesToUuid$2 = _interopRequireDefault$6(bytesToUuid$1);

function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng$1.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : (0, _bytesToUuid$2.default)(b);
}

var _default$6 = v1;
v1$1.default = _default$6;

var v3$1 = {};

var v35 = {};

Object.defineProperty(v35, "__esModule", {
  value: true
});
v35.default = _default$5;
v35.URL = v35.DNS = void 0;

var _bytesToUuid$1 = _interopRequireDefault$5(bytesToUuid$1);

function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = new Array(str.length);

  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
v35.DNS = DNS;
const URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
v35.URL = URL$1;

function _default$5(name, version, hashfunc) {
  var generateUUID = function (value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == 'string') value = stringToBytes(value);
    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || (0, _bytesToUuid$1.default)(bytes);
  }; // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name;
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}

var md5$1 = {};

Object.defineProperty(md5$1, "__esModule", {
  value: true
});
md5$1.default = void 0;

var _crypto$1 = _interopRequireDefault$4(require$$0__default$3["default"]);

function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto$1.default.createHash('md5').update(bytes).digest();
}

var _default$4 = md5;
md5$1.default = _default$4;

Object.defineProperty(v3$1, "__esModule", {
  value: true
});
v3$1.default = void 0;

var _v$1 = _interopRequireDefault$3(v35);

var _md = _interopRequireDefault$3(md5$1);

function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v$1.default)('v3', 0x30, _md.default);
var _default$3 = v3;
v3$1.default = _default$3;

var v4$2 = {};

Object.defineProperty(v4$2, "__esModule", {
  value: true
});
v4$2.default = void 0;

var _rng = _interopRequireDefault$2(rng$1);

var _bytesToUuid = _interopRequireDefault$2(bytesToUuid$1);

function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4$1(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};

  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || (0, _bytesToUuid.default)(rnds);
}

var _default$2 = v4$1;
v4$2.default = _default$2;

var v5$1 = {};

var sha1$1 = {};

Object.defineProperty(sha1$1, "__esModule", {
  value: true
});
sha1$1.default = void 0;

var _crypto = _interopRequireDefault$1(require$$0__default$3["default"]);

function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default$1 = sha1;
sha1$1.default = _default$1;

Object.defineProperty(v5$1, "__esModule", {
  value: true
});
v5$1.default = void 0;

var _v = _interopRequireDefault(v35);

var _sha = _interopRequireDefault(sha1$1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
v5$1.default = _default;

(function (exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "v1", {
	  enumerable: true,
	  get: function () {
	    return _v.default;
	  }
	});
	Object.defineProperty(exports, "v3", {
	  enumerable: true,
	  get: function () {
	    return _v2.default;
	  }
	});
	Object.defineProperty(exports, "v4", {
	  enumerable: true,
	  get: function () {
	    return _v3.default;
	  }
	});
	Object.defineProperty(exports, "v5", {
	  enumerable: true,
	  get: function () {
	    return _v4.default;
	  }
	});

	var _v = _interopRequireDefault(v1$1);

	var _v2 = _interopRequireDefault(v3$1);

	var _v3 = _interopRequireDefault(v4$2);

	var _v4 = _interopRequireDefault(v5$1);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
} (dist));

var uuid = /*@__PURE__*/getDefaultExportFromCjs(dist);

uuid.v1;
uuid.v3;
const v4 = uuid.v4;
uuid.v5;

var version = "5.4.12";
var ROX = {
	api_version: "1.9.0"
};

var Manifest = {
  api_version: ROX.api_version,
  lib_version: version
};

var _createClass$7 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RoxCache = function () {
  function RoxCache() {
    _classCallCheck$7(this, RoxCache);
  }

  _createClass$7(RoxCache, [{
    key: "set",
    value: function set() {}
  }, {
    key: "get",
    value: function get() {}
  }]);

  return RoxCache;
}();

var RoxCache$1 = new RoxCache();

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var api_version = Manifest.api_version,
    lib_version = Manifest.lib_version;

var DeviceProperties = function (_RoxBase$DeviceProper) {
  _inherits$3(DeviceProperties, _RoxBase$DeviceProper);

  function DeviceProperties() {
    _classCallCheck$6(this, DeviceProperties);

    return _possibleConstructorReturn$3(this, (DeviceProperties.__proto__ || Object.getPrototypeOf(DeviceProperties)).apply(this, arguments));
  }

  _createClass$6(DeviceProperties, [{
    key: 'getNodeVersion',
    value: function getNodeVersion() {
      return process && process.versions && process.versions.node;
    }
  }, {
    key: 'getProperties',
    value: function getProperties() {
      var distinct_id = this.distinct_id,
          app_release = this.app_release,
          platform = this.platform,
          realPlatform = this.realPlatform;

      return {
        app_release: app_release,
        api_version: api_version,
        lib_version: lib_version,
        distinct_id: distinct_id,
        platform: platform,
        realPlatform: realPlatform,
        platformVersion: this.getNodeVersion(),
        customSigningCertificate: '5659eb0ca47811395ef85f0b09be63b7',
        anticache: +Date.now()
      };
    }
  }]);

  return DeviceProperties;
}(roxBase.exports.DeviceProperties);

var DeviceProperties$1 = new DeviceProperties(RoxCache$1, v4);

var parse = require$$0__default$1["default"].parse;
var events = require$$9__default["default"];
var https = require$$4__default["default"];
var http = require$$3__default["default"];
var util = require$$1__default["default"];

var httpsOptions = [
  'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers',
  'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'
];

var bom = [239, 187, 191];
var colon = 58;
var space = 32;
var lineFeed = 10;
var carriageReturn = 13;
// Beyond 256KB we could not observe any gain in performance
var maxBufferAheadAllocation = 1024 * 256;
// Headers matching the pattern should be removed when redirecting to different origin
var reUnsafeHeader = /^(cookie|authorization)$/i;

function hasBom (buf) {
  return bom.every(function (charCode, index) {
    return buf[index] === charCode
  })
}

/**
 * Creates a new EventSource object
 *
 * @param {String} url the URL to which to connect
 * @param {Object} [eventSourceInitDict] extra init params. See README for details.
 * @api public
 **/
function EventSource (url, eventSourceInitDict) {
  var readyState = EventSource.CONNECTING;
  var headers = eventSourceInitDict && eventSourceInitDict.headers;
  var hasNewOrigin = false;
  Object.defineProperty(this, 'readyState', {
    get: function () {
      return readyState
    }
  });

  Object.defineProperty(this, 'url', {
    get: function () {
      return url
    }
  });

  var self = this;
  self.reconnectInterval = 1000;
  self.connectionInProgress = false;

  function onConnectionClosed (message) {
    if (readyState === EventSource.CLOSED) return
    readyState = EventSource.CONNECTING;
    _emit('error', new Event('error', {message: message}));

    // The url may have been changed by a temporary redirect. If that's the case,
    // revert it now, and flag that we are no longer pointing to a new origin
    if (reconnectUrl) {
      url = reconnectUrl;
      reconnectUrl = null;
      hasNewOrigin = false;
    }
    setTimeout(function () {
      if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {
        return
      }
      self.connectionInProgress = true;
      connect();
    }, self.reconnectInterval);
  }

  var req;
  var lastEventId = '';
  if (headers && headers['Last-Event-ID']) {
    lastEventId = headers['Last-Event-ID'];
    delete headers['Last-Event-ID'];
  }

  var discardTrailingNewline = false;
  var data = '';
  var eventName = '';

  var reconnectUrl = null;

  function connect () {
    var options = parse(url);
    var isSecure = options.protocol === 'https:';
    options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' };
    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId;
    if (headers) {
      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
      for (var i in reqHeaders) {
        var header = reqHeaders[i];
        if (header) {
          options.headers[i] = header;
        }
      }
    }

    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,
    // but for now exists as a backwards-compatibility layer
    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);

    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {
      options.createConnection = eventSourceInitDict.createConnection;
    }

    // If specify http proxy, make the request to sent to the proxy server,
    // and include the original url in path and Host headers
    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
    if (useProxy) {
      var proxy = parse(eventSourceInitDict.proxy);
      isSecure = proxy.protocol === 'https:';

      options.protocol = isSecure ? 'https:' : 'http:';
      options.path = url;
      options.headers.Host = options.host;
      options.hostname = proxy.hostname;
      options.host = proxy.host;
      options.port = proxy.port;
    }

    // If https options are specified, merge them into the request options
    if (eventSourceInitDict && eventSourceInitDict.https) {
      for (var optName in eventSourceInitDict.https) {
        if (httpsOptions.indexOf(optName) === -1) {
          continue
        }

        var option = eventSourceInitDict.https[optName];
        if (option !== undefined) {
          options[optName] = option;
        }
      }
    }

    // Pass this on to the XHR
    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {
      options.withCredentials = eventSourceInitDict.withCredentials;
    }

    req = (isSecure ? https : http).request(options, function (res) {
      self.connectionInProgress = false;
      // Handle HTTP errors
      if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}));
        onConnectionClosed();
        return
      }

      // Handle HTTP redirects
      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
        var location = res.headers.location;
        if (!location) {
          // Server sent redirect response without Location header.
          _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}));
          return
        }
        var prevOrigin = new URL(url).origin;
        var nextOrigin = new URL(location).origin;
        hasNewOrigin = prevOrigin !== nextOrigin;
        if (res.statusCode === 307) reconnectUrl = url;
        url = location;
        process.nextTick(connect);
        return
      }

      if (res.statusCode !== 200) {
        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}));
        return self.close()
      }

      readyState = EventSource.OPEN;
      res.on('close', function () {
        res.removeAllListeners('close');
        res.removeAllListeners('end');
        onConnectionClosed();
      });

      res.on('end', function () {
        res.removeAllListeners('close');
        res.removeAllListeners('end');
        onConnectionClosed();
      });
      _emit('open', new Event('open'));

      // text/event-stream parser adapted from webkit's
      // Source/WebCore/page/EventSource.cpp
      var buf;
      var newBuffer;
      var startingPos = 0;
      var startingFieldLength = -1;
      var newBufferSize = 0;
      var bytesUsed = 0;

      res.on('data', function (chunk) {
        if (!buf) {
          buf = chunk;
          if (hasBom(buf)) {
            buf = buf.slice(bom.length);
          }
          bytesUsed = buf.length;
        } else {
          if (chunk.length > buf.length - bytesUsed) {
            newBufferSize = (buf.length * 2) + chunk.length;
            if (newBufferSize > maxBufferAheadAllocation) {
              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;
            }
            newBuffer = Buffer.alloc(newBufferSize);
            buf.copy(newBuffer, 0, 0, bytesUsed);
            buf = newBuffer;
          }
          chunk.copy(buf, bytesUsed);
          bytesUsed += chunk.length;
        }

        var pos = 0;
        var length = bytesUsed;

        while (pos < length) {
          if (discardTrailingNewline) {
            if (buf[pos] === lineFeed) {
              ++pos;
            }
            discardTrailingNewline = false;
          }

          var lineLength = -1;
          var fieldLength = startingFieldLength;
          var c;

          for (var i = startingPos; lineLength < 0 && i < length; ++i) {
            c = buf[i];
            if (c === colon) {
              if (fieldLength < 0) {
                fieldLength = i - pos;
              }
            } else if (c === carriageReturn) {
              discardTrailingNewline = true;
              lineLength = i - pos;
            } else if (c === lineFeed) {
              lineLength = i - pos;
            }
          }

          if (lineLength < 0) {
            startingPos = length - pos;
            startingFieldLength = fieldLength;
            break
          } else {
            startingPos = 0;
            startingFieldLength = -1;
          }

          parseEventStreamLine(buf, pos, fieldLength, lineLength);

          pos += lineLength + 1;
        }

        if (pos === length) {
          buf = void 0;
          bytesUsed = 0;
        } else if (pos > 0) {
          buf = buf.slice(pos, bytesUsed);
          bytesUsed = buf.length;
        }
      });
    });

    req.on('error', function (err) {
      self.connectionInProgress = false;
      onConnectionClosed(err.message);
    });

    if (req.setNoDelay) req.setNoDelay(true);
    req.end();
  }

  connect();

  function _emit () {
    if (self.listeners(arguments[0]).length > 0) {
      self.emit.apply(self, arguments);
    }
  }

  this._close = function () {
    if (readyState === EventSource.CLOSED) return
    readyState = EventSource.CLOSED;
    if (req.abort) req.abort();
    if (req.xhr && req.xhr.abort) req.xhr.abort();
  };

  function parseEventStreamLine (buf, pos, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        var type = eventName || 'message';
        _emit(type, new MessageEvent(type, {
          data: data.slice(0, -1), // remove trailing newline
          lastEventId: lastEventId,
          origin: new URL(url).origin
        }));
        data = '';
      }
      eventName = void 0;
    } else if (fieldLength > 0) {
      var noValue = fieldLength < 0;
      var step = 0;
      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();

      if (noValue) {
        step = lineLength;
      } else if (buf[pos + fieldLength + 1] !== space) {
        step = fieldLength + 1;
      } else {
        step = fieldLength + 2;
      }
      pos += step;

      var valueLength = lineLength - step;
      var value = buf.slice(pos, pos + valueLength).toString();

      if (field === 'data') {
        data += value + '\n';
      } else if (field === 'event') {
        eventName = value;
      } else if (field === 'id') {
        lastEventId = value;
      } else if (field === 'retry') {
        var retry = parseInt(value, 10);
        if (!Number.isNaN(retry)) {
          self.reconnectInterval = retry;
        }
      }
    }
  }
}

var eventsource = EventSource;

util.inherits(EventSource, events.EventEmitter);
EventSource.prototype.constructor = EventSource; // make stacktraces readable

['open', 'error', 'message'].forEach(function (method) {
  Object.defineProperty(EventSource.prototype, 'on' + method, {
    /**
     * Returns the current listener
     *
     * @return {Mixed} the set function or undefined
     * @api private
     */
    get: function get () {
      var listener = this.listeners(method)[0];
      return listener ? (listener._listener ? listener._listener : listener) : undefined
    },

    /**
     * Start listening for events
     *
     * @param {Function} listener the listener
     * @return {Mixed} the set function or undefined
     * @api private
     */
    set: function set (listener) {
      this.removeAllListeners(method);
      this.addEventListener(method, listener);
    }
  });
});

/**
 * Ready states
 */
Object.defineProperty(EventSource, 'CONNECTING', {enumerable: true, value: 0});
Object.defineProperty(EventSource, 'OPEN', {enumerable: true, value: 1});
Object.defineProperty(EventSource, 'CLOSED', {enumerable: true, value: 2});

EventSource.prototype.CONNECTING = 0;
EventSource.prototype.OPEN = 1;
EventSource.prototype.CLOSED = 2;

/**
 * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close
 * @api public
 */
EventSource.prototype.close = function () {
  this._close();
};

/**
 * Emulates the W3C Browser based WebSocket interface using addEventListener.
 *
 * @param {String} type A string representing the event type to listen out for
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.addEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */
EventSource.prototype.addEventListener = function addEventListener (type, listener) {
  if (typeof listener === 'function') {
    // store a reference so we can return the original function again
    listener._listener = listener;
    this.on(type, listener);
  }
};

/**
 * Emulates the W3C Browser based WebSocket interface using dispatchEvent.
 *
 * @param {Event} event An event to be dispatched
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
 * @api public
 */
EventSource.prototype.dispatchEvent = function dispatchEvent (event) {
  if (!event.type) {
    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR')
  }
  // if event is instance of an CustomEvent (or has 'details' property),
  // send the detail object as the payload for the event
  this.emit(event.type, event.detail);
};

/**
 * Emulates the W3C Browser based WebSocket interface using removeEventListener.
 *
 * @param {String} type A string representing the event type to remove
 * @param {Function} listener callback
 * @see https://developer.mozilla.org/en/DOM/element.removeEventListener
 * @see http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */
EventSource.prototype.removeEventListener = function removeEventListener (type, listener) {
  if (typeof listener === 'function') {
    listener._listener = undefined;
    this.removeListener(type, listener);
  }
};

/**
 * W3C Event
 *
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event
 * @api private
 */
function Event (type, optionalProperties) {
  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true });
  if (optionalProperties) {
    for (var f in optionalProperties) {
      if (optionalProperties.hasOwnProperty(f)) {
        Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true });
      }
    }
  }
}

/**
 * W3C MessageEvent
 *
 * @see http://www.w3.org/TR/webmessaging/#event-definitions
 * @api private
 */
function MessageEvent (type, eventInitDict) {
  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true });
  for (var f in eventInitDict) {
    if (eventInitDict.hasOwnProperty(f)) {
      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true });
    }
  }
}

/**
 * Returns a new object of headers that does not include any authorization and cookie headers
 *
 * @param {Object} headers An object of headers ({[headerName]: headerValue})
 * @return {Object} a new object of headers
 * @api private
 */
function removeUnsafeHeaders (headers) {
  var safe = {};
  for (var key in headers) {
    if (reUnsafeHeader.test(key)) {
      continue
    }

    safe[key] = headers[key];
  }

  return safe
}

var defaultSetupOptions = {
  distinctId: null,
  version: '0',
  configurationFetchedHandler: function configurationFetchedHandler() {},
  eventSourceImpl: eventsource,
  impressionHandler: null,
  fetchIntervalInSec: 60,
  devModeSecret: null,
  platform: 'NodeJS'
};

var CustomProperty = roxBase.exports.Entities.CustomProperty;


function getDefaultCustomProperties(deviceProps, appKey) {
  var distinctId = deviceProps.distinct_id;
  if (!deviceProps.distinctIdSetExplicitly) {
    distinctId = function distinctId(_) {
      return deviceProps.generateDistinctId();
    };
  }
  var _props = deviceProps.getProperties();

  return [new CustomProperty('rox.app_release', CustomProperty.semverTypeName, _props.app_release), new CustomProperty('rox.platform', String, _props.platform), new CustomProperty('rox.distinct_id', String, distinctId), new CustomProperty('rox.internal.realPlatform', String, 'NodeJS'), new CustomProperty('rox.internal.customPlatform', String, _props.platform), new CustomProperty('rox.internal.appKey', String, appKey), new CustomProperty('rox.internal.distinct_id', String, function () {
    return v4();
  }), new CustomProperty('rox.now', Date, function () {
    return new Date();
  })];
}

var roxCrypto = {};

Object.defineProperty(roxCrypto, '__esModule', { value: true });

var crypto = require$$0__default$3["default"];

function _interopDefaultLegacy$1 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var crypto__default = /*#__PURE__*/_interopDefaultLegacy$1(crypto);

const publicKey =
  '-----BEGIN RSA PUBLIC KEY-----\n\
MIIBCgKCAQEA6vBjERS8mkFQxHXB5WJuzZxqwKoSz9hP9u1ttck0Hop+6/BTk/+4\n\
ydDy6XBi8P98w0+cMyCdzrRcuB1q3toZ+8JrfmyPm20v/ZCq5qpKYwI9fj8JweJY\n\
RGndu5aJTArs+abq6ottPZO6udSDHX6tPzrez/wZqfiwTbNheIzLD2MWVFGJFUwJ\n\
j6oJ8MblqCWWp/zhjY7Y/ThoPHjnDn3MsQuBg0f2GopfpIbeCPxx3rEl1bpKl57b\n\
G3YJ1yhZF+vNk7hT3N6XfJcvujejklqWzVfFJhFWcoJ8Vk978QU9k1rxXsW1udij\n\
hWPdcCJI7fiDxDDyQTzw4jfSdp7rbb3zKQIDAQAB\n\
-----END RSA PUBLIC KEY-----';

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_HASH_FUNC = 'SHA256';
var DEFAULT_SIGNATURE_ENCODING = 'base64';
var DEFAULT_PAYLOAD_ENCODING = 'utf-8';

var RoxCrypto = function () {
  function RoxCrypto() {
    _classCallCheck$5(this, RoxCrypto);
  }

  _createClass$5(RoxCrypto, null, [{
    key: 'verify',
    value: function verify(payload) {
      var signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var hash_algo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_HASH_FUNC;

      if (payload.constructor !== String) {
        payload = JSON.stringify(payload);
      }
      var verifier = crypto__default["default"].createVerify(hash_algo);
      verifier.update(payload, DEFAULT_PAYLOAD_ENCODING);

      return verifier.verify(publicKey, signature, DEFAULT_SIGNATURE_ENCODING);
    }
  }]);

  return RoxCrypto;
}();

var RoxCrypto_1 = roxCrypto.RoxCrypto = RoxCrypto;

var OVERRIDE_CACHE_KEY = 'roxOverrideValues';

var cache = RoxCache$1.get(OVERRIDE_CACHE_KEY);
if (!cache) {
  cache = {};
} else {
  cache = JSON.parse(cache);
}

function writeCache(cache) {
  RoxCache$1.set(OVERRIDE_CACHE_KEY, JSON.stringify(cache));
}

function hasOverride() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (typeof name === 'undefined') return false;
  return typeof cache[name] !== 'undefined';
}

function getOverride() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  if (!name) throw new Error('Missing name');
  return cache[name];
}

function setOverride(name, value) {
  if (!name) throw new Error('Missing name');
  cache[name] = value;
  writeCache(cache);
}

function clearOverride(name) {
  if (!name) throw new Error('Missing name');
  cache[name] = undefined;
  delete cache[name];
  writeCache(cache);
}

function clearAllOverrides() {
  cache = {};
  writeCache(cache);
}

function getOriginalValue(name) {
  if (!name) throw new Error('Missing name');
  var flag = roxBase.exports.Repositories.Flags.flagWithName(name);
  if (!flag) return null;
  return flag._originalValue();
}

var overrides = /*#__PURE__*/Object.freeze({
	__proto__: null,
	hasOverride: hasOverride,
	getOverride: getOverride,
	setOverride: setOverride,
	clearOverride: clearOverride,
	clearAllOverrides: clearAllOverrides,
	getOriginalValue: getOriginalValue
});

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _RoxBase$Entities$2 = roxBase.exports.Entities,
    FlagTypes$2 = _RoxBase$Entities$2.FlagTypes,
    RoxStringBase$2 = _RoxBase$Entities$2.RoxStringBase;
var RoxxParser = roxBase.exports.Parsers.RoxxParser;

var Context = roxBase.exports.Context;

var parser = new RoxxParser();

var RoxStringNode = function (_RoxStringBase) {
  _inherits$2(RoxStringNode, _RoxStringBase);

  function RoxStringNode(defaultValue, variations) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : FlagTypes$2.string;

    _classCallCheck$4(this, RoxStringNode);

    var _this = _possibleConstructorReturn$2(this, (RoxStringNode.__proto__ || Object.getPrototypeOf(RoxStringNode)).call(this, defaultValue, variations, type));

    _this._freezable = false;
    return _this;
  }

  _createClass$4(RoxStringNode, [{
    key: 'getActiveValue',
    value: function getActiveValue(callContext, context) {
      var returnValue = callContext.alternativeDefaultValue != null ? callContext.alternativeDefaultValue : this._defaultValue;
      var contextUsed = context;
      var experimenting = false;
      if (this.condition) {
        var mergedContext = Context.Actions.getMergedContextWithGlobal(context);
        contextUsed = mergedContext;
        var evaluatedResult = parser.evaluateExpression(this.condition, callContext, mergedContext);
        var castedResult = evaluatedResult && evaluatedResult.toString ? evaluatedResult.toString() : evaluatedResult;

        if (typeof castedResult !== 'undefined') {
          experimenting = true;
          returnValue = castedResult;
        }
      }
      callContext.result = { usedContext: contextUsed, value: returnValue, isExperimenting: experimenting };
    }
  }, {
    key: 'getInternalValue',
    value: function getInternalValue(callContext, context) {
      var overridenValue = this.overridenValue;
      if (overridenValue) {
        callContext.result = { isExperimenting: true, isOverride: true, usedContext: context, value: overridenValue };
        return;
      }

      this.getActiveValue(callContext, context);
      return;
    }
  }, {
    key: 'getValue',
    value: function getValue(context) {
      var callContext = {};
      this.getInternalValue(callContext, context);
      if (!callContext.result.isOverride) {
        this._flagImpression(callContext.result.value, callContext.result.usedContext);
      }
      return callContext.result.value;
    }
  }, {
    key: 'peek',
    value: function peek(context) {
      var callContext = { isPeek: true };
      this.getInternalValue(callContext, context);
      return callContext.result.value;
    }
  }, {
    key: 'overrider',
    get: function get() {
      return overrides;
    }
  }]);

  return RoxStringNode;
}(RoxStringBase$2);

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _RoxBase$Entities$1 = roxBase.exports.Entities,
    FlagTypes$1 = _RoxBase$Entities$1.FlagTypes,
    RoxStringBase$1 = _RoxBase$Entities$1.RoxStringBase;

var RoxFlagNode = function (_RoxStringNode) {
  _inherits$1(RoxFlagNode, _RoxStringNode);

  function RoxFlagNode() {
    var defaultValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck$3(this, RoxFlagNode);

    return _possibleConstructorReturn$1(this, (RoxFlagNode.__proto__ || Object.getPrototypeOf(RoxFlagNode)).call(this, defaultValue, [false, true], FlagTypes$1.boolean));
  }

  _createClass$3(RoxFlagNode, [{
    key: 'isEnabled',
    value: function isEnabled(context) {
      var callContext = {};
      this.getInternalValue(callContext, context);
      var finalValue = RoxStringBase$1._normalizeBoolean(callContext.result.value);
      if (!callContext.result.isOverride) {
        this._flagImpression(finalValue.toString(), callContext.result.usedContext);
      }
      return finalValue;
    }
  }]);

  return RoxFlagNode;
}(RoxStringNode);

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
var _RoxBase$Entities = roxBase.exports.Entities,
    FlagTypes = _RoxBase$Entities.FlagTypes,
    RoxStringBase = _RoxBase$Entities.RoxStringBase;

var RoxNumberNode = function (_RoxStringNode) {
  _inherits(RoxNumberNode, _RoxStringNode);

  function RoxNumberNode(defaultValue, variations) {
    _classCallCheck$2(this, RoxNumberNode);

    return _possibleConstructorReturn(this, (RoxNumberNode.__proto__ || Object.getPrototypeOf(RoxNumberNode)).call(this, defaultValue, variations, FlagTypes.number));
  }

  _createClass$2(RoxNumberNode, [{
    key: 'getValue',
    value: function getValue(context) {
      var callContext = {};
      this.getInternalValue(callContext, context);
      var finalValue = RoxStringBase._normalizeNumber(callContext.result.value);
      if (!callContext.result.isOverride) {
        this._flagImpression(finalValue.toString(), callContext.result.usedContext);
      }
      return finalValue;
    }
  }]);

  return RoxNumberNode;
}(RoxStringNode);

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NodeEntitiesProvider = function () {
  function NodeEntitiesProvider() {
    _classCallCheck$1(this, NodeEntitiesProvider);
  }

  _createClass$1(NodeEntitiesProvider, [{
    key: 'createFlag',
    value: function createFlag(defaultValue) {
      return new RoxFlagNode(defaultValue);
    }
  }, {
    key: 'createString',
    value: function createString(defaultValue, options) {
      return new RoxStringNode(defaultValue, options);
    }
  }, {
    key: 'createNumber',
    value: function createNumber(defaultValue, variations) {
      return new RoxNumberNode(defaultValue, variations);
    }
  }]);

  return NodeEntitiesProvider;
}();

var EntitiesProvider = new NodeEntitiesProvider();

var createRoxClient = roxBase.exports.createRoxClient;


var client = createRoxClient({
  DeviceProperties: DeviceProperties$1,
  getDefaultCustomProperties: getDefaultCustomProperties,
  DefaultSetupOptions: defaultSetupOptions,
  RoxCache: RoxCache$1,
  RoxCrypto: RoxCrypto_1,
  EntitiesProvider: EntitiesProvider
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var RoxLogger = roxBase.exports.RoxLogger,
    configuration = roxBase.exports.Config,
    Repositories = roxBase.exports.Repositories;

var Rox = function () {
  function Rox() {
    _classCallCheck(this, Rox);
  }

  _createClass(Rox, [{
    key: 'setup',

    /**
     * Initiate connection with ROX servers for the application identified by the application key. The registered containers will be synced and Rox entities will get the appropriate values.
     * @param {String} appKey application key as appears in ROX dashboard
     * @param {Object} options optional configuration object
     */
    value: function setup(appKey) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      RoxLogger.setVerboseMode(options.debugLevel);
      if (options.configuration) {
        configuration.setActive(options.configuration);
      } else if (options.hosting) {
        configuration.setHosting(options.hosting);
      }
      if (options.proxy) {
        configuration.setProxy(options.proxy);
      }

      client.setKey(appKey, options);

      return client.setup(options).then(function () {
        if (client.disableNetwork) {
          return client.fetchCacheOnly();
        }
        client.sendState();
        return client.fetchPeriodically();
      });
    }
  }, {
    key: 'setCustomStringProperty',
    value: function setCustomStringProperty(key, value) {
      client.setCustomProperty(key, String, value);
    }
  }, {
    key: 'setCustomDateProperty',
    value: function setCustomDateProperty(key, value) {
      client.setCustomProperty(key, Date, value);
    }
  }, {
    key: 'setCustomNumberProperty',
    value: function setCustomNumberProperty(key, value) {
      client.setCustomProperty(key, Number, value);
    }
  }, {
    key: 'setCustomBooleanProperty',
    value: function setCustomBooleanProperty(key, value) {
      client.setCustomProperty(key, Boolean, value);
    }
  }, {
    key: 'setCustomSemverProperty',
    value: function setCustomSemverProperty(key, value) {
      client.setSemverCustomProperty(key, value);
    }

    /**
     * Register a container of Rox entities by specifiying a namespace.
     * @param {String} name Container name
     * @param {Object} container Object literal whose properties are Rox entities
     */

  }, {
    key: 'register',
    value: function register(name, container) {
      client.register(name, container);
    }
  }, {
    key: 'fetch',
    value: function fetch() {
      client && client.fetch();
    }
  }, {
    key: 'setUserspaceUnhandledErrorHandler',
    value: function setUserspaceUnhandledErrorHandler(handler) {
      client.setUserspaceUnhandledErrorHandler(handler);
    }
  }, {
    key: 'flags',
    get: function get() {
      return Repositories.Flags.flags;
    }
  }, {
    key: 'dynamicApi',
    get: function get() {
      return client.dynamicApi;
    }
  }, {
    key: 'cacheURL',
    get: function get() {
      return client.cacheURL;
    }
  }]);

  return Rox;
}();

var instance = new Rox();

var GET = 'GET';
var POST = 'POST';
var PUT = 'PUT';
var DELETE = 'DELETE';

var FLAGS = '/api/flags';
var INDEX = '/';

var TYPES = {
  HTML: 'text/html; charset=utf-8',
  JSON: 'application/json'
};

var METHODS = {
  GET: GET,
  POST: POST,
  PUT: PUT,
  DELETE: DELETE
};

var ROUTES = {
  INDEX: INDEX,
  FLAGS: FLAGS
};

var flagsPattern = new RegExp('^' + ROUTES.FLAGS + '/?(.+)?');

var allFlagsJSON = function allFlagsJSON() {
  return {
    body: roxBase.exports.Repositories.Flags.flags.map(function (f) {
      return f.dump();
    }),
    type: TYPES.JSON
  };
};

// will change in future
var API_VERSION = 'v0';
var ROXBOARD_SERVER = '//connect.rollout.io/' + API_VERSION;

var serveIndex = function serveIndex() {
  return '<!DOCTYPE html> <html lang="en"><head><meta charset="utf-8" /><title>ROXBoard</title><link rel="stylesheet" href="' + ROXBOARD_SERVER + '/styles.css" /><script>\nvar initialData = ' + JSON.stringify(allFlagsJSON().body) + ';\n</script>\n</head><body><div id="root"></div></body><script src="' + ROXBOARD_SERVER + '/bundle.js"></script></html>';
};

var extractBodyFromRequest = function extractBodyFromRequest(req) {
  return new Promise(function (resolve, reject) {
    try {
      var body = '';
      req.on('readable', function () {
        var data = req.read();
        body = data ? body + data : body;
      });
      req.on('end', function () {
        return resolve(body);
      });
      req.on('close', function () {
        return resolve('');
      });
    } catch (e) {
      reject(e);
    }
  });
};

var handleGET = function handleGET(url) {
  switch (url) {
    case ROUTES.FLAGS:
      return allFlagsJSON();
    default:
      return {
        body: serveIndex(),
        type: TYPES.HTML
      };
  }
};

var handlePOST = function handlePOST(req) {
  switch (req.url) {
    case ROUTES.FLAGS:
      return extractBodyFromRequest(req).then(function (body) {
        if (typeof body === 'string') body = JSON.parse(body);
        if (!(body instanceof Array)) body = [body];

        body.forEach(function (_ref) {
          var name = _ref.name,
              value = _ref.value;

          if (!name || !value) return;
          setOverride(name, value);
        });
        return allFlagsJSON();
      });
    default:
      return Promise.resolve({ code: 404, body: '' });
  }
};

var handleDELETE = function handleDELETE(req) {
  var matched = req.url.match(flagsPattern);
  if (matched) {
    // delete something
    if (matched[1]) {
      // delete specific override
      clearOverride(matched[1]);
    } else {
      // delete all overrides
      clearAllOverrides();
    }
  } else {
    return { code: 404, body: '' };
  }
  return { body: '' };
};

var PORT = 3000;

var requestHandler = function requestHandler(req, res) {
  var response = Promise.resolve({
    body: ''
  });
  var method = req.method,
      url = req.url;

  switch (method) {
    case METHODS.GET:
      response = Promise.resolve(handleGET(url));
      break;
    case METHODS.POST:
      response = Promise.resolve(handlePOST(req));
      break;
    case METHODS.DELETE:
      response = Promise.resolve(handleDELETE(req));
      break;
  }

  response.then(function (_ref) {
    var body = _ref.body,
        type = _ref.type,
        code = _ref.code;

    var _body = typeof body === 'string' ? body : JSON.stringify(body);

    res.writeHead(code || 200, {
      'Content-Length': Buffer.byteLength(_body || ''),
      'Content-Type': type || 'text/plain'
    });

    res.write(_body);
  }).catch(function (error) {
    res.statusCode = 500;
    console.error(error); // eslint-disable-line no-console
  }).then(function () {
    return res.end();
  });
};
var server = require$$3__default["default"].createServer(requestHandler);

function startAdminServer() {
  var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PORT;

  return new Promise(function (resolve, reject) {
    server.listen(port, function (error) {
      if (error) {
        console.error(error); // eslint-disable-line no-console
        return reject(error);
      }
      return resolve(server);
    });
  });
}

instance.startAdminServer = startAdminServer;
instance.setContext = roxBase.exports.Context.Manager.setContext;
instance.RoxString = RoxStringNode;
instance.RoxNumber = RoxNumberNode;
instance.Flag = RoxFlagNode;
instance.overrides = overrides;

module.exports = instance;
